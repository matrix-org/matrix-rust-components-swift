// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(matrix_sdk_ffiFFI)
import matrix_sdk_ffiFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_matrix_sdk_ffi_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureMatrixSdkFfiInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
// Initial value and increment amount for handles. 
// These ensure that SWIFT handles always have the lowest bit set
fileprivate let UNIFFI_HANDLEMAP_INITIAL: UInt64 = 1
fileprivate let UNIFFI_HANDLEMAP_DELTA: UInt64 = 2

fileprivate final class UniffiHandleMap<T>: @unchecked Sendable {
    // All mutation happens with this lock held, which is why we implement @unchecked Sendable.
    private let lock = NSLock()
    private var map: [UInt64: T] = [:]
    private var currentHandle: UInt64 = UNIFFI_HANDLEMAP_INITIAL

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            return doInsert(obj)
        }
    }

    // Low-level insert function, this assumes `lock` is held.
    private func doInsert(_ obj: T) -> UInt64 {
        let handle = currentHandle
        currentHandle += UNIFFI_HANDLEMAP_DELTA
        map[handle] = obj
        return handle
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

     func clone(handle: UInt64) throws -> UInt64 {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return doInsert(obj)
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.
// Magic number for the Rust proxy to call using the same mechanism as every other method,
// to free the callback once it's dropped by Rust.
private let IDX_CALLBACK_FREE: Int32 = 0
// Callback return codes
private let UNIFFI_CALLBACK_SUCCESS: Int32 = 0
private let UNIFFI_CALLBACK_ERROR: Int32 = 1
private let UNIFFI_CALLBACK_UNEXPECTED_ERROR: Int32 = 2

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt16: FfiConverterPrimitive {
    typealias FfiType = UInt16
    typealias SwiftType = UInt16

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt16 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt32: FfiConverterPrimitive {
    typealias FfiType = Int32
    typealias SwiftType = Int32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int32, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterUInt64: FfiConverterPrimitive {
    typealias FfiType = UInt64
    typealias SwiftType = UInt64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterInt64: FfiConverterPrimitive {
    typealias FfiType = Int64
    typealias SwiftType = Int64

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Int64 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Int64, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterFloat: FfiConverterPrimitive {
    typealias FfiType = Float
    typealias SwiftType = Float

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Float {
        return try lift(readFloat(&buf))
    }

    public static func write(_ value: Float, into buf: inout [UInt8]) {
        writeFloat(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDouble: FfiConverterPrimitive {
    typealias FfiType = Double
    typealias SwiftType = Double

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Double {
        return try lift(readDouble(&buf))
    }

    public static func write(_ value: Double, into buf: inout [UInt8]) {
        writeDouble(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimeInterval {
        let seconds: UInt64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        return Double(seconds) + (Double(nanoseconds) / 1.0e9)
    }

    public static func write(_ value: TimeInterval, into buf: inout [UInt8]) {
        if value.rounded(.down) > Double(Int64.max) {
            fatalError("Duration overflow, exceeds max bounds supported by Uniffi")
        }

        if value < 0 {
            fatalError("Invalid duration, must be non-negative")
        }

        let seconds = UInt64(value)
        let nanoseconds = UInt32((value - Double(seconds)) * 1.0e9)
        writeInt(&buf, seconds)
        writeInt(&buf, nanoseconds)
    }
}




/**
 * Used to pass back the [`CheckCode`] entered by the user to verify that the
 * secure channel is indeed secure.
 */
public protocol CheckCodeSenderProtocol: AnyObject, Sendable {
    
    /**
     * Send the [`CheckCode`].
     *
     * Calling this method more than once will result in an error.
     *
     * # Arguments
     *
     * * `check_code` - The check code in digits representation.
     */
    func send(code: UInt8) async throws 
    
}
/**
 * Used to pass back the [`CheckCode`] entered by the user to verify that the
 * secure channel is indeed secure.
 */
open class CheckCodeSender: CheckCodeSenderProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_checkcodesender(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_checkcodesender(handle, $0) }
    }

    

    
    /**
     * Send the [`CheckCode`].
     *
     * Calling this method more than once will result in an error.
     *
     * # Arguments
     *
     * * `check_code` - The check code in digits representation.
     */
open func send(code: UInt8)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_checkcodesender_send(
                    self.uniffiCloneHandle(),
                    FfiConverterUInt8.lower(code)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeHumanQrLoginError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCheckCodeSender: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = CheckCodeSender

    public static func lift(_ handle: UInt64) throws -> CheckCodeSender {
        return CheckCodeSender(unsafeFromHandle: handle)
    }

    public static func lower(_ value: CheckCodeSender) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CheckCodeSender {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: CheckCodeSender, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckCodeSender_lift(_ handle: UInt64) throws -> CheckCodeSender {
    return try FfiConverterTypeCheckCodeSender.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCheckCodeSender_lower(_ value: CheckCodeSender) -> UInt64 {
    return FfiConverterTypeCheckCodeSender.lower(value)
}






public protocol ClientProtocol: AnyObject, Sendable {
    
    /**
     * Aborts an existing OIDC login operation that might have been cancelled,
     * failed etc.
     */
    func abortOidcAuth(authorizationData: OAuthAuthorizationData) async 
    
    /**
     * Get the content of the event of the given type out of the account data
     * store.
     *
     * It will be returned as a JSON string.
     */
    func accountData(eventType: String) async throws  -> String?
    
    func accountUrl(action: AccountManagementAction?) async throws  -> String?
    
    /**
     * Find all sliding sync versions that are available.
     *
     * Be careful: This method may hit the store and will send new requests for
     * each call. It can be costly to call it repeatedly.
     *
     * If `.well-known` or `/versions` is unreachable, it will simply move
     * potential sliding sync versions aside. No error will be reported.
     */
    func availableSlidingSyncVersions() async  -> [SlidingSyncVersion]
    
    /**
     * Sends a request to retrieve the avatar URL. Will fill the cache used by
     * [`Self::cached_avatar_url`] on success.
     */
    func avatarUrl() async throws  -> String?
    
    /**
     * Waits until an at least partially synced room is received, and returns
     * it.
     *
     * **Note: this function will loop endlessly until either it finds the room
     * or an externally set timeout happens.**
     */
    func awaitRoomRemoteEcho(roomId: String) async throws  -> Room
    
    /**
     * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
     */
    func cachedAvatarUrl() async throws  -> String?
    
    /**
     * Lets the user know whether this is an `m.login.password` based
     * auth and if the account can actually be deactivated
     */
    func canDeactivateAccount()  -> Bool
    
    /**
     * Clear all the non-critical caches for this Client instance.
     *
     * WARNING: This will clear all the caches, including the base store (state
     * store), so callers must make sure that the Client is at rest before
     * calling it.
     *
     * In particular, if a [`SyncService`] is running, it must be passed here
     * as a parameter, or stopped before calling this method. Ideally, the
     * send queues should have been disabled and must all be inactive (i.e.
     * not sending events); this method will disable them, but it might not
     * be enough if the queues are still processing events.
     *
     * After the method returns, the Client will be in an unstable
     * state, and it is required that the caller reinstantiates a new
     * Client instance, be it via dropping the previous and re-creating it,
     * restarting their application, or any other similar means.
     *
     * - This will get rid of the backing state store file, if provided.
     * - This will empty all the room's persisted event caches, so all rooms
     * will start as if they were empty.
     * - This will empty the media cache according to the current media
     * retention policy.
     */
    func clearCaches(syncService: SyncService?) async throws 
    
    func createRoom(request: CreateRoomParameters) async throws  -> String
    
    /**
     * Login using JWT
     * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
     * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
     */
    func customLoginWithJwt(jwt: String, initialDeviceName: String?, deviceId: String?) async throws 
    
    /**
     * Deactivate this account definitively.
     * Similarly to `encryption::reset_identity` this
     * will only work with password-based authentication (`m.login.password`)
     *
     * # Arguments
     *
     * * `auth_data` - This request uses the [User-Interactive Authentication
     * API][uiaa]. The first request needs to set this to `None` and will
     * always fail and the same request needs to be made but this time with
     * some `auth_data` provided.
     */
    func deactivateAccount(authData: AuthData?, eraseData: Bool) async throws 
    
    /**
     * Deletes a pusher of given pusher ids
     */
    func deletePusher(identifiers: PusherIdentifiers) async throws 
    
    func deviceId() throws  -> String
    
    func displayName() async throws  -> String
    
    /**
     * Enables or disables all the room send queues at once.
     *
     * When connectivity is lost on a device, it is recommended to disable the
     * room sending queues.
     *
     * This can be controlled for individual rooms, using
     * [`Room::enable_send_queue`].
     */
    func enableAllSendQueues(enable: Bool) async 
    
    /**
     * Enables or disables progress reporting for media uploads in the send
     * queue.
     */
    func enableSendQueueUploadProgress(enable: Bool) 
    
    func encryption()  -> Encryption
    
    /**
     * Fetch the media preview configuration from the server.
     */
    func fetchMediaPreviewConfig() async throws  -> MediaPreviewConfig?
    
    func getDmRoom(userId: String) throws  -> Room?
    
    /**
     * Get the invite request avatars display policy
     * currently stored in the cache.
     */
    func getInviteAvatarsDisplayPolicy() async throws  -> InviteAvatars?
    
    /**
     * Gets the `max_upload_size` value from the homeserver, which controls the
     * max size a media upload request can have.
     */
    func getMaxMediaUploadSize() async throws  -> UInt64
    
    func getMediaContent(mediaSource: MediaSource) async throws  -> Data
    
    /**
     * Retrieves a media file from the media source
     *
     * Not available on Wasm platforms, due to lack of accessible file system.
     */
    func getMediaFile(mediaSource: MediaSource, filename: String?, mimeType: String, useCache: Bool, tempDir: String?) async throws  -> MediaFileHandle
    
    /**
     * Get the media previews timeline display policy
     * currently stored in the cache.
     */
    func getMediaPreviewDisplayPolicy() async throws  -> MediaPreviews?
    
    func getMediaThumbnail(mediaSource: MediaSource, width: UInt64, height: UInt64) async throws  -> Data
    
    func getNotificationSettings() async  -> NotificationSettings
    
    func getProfile(userId: String) async throws  -> UserProfile
    
    func getRecentlyVisitedRooms() async throws  -> [String]
    
    /**
     * Get a room by its ID.
     *
     * # Arguments
     *
     * * `room_id` - The ID of the room to get.
     *
     * # Returns
     *
     * A `Result` containing an optional room, or a `ClientError`.
     * This method will not initialize the room's timeline or populate it with
     * events.
     */
    func getRoom(roomId: String) throws  -> Room?
    
    /**
     * Given a room alias, get the preview of a room, to interact with it.
     */
    func getRoomPreviewFromRoomAlias(roomAlias: String) async throws  -> RoomPreview
    
    /**
     * Given a room id, get the preview of a room, to interact with it.
     *
     * The list of `via_servers` must be a list of servers that know
     * about the room and can resolve it, and that may appear as a `via`
     * parameter in e.g. a permalink URL. This list can be empty.
     */
    func getRoomPreviewFromRoomId(roomId: String, viaServers: [String]) async throws  -> RoomPreview
    
    func getSessionVerificationController() async throws  -> SessionVerificationController
    
    /**
     * Returns the sizes of the existing stores, if known.
     */
    func getStoreSizes() async throws  -> StoreSizes
    
    /**
     * Allows generic GET requests to be made through the SDK's internal HTTP
     * client. This is useful when the caller's native HTTP client wouldn't
     * have the same configuration (such as certificates, proxies, etc.) This
     * method returns the raw bytes of the response, so that any kind of
     * resource can be fetched including images, files, etc.
     *
     * Note: When an HTTP error occurs, the error response can be found in the
     * `ClientError::Generic`'s `details` field.
     */
    func getUrl(url: String) async throws  -> Data
    
    /**
     * The homeserver this client is configured to use.
     */
    func homeserver()  -> String
    
    /**
     * Information about login options for the client's homeserver.
     */
    func homeserverLoginDetails() async  -> HomeserverLoginDetails
    
    func ignoreUser(userId: String) async throws 
    
    func ignoredUsers() async throws  -> [String]
    
    /**
     * Checks if the server supports the LiveKit RTC focus for placing calls.
     */
    func isLivekitRtcSupported() async throws  -> Bool
    
    /**
     * Checks if the server supports login using a QR code.
     */
    func isLoginWithQrCodeSupported() async throws  -> Bool
    
    /**
     * Checks if the server supports the report room API.
     */
    func isReportRoomApiSupported() async throws  -> Bool
    
    /**
     * Checks if a room alias is not in use yet.
     *
     * Returns:
     * - `Ok(true)` if the room alias is available.
     * - `Ok(false)` if it's not (the resolve alias request returned a `404`
     * status code).
     * - An `Err` otherwise.
     */
    func isRoomAliasAvailable(alias: String) async throws  -> Bool
    
    /**
     * Join a room by its ID.
     *
     * Use this method when the homeserver already knows of the given room ID.
     * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
     * server names for the homeserver to find the room.
     */
    func joinRoomById(roomId: String) async throws  -> Room
    
    /**
     * Join a room by its ID or alias.
     *
     * When supplying the room's ID, you can also supply a list of server names
     * for the homeserver to find the room. Typically these server names
     * come from a permalink's `via` parameters, or from resolving a room's
     * alias into an ID.
     */
    func joinRoomByIdOrAlias(roomIdOrAlias: String, serverNames: [String]) async throws  -> Room
    
    /**
     * Knock on a room to join it using its ID or alias.
     */
    func knock(roomIdOrAlias: String, reason: String?, serverNames: [String]) async throws  -> Room
    
    /**
     * Login using a username and password.
     */
    func login(username: String, password: String, initialDeviceName: String?, deviceId: String?) async throws 
    
    /**
     * Login using an email and password.
     */
    func loginWithEmail(email: String, password: String, initialDeviceName: String?, deviceId: String?) async throws 
    
    /**
     * Completes the OIDC login process.
     */
    func loginWithOidcCallback(callbackUrl: String) async throws 
    
    /**
     * Log the current user out.
     */
    func logout() async throws 
    
    /**
     * Create a handler for granting login from this device to a new device by
     * way of a QR code.
     */
    func newGrantLoginWithQrCodeHandler()  -> GrantLoginWithQrCodeHandler
    
    /**
     * Create a handler for requesting an existing device to grant login to
     * this device by way of a QR code.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The data to restore or register the client with
     * the server.
     */
    func newLoginWithQrCodeHandler(oidcConfiguration: OidcConfiguration)  -> LoginWithQrCodeHandler
    
    func notificationClient(processSetup: NotificationProcessSetup) async throws  -> NotificationClient
    
    /**
     * Subscribe to updates of global account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
    func observeAccountDataEvent(eventType: AccountDataEventType, listener: AccountDataListener)  -> TaskHandle
    
    /**
     * Subscribe to updates of room account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
    func observeRoomAccountDataEvent(roomId: String, eventType: RoomAccountDataEventType, listener: RoomAccountDataListener) throws  -> TaskHandle
    
    /**
     * Perform database optimizations if any are available, i.e. vacuuming in
     * SQLite.
     */
    func optimizeStores() async throws 
    
    /**
     * Register a handler for notifications generated from sync responses.
     *
     * The handler will be called during sync for each event that triggers
     * a notification based on the user's push rules.
     *
     * The handler receives:
     * - The notification with push actions and event data
     * - The room ID where the notification occurred
     *
     * This is useful for implementing custom notification logic, such as
     * displaying local notifications or updating notification badges.
     */
    func registerNotificationHandler(listener: SyncNotificationListener) async 
    
    func removeAvatar() async throws 
    
    /**
     * Empty the server version and unstable features cache.
     *
     * Since the SDK caches the supported versions, it's possible to have a
     * stale entry in the cache. This functions makes it possible to force
     * reset it.
     */
    func resetSupportedVersions() async throws 
    
    /**
     * Empty the well-known cache.
     *
     * Since the SDK caches the well-known, it's possible to have a stale
     * entry in the cache. This functions makes it possible to force reset
     * it.
     */
    func resetWellKnown() async throws 
    
    /**
     * Resolves the given room alias to a room ID (and a list of servers), if
     * possible.
     */
    func resolveRoomAlias(roomAlias: String) async throws  -> ResolvedRoomAlias?
    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads the entire set of rooms from the previous session.
     *
     * If you want to control the amount of rooms to reloads, check
     * [`Client::restore_session_with`].
     */
    func restoreSession(session: Session) async throws 
    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads a set of rooms controlled by [`RoomLoadSettings`].
     */
    func restoreSessionWith(session: Session, roomLoadSettings: RoomLoadSettings) async throws 
    
    /**
     * Checks if a room alias exists in the current homeserver.
     */
    func roomAliasExists(roomAlias: String) async throws  -> Bool
    
    func roomDirectorySearch()  -> RoomDirectorySearch
    
    func rooms()  -> [Room]
    
    func searchUsers(searchTerm: String, limit: UInt64) async throws  -> SearchUsersResults
    
    /**
     * The URL of the server.
     *
     * Not to be confused with the `Self::homeserver`. `server` is usually
     * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
     * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
     * homeserver (at the time of writing â€” 2024-08-28).
     *
     * This value is optional depending on how the `Client` has been built.
     * If it's been built from a homeserver URL directly, we don't know the
     * server. However, if the `Client` has been built from a server URL or
     * name, then the homeserver has been discovered, and we know both.
     */
    func server()  -> String?
    
    /**
     * Get server vendor information from the federation API.
     *
     * This method retrieves information about the server's name and version
     * by calling the `/_matrix/federation/v1/version` endpoint.
     */
    func serverVendorInfo() async throws  -> ServerVendorInfo
    
    func session() throws  -> Session
    
    /**
     * Set the given account data content for the given event type.
     *
     * It should be supplied as a JSON string.
     */
    func setAccountData(eventType: String, content: String) async throws 
    
    /**
     * Sets the [ClientDelegate] which will inform about authentication errors.
     * Returns an error if the delegate was already set.
     */
    func setDelegate(delegate: ClientDelegate?) throws  -> TaskHandle?
    
    func setDisplayName(name: String) async throws 
    
    /**
     * Set the invite request avatars display policy
     */
    func setInviteAvatarsDisplayPolicy(policy: InviteAvatars) async throws 
    
    /**
     * Set the media previews timeline display policy
     */
    func setMediaPreviewDisplayPolicy(policy: MediaPreviews) async throws 
    
    /**
     * Set the media retention policy.
     */
    func setMediaRetentionPolicy(policy: MediaRetentionPolicy) async throws 
    
    /**
     * Registers a pusher with given parameters
     */
    func setPusher(identifiers: PusherIdentifiers, kind: PusherKind, appDisplayName: String, deviceDisplayName: String, profileTag: String?, lang: String) async throws 
    
    /**
     * Sets the [UnableToDecryptDelegate] which will inform about UTDs.
     * Returns an error if the delegate was already set.
     */
    func setUtdDelegate(utdDelegate: UnableToDecryptDelegate) async throws 
    
    /**
     * The sliding sync version.
     */
    func slidingSyncVersion()  -> SlidingSyncVersion
    
    func spaceService() async  -> SpaceService
    
    /**
     * Returns a handler to start the SSO login process.
     */
    func startSsoLogin(redirectUrl: String, idpId: String?) async throws  -> SsoHandler
    
    func subscribeToIgnoredUsers(listener: IgnoredUsersListener)  -> TaskHandle
    
    /**
     * Subscribe to changes in the media preview configuration.
     */
    func subscribeToMediaPreviewConfig(listener: MediaPreviewConfigListener) async throws  -> TaskHandle
    
    /**
     * Subscribe to [`RoomInfo`] updates given a provided [`RoomId`].
     *
     * This works even for rooms we haven't received yet, so we can subscribe
     * to this and wait until we receive updates from them when sync responses
     * are processed.
     *
     * Note this method should be used sparingly since using callback
     * interfaces is expensive, as well as keeping them alive for a long
     * time. Usages of this method should be short-lived and dropped as
     * soon as possible.
     */
    func subscribeToRoomInfo(roomId: String, listener: RoomInfoListener) async throws  -> TaskHandle
    
    /**
     * Subscribe to the global enablement status of the send queue, at the
     * client-wide level.
     *
     * The given listener will be immediately called with the initial value of
     * the enablement status.
     */
    func subscribeToSendQueueStatus(listener: SendQueueRoomErrorListener)  -> TaskHandle
    
    /**
     * Subscribe to the global send queue update reporter, at the
     * client-wide level.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    func subscribeToSendQueueUpdates(listener: SendQueueRoomUpdateListener) async throws  -> TaskHandle
    
    func syncService()  -> SyncServiceBuilder
    
    func trackRecentlyVisitedRoom(room: String) async throws 
    
    func unignoreUser(userId: String) async throws 
    
    func uploadAvatar(mimeType: String, data: Data) async throws 
    
    func uploadMedia(mimeType: String, data: Data, progressWatcher: ProgressWatcher?) async throws  -> String
    
    /**
     * Requests the URL needed for opening a web view using OIDC. Once the web
     * view has succeeded, call `login_with_oidc_callback` with the callback it
     * returns. If a failure occurs and a callback isn't available, make sure
     * to call `abort_oidc_auth` to inform the client of this.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The configuration used to load the credentials
     * of the client if it is already registered with the authorization
     * server, or register the client and store its credentials if it isn't.
     *
     * * `prompt` - The desired user experience in the web UI. No value means
     * that the user wishes to login into an existing account, and a value of
     * `Create` means that the user wishes to register a new account.
     *
     * * `login_hint` - A generic login hint that an identity provider can use
     * to pre-fill the login form. The format of this hint is not restricted
     * by the spec as external providers all have their own way to handle the hint.
     * However, it should be noted that when providing a user ID as a hint
     * for MAS (with no upstream provider), then the format to use is defined
     * by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
     *
     * * `device_id` - The unique ID that will be associated with the session.
     * If not set, a random one will be generated. It can be an existing
     * device ID from a previous login call. Note that this should be done
     * only if the client also holds the corresponding encryption keys.
     *
     * * `additional_scopes` - Additional scopes to request from the
     * authorization server, e.g. "urn:matrix:client:com.example.msc9999.foo".
     * The scopes for API access and the device ID according to the
     * [specification](https://spec.matrix.org/v1.15/client-server-api/#allocated-scope-tokens)
     * are always requested.
     */
    func urlForOidc(oidcConfiguration: OidcConfiguration, prompt: OidcPrompt?, loginHint: String?, deviceId: String?, additionalScopes: [String]?) async throws  -> OAuthAuthorizationData
    
    func userId() throws  -> String
    
    /**
     * The server name part of the current user ID
     */
    func userIdServerName() throws  -> String
    
    /**
     * Adds a recently used emoji to the list and uploads the updated
     * `io.element.recent_emoji` content to the global account data.
     */
    func addRecentEmoji(emoji: String) async throws 
    
    /**
     * Gets the list of recently used emojis from the
     * `io.element.recent_emoji` global account data.
     */
    func getRecentEmojis() async throws  -> [RecentEmoji]
    
}
open class Client: ClientProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_client(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_client(handle, $0) }
    }

    

    
    /**
     * Aborts an existing OIDC login operation that might have been cancelled,
     * failed etc.
     */
open func abortOidcAuth(authorizationData: OAuthAuthorizationData)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_abort_oidc_auth(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeOAuthAuthorizationData_lower(authorizationData)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Get the content of the event of the given type out of the account data
     * store.
     *
     * It will be returned as a JSON string.
     */
open func accountData(eventType: String)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_account_data(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventType)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func accountUrl(action: AccountManagementAction?)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_account_url(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionTypeAccountManagementAction.lower(action)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Find all sliding sync versions that are available.
     *
     * Be careful: This method may hit the store and will send new requests for
     * each call. It can be costly to call it repeatedly.
     *
     * If `.well-known` or `/versions` is unreachable, it will simply move
     * potential sliding sync versions aside. No error will be reported.
     */
open func availableSlidingSyncVersions()async  -> [SlidingSyncVersion]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_available_sliding_sync_versions(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSlidingSyncVersion.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Sends a request to retrieve the avatar URL. Will fill the cache used by
     * [`Self::cached_avatar_url`] on success.
     */
open func avatarUrl()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_avatar_url(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Waits until an at least partially synced room is received, and returns
     * it.
     *
     * **Note: this function will loop endlessly until either it finds the room
     * or an externally set timeout happens.**
     */
open func awaitRoomRemoteEcho(roomId: String)async throws  -> Room  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_await_room_remote_echo(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoom_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Retrieves an avatar cached from a previous call to [`Self::avatar_url`].
     */
open func cachedAvatarUrl()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_cached_avatar_url(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Lets the user know whether this is an `m.login.password` based
     * auth and if the account can actually be deactivated
     */
open func canDeactivateAccount() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_can_deactivate_account(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Clear all the non-critical caches for this Client instance.
     *
     * WARNING: This will clear all the caches, including the base store (state
     * store), so callers must make sure that the Client is at rest before
     * calling it.
     *
     * In particular, if a [`SyncService`] is running, it must be passed here
     * as a parameter, or stopped before calling this method. Ideally, the
     * send queues should have been disabled and must all be inactive (i.e.
     * not sending events); this method will disable them, but it might not
     * be enough if the queues are still processing events.
     *
     * After the method returns, the Client will be in an unstable
     * state, and it is required that the caller reinstantiates a new
     * Client instance, be it via dropping the previous and re-creating it,
     * restarting their application, or any other similar means.
     *
     * - This will get rid of the backing state store file, if provided.
     * - This will empty all the room's persisted event caches, so all rooms
     * will start as if they were empty.
     * - This will empty the media cache according to the current media
     * retention policy.
     */
open func clearCaches(syncService: SyncService?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_clear_caches(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionTypeSyncService.lower(syncService)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func createRoom(request: CreateRoomParameters)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_create_room(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeCreateRoomParameters_lower(request)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Login using JWT
     * This is an implementation of the custom_login https://docs.rs/matrix-sdk/latest/matrix_sdk/matrix_auth/struct.MatrixAuth.html#method.login_custom
     * For more information on logging in with JWT: https://element-hq.github.io/synapse/latest/jwt.html
     */
open func customLoginWithJwt(jwt: String, initialDeviceName: String?, deviceId: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_custom_login_with_jwt(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(jwt),FfiConverterOptionString.lower(initialDeviceName),FfiConverterOptionString.lower(deviceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Deactivate this account definitively.
     * Similarly to `encryption::reset_identity` this
     * will only work with password-based authentication (`m.login.password`)
     *
     * # Arguments
     *
     * * `auth_data` - This request uses the [User-Interactive Authentication
     * API][uiaa]. The first request needs to set this to `None` and will
     * always fail and the same request needs to be made but this time with
     * some `auth_data` provided.
     */
open func deactivateAccount(authData: AuthData?, eraseData: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_deactivate_account(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionTypeAuthData.lower(authData),FfiConverterBool.lower(eraseData)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Deletes a pusher of given pusher ids
     */
open func deletePusher(identifiers: PusherIdentifiers)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_delete_pusher(
                    self.uniffiCloneHandle(),
                    FfiConverterTypePusherIdentifiers_lower(identifiers)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func deviceId()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_device_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func displayName()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_display_name(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Enables or disables all the room send queues at once.
     *
     * When connectivity is lost on a device, it is recommended to disable the
     * room sending queues.
     *
     * This can be controlled for individual rooms, using
     * [`Room::enable_send_queue`].
     */
open func enableAllSendQueues(enable: Bool)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_enable_all_send_queues(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(enable)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Enables or disables progress reporting for media uploads in the send
     * queue.
     */
open func enableSendQueueUploadProgress(enable: Bool)  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_enable_send_queue_upload_progress(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(enable),$0
    )
}
}
    
open func encryption() -> Encryption  {
    return try!  FfiConverterTypeEncryption_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_encryption(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Fetch the media preview configuration from the server.
     */
open func fetchMediaPreviewConfig()async throws  -> MediaPreviewConfig?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_fetch_media_preview_config(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeMediaPreviewConfig.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func getDmRoom(userId: String)throws  -> Room?  {
    return try  FfiConverterOptionTypeRoom.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_dm_room(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
    /**
     * Get the invite request avatars display policy
     * currently stored in the cache.
     */
open func getInviteAvatarsDisplayPolicy()async throws  -> InviteAvatars?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_invite_avatars_display_policy(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeInviteAvatars.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Gets the `max_upload_size` value from the homeserver, which controls the
     * max size a media upload request can have.
     */
open func getMaxMediaUploadSize()async throws  -> UInt64  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_max_media_upload_size(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterUInt64.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func getMediaContent(mediaSource: MediaSource)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_media_content(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeMediaSource_lower(mediaSource)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Retrieves a media file from the media source
     *
     * Not available on Wasm platforms, due to lack of accessible file system.
     */
open func getMediaFile(mediaSource: MediaSource, filename: String?, mimeType: String, useCache: Bool, tempDir: String?)async throws  -> MediaFileHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_media_file(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeMediaSource_lower(mediaSource),FfiConverterOptionString.lower(filename),FfiConverterString.lower(mimeType),FfiConverterBool.lower(useCache),FfiConverterOptionString.lower(tempDir)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeMediaFileHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get the media previews timeline display policy
     * currently stored in the cache.
     */
open func getMediaPreviewDisplayPolicy()async throws  -> MediaPreviews?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_media_preview_display_policy(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeMediaPreviews.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func getMediaThumbnail(mediaSource: MediaSource, width: UInt64, height: UInt64)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_media_thumbnail(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeMediaSource_lower(mediaSource),FfiConverterUInt64.lower(width),FfiConverterUInt64.lower(height)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func getNotificationSettings()async  -> NotificationSettings  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_notification_settings(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeNotificationSettings_lift,
            errorHandler: nil
            
        )
}
    
open func getProfile(userId: String)async throws  -> UserProfile  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_profile(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeUserProfile_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func getRecentlyVisitedRooms()async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_recently_visited_rooms(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get a room by its ID.
     *
     * # Arguments
     *
     * * `room_id` - The ID of the room to get.
     *
     * # Returns
     *
     * A `Result` containing an optional room, or a `ClientError`.
     * This method will not initialize the room's timeline or populate it with
     * events.
     */
open func getRoom(roomId: String)throws  -> Room?  {
    return try  FfiConverterOptionTypeRoom.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_get_room(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(roomId),$0
    )
})
}
    
    /**
     * Given a room alias, get the preview of a room, to interact with it.
     */
open func getRoomPreviewFromRoomAlias(roomAlias: String)async throws  -> RoomPreview  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_alias(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomAlias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomPreview_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Given a room id, get the preview of a room, to interact with it.
     *
     * The list of `via_servers` must be a list of servers that know
     * about the room and can resolve it, and that may appear as a `via`
     * parameter in e.g. a permalink URL. This list can be empty.
     */
open func getRoomPreviewFromRoomId(roomId: String, viaServers: [String])async throws  -> RoomPreview  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_room_preview_from_room_id(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId),FfiConverterSequenceString.lower(viaServers)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomPreview_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func getSessionVerificationController()async throws  -> SessionVerificationController  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_session_verification_controller(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeSessionVerificationController_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns the sizes of the existing stores, if known.
     */
open func getStoreSizes()async throws  -> StoreSizes  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_store_sizes(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeStoreSizes_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Allows generic GET requests to be made through the SDK's internal HTTP
     * client. This is useful when the caller's native HTTP client wouldn't
     * have the same configuration (such as certificates, proxies, etc.) This
     * method returns the raw bytes of the response, so that any kind of
     * resource can be fetched including images, files, etc.
     *
     * Note: When an HTTP error occurs, the error response can be found in the
     * `ClientError::Generic`'s `details` field.
     */
open func getUrl(url: String)async throws  -> Data  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_url(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(url)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterData.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * The homeserver this client is configured to use.
     */
open func homeserver() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_homeserver(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Information about login options for the client's homeserver.
     */
open func homeserverLoginDetails()async  -> HomeserverLoginDetails  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_homeserver_login_details(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeHomeserverLoginDetails_lift,
            errorHandler: nil
            
        )
}
    
open func ignoreUser(userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_ignore_user(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func ignoredUsers()async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_ignored_users(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Checks if the server supports the LiveKit RTC focus for placing calls.
     */
open func isLivekitRtcSupported()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_is_livekit_rtc_supported(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Checks if the server supports login using a QR code.
     */
open func isLoginWithQrCodeSupported()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_is_login_with_qr_code_supported(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Checks if the server supports the report room API.
     */
open func isReportRoomApiSupported()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_is_report_room_api_supported(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Checks if a room alias is not in use yet.
     *
     * Returns:
     * - `Ok(true)` if the room alias is available.
     * - `Ok(false)` if it's not (the resolve alias request returned a `404`
     * status code).
     * - An `Err` otherwise.
     */
open func isRoomAliasAvailable(alias: String)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_is_room_alias_available(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(alias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Join a room by its ID.
     *
     * Use this method when the homeserver already knows of the given room ID.
     * Otherwise use `join_room_by_id_or_alias` so you can pass a list of
     * server names for the homeserver to find the room.
     */
open func joinRoomById(roomId: String)async throws  -> Room  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoom_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Join a room by its ID or alias.
     *
     * When supplying the room's ID, you can also supply a list of server names
     * for the homeserver to find the room. Typically these server names
     * come from a permalink's `via` parameters, or from resolving a room's
     * alias into an ID.
     */
open func joinRoomByIdOrAlias(roomIdOrAlias: String, serverNames: [String])async throws  -> Room  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_join_room_by_id_or_alias(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomIdOrAlias),FfiConverterSequenceString.lower(serverNames)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoom_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Knock on a room to join it using its ID or alias.
     */
open func knock(roomIdOrAlias: String, reason: String?, serverNames: [String])async throws  -> Room  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_knock(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomIdOrAlias),FfiConverterOptionString.lower(reason),FfiConverterSequenceString.lower(serverNames)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoom_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Login using a username and password.
     */
open func login(username: String, password: String, initialDeviceName: String?, deviceId: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_login(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(username),FfiConverterString.lower(password),FfiConverterOptionString.lower(initialDeviceName),FfiConverterOptionString.lower(deviceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Login using an email and password.
     */
open func loginWithEmail(email: String, password: String, initialDeviceName: String?, deviceId: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_login_with_email(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(email),FfiConverterString.lower(password),FfiConverterOptionString.lower(initialDeviceName),FfiConverterOptionString.lower(deviceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Completes the OIDC login process.
     */
open func loginWithOidcCallback(callbackUrl: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_login_with_oidc_callback(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(callbackUrl)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeOidcError_lift
        )
}
    
    /**
     * Log the current user out.
     */
open func logout()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_logout(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Create a handler for granting login from this device to a new device by
     * way of a QR code.
     */
open func newGrantLoginWithQrCodeHandler() -> GrantLoginWithQrCodeHandler  {
    return try!  FfiConverterTypeGrantLoginWithQrCodeHandler_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_new_grant_login_with_qr_code_handler(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Create a handler for requesting an existing device to grant login to
     * this device by way of a QR code.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The data to restore or register the client with
     * the server.
     */
open func newLoginWithQrCodeHandler(oidcConfiguration: OidcConfiguration) -> LoginWithQrCodeHandler  {
    return try!  FfiConverterTypeLoginWithQrCodeHandler_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_new_login_with_qr_code_handler(
            self.uniffiCloneHandle(),
        FfiConverterTypeOidcConfiguration_lower(oidcConfiguration),$0
    )
})
}
    
open func notificationClient(processSetup: NotificationProcessSetup)async throws  -> NotificationClient  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_notification_client(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeNotificationProcessSetup_lower(processSetup)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeNotificationClient_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Subscribe to updates of global account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
open func observeAccountDataEvent(eventType: AccountDataEventType, listener: AccountDataListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_observe_account_data_event(
            self.uniffiCloneHandle(),
        FfiConverterTypeAccountDataEventType_lower(eventType),
        FfiConverterCallbackInterfaceAccountDataListener_lower(listener),$0
    )
})
}
    
    /**
     * Subscribe to updates of room account data events.
     *
     * Be careful that only the most recent value can be observed. Subscribers
     * are notified when a new value is sent, but there is no guarantee that
     * they will see all values.
     */
open func observeRoomAccountDataEvent(roomId: String, eventType: RoomAccountDataEventType, listener: RoomAccountDataListener)throws  -> TaskHandle  {
    return try  FfiConverterTypeTaskHandle_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_observe_room_account_data_event(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(roomId),
        FfiConverterTypeRoomAccountDataEventType_lower(eventType),
        FfiConverterCallbackInterfaceRoomAccountDataListener_lower(listener),$0
    )
})
}
    
    /**
     * Perform database optimizations if any are available, i.e. vacuuming in
     * SQLite.
     */
open func optimizeStores()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_optimize_stores(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Register a handler for notifications generated from sync responses.
     *
     * The handler will be called during sync for each event that triggers
     * a notification based on the user's push rules.
     *
     * The handler receives:
     * - The notification with push actions and event data
     * - The room ID where the notification occurred
     *
     * This is useful for implementing custom notification logic, such as
     * displaying local notifications or updating notification badges.
     */
open func registerNotificationHandler(listener: SyncNotificationListener)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_register_notification_handler(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceSyncNotificationListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func removeAvatar()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_remove_avatar(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Empty the server version and unstable features cache.
     *
     * Since the SDK caches the supported versions, it's possible to have a
     * stale entry in the cache. This functions makes it possible to force
     * reset it.
     */
open func resetSupportedVersions()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_reset_supported_versions(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Empty the well-known cache.
     *
     * Since the SDK caches the well-known, it's possible to have a stale
     * entry in the cache. This functions makes it possible to force reset
     * it.
     */
open func resetWellKnown()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_reset_well_known(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Resolves the given room alias to a room ID (and a list of servers), if
     * possible.
     */
open func resolveRoomAlias(roomAlias: String)async throws  -> ResolvedRoomAlias?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_resolve_room_alias(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomAlias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeResolvedRoomAlias.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads the entire set of rooms from the previous session.
     *
     * If you want to control the amount of rooms to reloads, check
     * [`Client::restore_session_with`].
     */
open func restoreSession(session: Session)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_restore_session(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeSession_lower(session)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Restores the client from a `Session`.
     *
     * It reloads a set of rooms controlled by [`RoomLoadSettings`].
     */
open func restoreSessionWith(session: Session, roomLoadSettings: RoomLoadSettings)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_restore_session_with(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeSession_lower(session),FfiConverterTypeRoomLoadSettings_lower(roomLoadSettings)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Checks if a room alias exists in the current homeserver.
     */
open func roomAliasExists(roomAlias: String)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_room_alias_exists(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomAlias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func roomDirectorySearch() -> RoomDirectorySearch  {
    return try!  FfiConverterTypeRoomDirectorySearch_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_room_directory_search(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func rooms() -> [Room]  {
    return try!  FfiConverterSequenceTypeRoom.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_rooms(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func searchUsers(searchTerm: String, limit: UInt64)async throws  -> SearchUsersResults  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_search_users(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(searchTerm),FfiConverterUInt64.lower(limit)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeSearchUsersResults_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * The URL of the server.
     *
     * Not to be confused with the `Self::homeserver`. `server` is usually
     * the server part in a user ID, e.g. with `@mnt_io:matrix.org`, here
     * `matrix.org` is the server, whilst `matrix-client.matrix.org` is the
     * homeserver (at the time of writing â€” 2024-08-28).
     *
     * This value is optional depending on how the `Client` has been built.
     * If it's been built from a homeserver URL directly, we don't know the
     * server. However, if the `Client` has been built from a server URL or
     * name, then the homeserver has been discovered, and we know both.
     */
open func server() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_server(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get server vendor information from the federation API.
     *
     * This method retrieves information about the server's name and version
     * by calling the `/_matrix/federation/v1/version` endpoint.
     */
open func serverVendorInfo()async throws  -> ServerVendorInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_server_vendor_info(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeServerVendorInfo_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func session()throws  -> Session  {
    return try  FfiConverterTypeSession_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_session(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Set the given account data content for the given event type.
     *
     * It should be supplied as a JSON string.
     */
open func setAccountData(eventType: String, content: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_account_data(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventType),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Sets the [ClientDelegate] which will inform about authentication errors.
     * Returns an error if the delegate was already set.
     */
open func setDelegate(delegate: ClientDelegate?)throws  -> TaskHandle?  {
    return try  FfiConverterOptionTypeTaskHandle.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_set_delegate(
            self.uniffiCloneHandle(),
        FfiConverterOptionCallbackInterfaceClientDelegate.lower(delegate),$0
    )
})
}
    
open func setDisplayName(name: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_display_name(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Set the invite request avatars display policy
     */
open func setInviteAvatarsDisplayPolicy(policy: InviteAvatars)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_invite_avatars_display_policy(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeInviteAvatars_lower(policy)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Set the media previews timeline display policy
     */
open func setMediaPreviewDisplayPolicy(policy: MediaPreviews)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_media_preview_display_policy(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeMediaPreviews_lower(policy)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Set the media retention policy.
     */
open func setMediaRetentionPolicy(policy: MediaRetentionPolicy)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_media_retention_policy(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeMediaRetentionPolicy_lower(policy)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Registers a pusher with given parameters
     */
open func setPusher(identifiers: PusherIdentifiers, kind: PusherKind, appDisplayName: String, deviceDisplayName: String, profileTag: String?, lang: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_pusher(
                    self.uniffiCloneHandle(),
                    FfiConverterTypePusherIdentifiers_lower(identifiers),FfiConverterTypePusherKind_lower(kind),FfiConverterString.lower(appDisplayName),FfiConverterString.lower(deviceDisplayName),FfiConverterOptionString.lower(profileTag),FfiConverterString.lower(lang)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Sets the [UnableToDecryptDelegate] which will inform about UTDs.
     * Returns an error if the delegate was already set.
     */
open func setUtdDelegate(utdDelegate: UnableToDecryptDelegate)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_set_utd_delegate(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceUnableToDecryptDelegate_lower(utdDelegate)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * The sliding sync version.
     */
open func slidingSyncVersion() -> SlidingSyncVersion  {
    return try!  FfiConverterTypeSlidingSyncVersion_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_sliding_sync_version(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func spaceService()async  -> SpaceService  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_space_service(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeSpaceService_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Returns a handler to start the SSO login process.
     */
open func startSsoLogin(redirectUrl: String, idpId: String?)async throws  -> SsoHandler  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_start_sso_login(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(redirectUrl),FfiConverterOptionString.lower(idpId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeSsoHandler_lift,
            errorHandler: FfiConverterTypeSsoError_lift
        )
}
    
open func subscribeToIgnoredUsers(listener: IgnoredUsersListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_ignored_users(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceIgnoredUsersListener_lower(listener),$0
    )
})
}
    
    /**
     * Subscribe to changes in the media preview configuration.
     */
open func subscribeToMediaPreviewConfig(listener: MediaPreviewConfigListener)async throws  -> TaskHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_media_preview_config(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceMediaPreviewConfigListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Subscribe to [`RoomInfo`] updates given a provided [`RoomId`].
     *
     * This works even for rooms we haven't received yet, so we can subscribe
     * to this and wait until we receive updates from them when sync responses
     * are processed.
     *
     * Note this method should be used sparingly since using callback
     * interfaces is expensive, as well as keeping them alive for a long
     * time. Usages of this method should be short-lived and dropped as
     * soon as possible.
     */
open func subscribeToRoomInfo(roomId: String, listener: RoomInfoListener)async throws  -> TaskHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_room_info(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId),FfiConverterCallbackInterfaceRoomInfoListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Subscribe to the global enablement status of the send queue, at the
     * client-wide level.
     *
     * The given listener will be immediately called with the initial value of
     * the enablement status.
     */
open func subscribeToSendQueueStatus(listener: SendQueueRoomErrorListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_status(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceSendQueueRoomErrorListener_lower(listener),$0
    )
})
}
    
    /**
     * Subscribe to the global send queue update reporter, at the
     * client-wide level.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
open func subscribeToSendQueueUpdates(listener: SendQueueRoomUpdateListener)async throws  -> TaskHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_subscribe_to_send_queue_updates(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceSendQueueRoomUpdateListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func syncService() -> SyncServiceBuilder  {
    return try!  FfiConverterTypeSyncServiceBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_client_sync_service(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func trackRecentlyVisitedRoom(room: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_track_recently_visited_room(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(room)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func unignoreUser(userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_unignore_user(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func uploadAvatar(mimeType: String, data: Data)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_upload_avatar(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(mimeType),FfiConverterData.lower(data)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func uploadMedia(mimeType: String, data: Data, progressWatcher: ProgressWatcher?)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_upload_media(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(mimeType),FfiConverterData.lower(data),FfiConverterOptionCallbackInterfaceProgressWatcher.lower(progressWatcher)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Requests the URL needed for opening a web view using OIDC. Once the web
     * view has succeeded, call `login_with_oidc_callback` with the callback it
     * returns. If a failure occurs and a callback isn't available, make sure
     * to call `abort_oidc_auth` to inform the client of this.
     *
     * # Arguments
     *
     * * `oidc_configuration` - The configuration used to load the credentials
     * of the client if it is already registered with the authorization
     * server, or register the client and store its credentials if it isn't.
     *
     * * `prompt` - The desired user experience in the web UI. No value means
     * that the user wishes to login into an existing account, and a value of
     * `Create` means that the user wishes to register a new account.
     *
     * * `login_hint` - A generic login hint that an identity provider can use
     * to pre-fill the login form. The format of this hint is not restricted
     * by the spec as external providers all have their own way to handle the hint.
     * However, it should be noted that when providing a user ID as a hint
     * for MAS (with no upstream provider), then the format to use is defined
     * by [MSC4198]: https://github.com/matrix-org/matrix-spec-proposals/pull/4198
     *
     * * `device_id` - The unique ID that will be associated with the session.
     * If not set, a random one will be generated. It can be an existing
     * device ID from a previous login call. Note that this should be done
     * only if the client also holds the corresponding encryption keys.
     *
     * * `additional_scopes` - Additional scopes to request from the
     * authorization server, e.g. "urn:matrix:client:com.example.msc9999.foo".
     * The scopes for API access and the device ID according to the
     * [specification](https://spec.matrix.org/v1.15/client-server-api/#allocated-scope-tokens)
     * are always requested.
     */
open func urlForOidc(oidcConfiguration: OidcConfiguration, prompt: OidcPrompt?, loginHint: String?, deviceId: String?, additionalScopes: [String]?)async throws  -> OAuthAuthorizationData  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_url_for_oidc(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeOidcConfiguration_lower(oidcConfiguration),FfiConverterOptionTypeOidcPrompt.lower(prompt),FfiConverterOptionString.lower(loginHint),FfiConverterOptionString.lower(deviceId),FfiConverterOptionSequenceString.lower(additionalScopes)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeOAuthAuthorizationData_lift,
            errorHandler: FfiConverterTypeOidcError_lift
        )
}
    
open func userId()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_user_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * The server name part of the current user ID
     */
open func userIdServerName()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_client_user_id_server_name(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Adds a recently used emoji to the list and uploads the updated
     * `io.element.recent_emoji` content to the global account data.
     */
open func addRecentEmoji(emoji: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_add_recent_emoji(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(emoji)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Gets the list of recently used emojis from the
     * `io.element.recent_emoji` global account data.
     */
open func getRecentEmojis()async throws  -> [RecentEmoji]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_client_get_recent_emojis(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeRecentEmoji.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClient: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Client

    public static func lift(_ handle: UInt64) throws -> Client {
        return Client(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Client) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Client {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Client, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lift(_ handle: UInt64) throws -> Client {
    return try FfiConverterTypeClient.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClient_lower(_ value: Client) -> UInt64 {
    return FfiConverterTypeClient.lower(value)
}






public protocol ClientBuilderProtocol: AnyObject, Sendable {
    
    func addRootCertificates(certificates: [Data])  -> ClientBuilder
    
    /**
     * Automatically create a backup version if no backup exists.
     */
    func autoEnableBackups(autoEnableBackups: Bool)  -> ClientBuilder
    
    func autoEnableCrossSigning(autoEnableCrossSigning: Bool)  -> ClientBuilder
    
    /**
     * Select a strategy to download room keys from the backup. By default
     * we download after a decryption failure.
     *
     * Take a look at the [`BackupDownloadStrategy`] enum for more options.
     */
    func backupDownloadStrategy(backupDownloadStrategy: BackupDownloadStrategy)  -> ClientBuilder
    
    func build() async throws  -> Client
    
    func crossProcessStoreLocksHolderName(holderName: String)  -> ClientBuilder
    
    /**
     * Set the trust requirement to be used when decrypting events.
     */
    func decryptionSettings(decryptionSettings: DecryptionSettings)  -> ClientBuilder
    
    func disableAutomaticTokenRefresh()  -> ClientBuilder
    
    /**
     * Don't trust any system root certificates, only trust the certificates
     * provided through
     * [`add_root_certificates`][ClientBuilder::add_root_certificates].
     */
    func disableBuiltInRootCertificates()  -> ClientBuilder
    
    func disableSslVerification()  -> ClientBuilder
    
    func enableOidcRefreshLock()  -> ClientBuilder
    
    /**
     * Set whether to enable the experimental support for sending and receiving
     * encrypted room history on invite, per [MSC4268].
     *
     * [MSC4268]: https://github.com/matrix-org/matrix-spec-proposals/pull/4268
     */
    func enableShareHistoryOnInvite(enableShareHistoryOnInvite: Bool)  -> ClientBuilder
    
    func homeserverUrl(url: String)  -> ClientBuilder
    
    /**
     * Use in-memory session storage.
     */
    func inMemoryStore()  -> ClientBuilder
    
    func proxy(url: String)  -> ClientBuilder
    
    /**
     * Add a default request config to this client.
     */
    func requestConfig(config: RequestConfig)  -> ClientBuilder
    
    /**
     * Set the strategy to be used for picking recipient devices when sending
     * an encrypted message.
     */
    func roomKeyRecipientStrategy(strategy: CollectStrategy)  -> ClientBuilder
    
    func serverName(serverName: String)  -> ClientBuilder
    
    func serverNameOrHomeserverUrl(serverNameOrUrl: String)  -> ClientBuilder
    
    /**
     * Sets the paths that the client will use to store its data and caches
     * with SQLite.
     *
     * Both paths **must** be unique per session as the SDK
     * stores aren't capable of handling multiple users, however it is
     * valid to use the same path for both stores on a single session.
     */
    func sessionPaths(dataPath: String, cachePath: String)  -> ClientBuilder
    
    func setSessionDelegate(sessionDelegate: ClientSessionDelegate)  -> ClientBuilder
    
    func slidingSyncVersionBuilder(versionBuilder: SlidingSyncVersionBuilder)  -> ClientBuilder
    
    /**
     * Use SQLite as the session storage.
     */
    func sqliteStore(config: SqliteStoreBuilder)  -> ClientBuilder
    
    /**
     * Tell the client that the system is memory constrained, like in a push
     * notification process for example.
     *
     * So far, at the time of writing (2025-04-07), it changes the defaults of
     * `matrix_sdk::SqliteStoreConfig` (if the `sqlite` feature is enabled).
     * Please check
     * `matrix_sdk::SqliteStoreConfig::with_low_memory_config`.
     */
    func systemIsMemoryConstrained()  -> ClientBuilder
    
    /**
     * Whether the client should support threads client-side or not, and enable
     * experimental support for MSC4306 (threads subscriptions) or not.
     */
    func threadsEnabled(enabled: Bool, threadSubscriptions: Bool)  -> ClientBuilder
    
    func userAgent(userAgent: String)  -> ClientBuilder
    
    func username(username: String)  -> ClientBuilder
    
}
open class ClientBuilder: ClientBuilderProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_clientbuilder(self.handle, $0) }
    }
public convenience init() {
    let handle =
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_clientbuilder_new($0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_clientbuilder(handle, $0) }
    }

    

    
open func addRootCertificates(certificates: [Data]) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_add_root_certificates(
            self.uniffiCloneHandle(),
        FfiConverterSequenceData.lower(certificates),$0
    )
})
}
    
    /**
     * Automatically create a backup version if no backup exists.
     */
open func autoEnableBackups(autoEnableBackups: Bool) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_backups(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(autoEnableBackups),$0
    )
})
}
    
open func autoEnableCrossSigning(autoEnableCrossSigning: Bool) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_auto_enable_cross_signing(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(autoEnableCrossSigning),$0
    )
})
}
    
    /**
     * Select a strategy to download room keys from the backup. By default
     * we download after a decryption failure.
     *
     * Take a look at the [`BackupDownloadStrategy`] enum for more options.
     */
open func backupDownloadStrategy(backupDownloadStrategy: BackupDownloadStrategy) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_backup_download_strategy(
            self.uniffiCloneHandle(),
        FfiConverterTypeBackupDownloadStrategy_lower(backupDownloadStrategy),$0
    )
})
}
    
open func build()async throws  -> Client  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_clientbuilder_build(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeClient_lift,
            errorHandler: FfiConverterTypeClientBuildError_lift
        )
}
    
open func crossProcessStoreLocksHolderName(holderName: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_cross_process_store_locks_holder_name(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(holderName),$0
    )
})
}
    
    /**
     * Set the trust requirement to be used when decrypting events.
     */
open func decryptionSettings(decryptionSettings: DecryptionSettings) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_decryption_settings(
            self.uniffiCloneHandle(),
        FfiConverterTypeDecryptionSettings_lower(decryptionSettings),$0
    )
})
}
    
open func disableAutomaticTokenRefresh() -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_automatic_token_refresh(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Don't trust any system root certificates, only trust the certificates
     * provided through
     * [`add_root_certificates`][ClientBuilder::add_root_certificates].
     */
open func disableBuiltInRootCertificates() -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_built_in_root_certificates(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func disableSslVerification() -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_disable_ssl_verification(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func enableOidcRefreshLock() -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_oidc_refresh_lock(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Set whether to enable the experimental support for sending and receiving
     * encrypted room history on invite, per [MSC4268].
     *
     * [MSC4268]: https://github.com/matrix-org/matrix-spec-proposals/pull/4268
     */
open func enableShareHistoryOnInvite(enableShareHistoryOnInvite: Bool) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_enable_share_history_on_invite(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(enableShareHistoryOnInvite),$0
    )
})
}
    
open func homeserverUrl(url: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_homeserver_url(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(url),$0
    )
})
}
    
    /**
     * Use in-memory session storage.
     */
open func inMemoryStore() -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_in_memory_store(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func proxy(url: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_proxy(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(url),$0
    )
})
}
    
    /**
     * Add a default request config to this client.
     */
open func requestConfig(config: RequestConfig) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_request_config(
            self.uniffiCloneHandle(),
        FfiConverterTypeRequestConfig_lower(config),$0
    )
})
}
    
    /**
     * Set the strategy to be used for picking recipient devices when sending
     * an encrypted message.
     */
open func roomKeyRecipientStrategy(strategy: CollectStrategy) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_room_key_recipient_strategy(
            self.uniffiCloneHandle(),
        FfiConverterTypeCollectStrategy_lower(strategy),$0
    )
})
}
    
open func serverName(serverName: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(serverName),$0
    )
})
}
    
open func serverNameOrHomeserverUrl(serverNameOrUrl: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_server_name_or_homeserver_url(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(serverNameOrUrl),$0
    )
})
}
    
    /**
     * Sets the paths that the client will use to store its data and caches
     * with SQLite.
     *
     * Both paths **must** be unique per session as the SDK
     * stores aren't capable of handling multiple users, however it is
     * valid to use the same path for both stores on a single session.
     */
open func sessionPaths(dataPath: String, cachePath: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_session_paths(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(dataPath),
        FfiConverterString.lower(cachePath),$0
    )
})
}
    
open func setSessionDelegate(sessionDelegate: ClientSessionDelegate) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_set_session_delegate(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceClientSessionDelegate_lower(sessionDelegate),$0
    )
})
}
    
open func slidingSyncVersionBuilder(versionBuilder: SlidingSyncVersionBuilder) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sliding_sync_version_builder(
            self.uniffiCloneHandle(),
        FfiConverterTypeSlidingSyncVersionBuilder_lower(versionBuilder),$0
    )
})
}
    
    /**
     * Use SQLite as the session storage.
     */
open func sqliteStore(config: SqliteStoreBuilder) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_sqlite_store(
            self.uniffiCloneHandle(),
        FfiConverterTypeSqliteStoreBuilder_lower(config),$0
    )
})
}
    
    /**
     * Tell the client that the system is memory constrained, like in a push
     * notification process for example.
     *
     * So far, at the time of writing (2025-04-07), it changes the defaults of
     * `matrix_sdk::SqliteStoreConfig` (if the `sqlite` feature is enabled).
     * Please check
     * `matrix_sdk::SqliteStoreConfig::with_low_memory_config`.
     */
open func systemIsMemoryConstrained() -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_system_is_memory_constrained(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Whether the client should support threads client-side or not, and enable
     * experimental support for MSC4306 (threads subscriptions) or not.
     */
open func threadsEnabled(enabled: Bool, threadSubscriptions: Bool) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_threads_enabled(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(enabled),
        FfiConverterBool.lower(threadSubscriptions),$0
    )
})
}
    
open func userAgent(userAgent: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_user_agent(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userAgent),$0
    )
})
}
    
open func username(username: String) -> ClientBuilder  {
    return try!  FfiConverterTypeClientBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_clientbuilder_username(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(username),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientBuilder: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = ClientBuilder

    public static func lift(_ handle: UInt64) throws -> ClientBuilder {
        return ClientBuilder(unsafeFromHandle: handle)
    }

    public static func lower(_ value: ClientBuilder) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuilder {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: ClientBuilder, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientBuilder_lift(_ handle: UInt64) throws -> ClientBuilder {
    return try FfiConverterTypeClientBuilder.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientBuilder_lower(_ value: ClientBuilder) -> UInt64 {
    return FfiConverterTypeClientBuilder.lower(value)
}






public protocol EncryptionProtocol: AnyObject, Sendable {
    
    /**
     * Does a backup exist on the server?
     *
     * Because the homeserver doesn't notify us about changes to the backup
     * version, the [`BackupState`] and its listener are a bit crippled.
     * The `BackupState::Unknown` state might mean there is no backup at all or
     * a backup exists but we don't have access to it.
     *
     * Therefore it is necessary to poll the server for an answer every time
     * you want to differentiate between those two states.
     */
    func backupExistsOnServer() async throws  -> Bool
    
    func backupState()  -> BackupState
    
    func backupStateListener(listener: BackupStateListener)  -> TaskHandle
    
    /**
     * Get the public curve25519 key of our own device in base64. This is
     * usually what is called the identity key of the device.
     */
    func curve25519Key() async  -> String?
    
    func disableRecovery() async throws 
    
    /**
     * Get the public ed25519 key of our own device. This is usually what is
     * called the fingerprint of the device.
     */
    func ed25519Key() async  -> String?
    
    func enableBackups() async throws 
    
    func enableRecovery(waitForBackupsToUpload: Bool, passphrase: String?, progressListener: EnableRecoveryProgressListener) async throws  -> String
    
    /**
     * Does the user have other devices that the current device can verify
     * against?
     *
     * The device must be signed by the user's cross-signing key, must have an
     * identity, and must not be a dehydrated device.
     */
    func hasDevicesToVerifyAgainst() async throws  -> Bool
    
    func isLastDevice() async throws  -> Bool
    
    func recover(recoveryKey: String) async throws 
    
    func recoverAndReset(oldRecoveryKey: String) async throws  -> String
    
    func recoveryState()  -> RecoveryState
    
    func recoveryStateListener(listener: RecoveryStateListener)  -> TaskHandle
    
    /**
     * Completely reset the current user's crypto identity: reset the cross
     * signing keys, delete the existing backup and recovery key.
     */
    func resetIdentity() async throws  -> IdentityResetHandle?
    
    func resetRecoveryKey() async throws  -> String
    
    /**
     * Get the E2EE identity of a user.
     *
     * This method always tries to fetch the identity from the store, which we
     * only have if the user is tracked, meaning that we are both members
     * of the same encrypted room. If no user is found locally, a request will
     * be made to the homeserver unless `fallback_to_server` is set to `false`.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user that the identity belongs to.
     * * `fallback_to_server` - Should we request the user identity from the
     * homeserver if one isn't found locally.
     *
     * Returns a `UserIdentity` if one is found. Returns an error if there
     * was an issue with the crypto store or with the request to the
     * homeserver.
     *
     * This will always return `None` if the client hasn't been logged in.
     */
    func userIdentity(userId: String, fallbackToServer: Bool) async throws  -> UserIdentity?
    
    func verificationState()  -> VerificationState
    
    func verificationStateListener(listener: VerificationStateListener)  -> TaskHandle
    
    func waitForBackupUploadSteadyState(progressListener: BackupSteadyStateListener?) async throws 
    
    /**
     * Waits for end-to-end encryption initialization tasks to finish, if any
     * was running in the background.
     */
    func waitForE2eeInitializationTasks() async 
    
}
open class Encryption: EncryptionProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_encryption(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_encryption(handle, $0) }
    }

    

    
    /**
     * Does a backup exist on the server?
     *
     * Because the homeserver doesn't notify us about changes to the backup
     * version, the [`BackupState`] and its listener are a bit crippled.
     * The `BackupState::Unknown` state might mean there is no backup at all or
     * a backup exists but we don't have access to it.
     *
     * Therefore it is necessary to poll the server for an answer every time
     * you want to differentiate between those two states.
     */
open func backupExistsOnServer()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_backup_exists_on_server(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func backupState() -> BackupState  {
    return try!  FfiConverterTypeBackupState_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func backupStateListener(listener: BackupStateListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_backup_state_listener(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceBackupStateListener_lower(listener),$0
    )
})
}
    
    /**
     * Get the public curve25519 key of our own device in base64. This is
     * usually what is called the identity key of the device.
     */
open func curve25519Key()async  -> String?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_curve25519_key(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: nil
            
        )
}
    
open func disableRecovery()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_disable_recovery(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRecoveryError_lift
        )
}
    
    /**
     * Get the public ed25519 key of our own device. This is usually what is
     * called the fingerprint of the device.
     */
open func ed25519Key()async  -> String?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_ed25519_key(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: nil
            
        )
}
    
open func enableBackups()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_enable_backups(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRecoveryError_lift
        )
}
    
open func enableRecovery(waitForBackupsToUpload: Bool, passphrase: String?, progressListener: EnableRecoveryProgressListener)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_enable_recovery(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(waitForBackupsToUpload),FfiConverterOptionString.lower(passphrase),FfiConverterCallbackInterfaceEnableRecoveryProgressListener_lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeRecoveryError_lift
        )
}
    
    /**
     * Does the user have other devices that the current device can verify
     * against?
     *
     * The device must be signed by the user's cross-signing key, must have an
     * identity, and must not be a dehydrated device.
     */
open func hasDevicesToVerifyAgainst()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_has_devices_to_verify_against(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func isLastDevice()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_is_last_device(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeRecoveryError_lift
        )
}
    
open func recover(recoveryKey: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_recover(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(recoveryKey)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRecoveryError_lift
        )
}
    
open func recoverAndReset(oldRecoveryKey: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_recover_and_reset(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(oldRecoveryKey)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeRecoveryError_lift
        )
}
    
open func recoveryState() -> RecoveryState  {
    return try!  FfiConverterTypeRecoveryState_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func recoveryStateListener(listener: RecoveryStateListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_recovery_state_listener(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceRecoveryStateListener_lower(listener),$0
    )
})
}
    
    /**
     * Completely reset the current user's crypto identity: reset the cross
     * signing keys, delete the existing backup and recovery key.
     */
open func resetIdentity()async throws  -> IdentityResetHandle?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_reset_identity(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeIdentityResetHandle.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func resetRecoveryKey()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_reset_recovery_key(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeRecoveryError_lift
        )
}
    
    /**
     * Get the E2EE identity of a user.
     *
     * This method always tries to fetch the identity from the store, which we
     * only have if the user is tracked, meaning that we are both members
     * of the same encrypted room. If no user is found locally, a request will
     * be made to the homeserver unless `fallback_to_server` is set to `false`.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user that the identity belongs to.
     * * `fallback_to_server` - Should we request the user identity from the
     * homeserver if one isn't found locally.
     *
     * Returns a `UserIdentity` if one is found. Returns an error if there
     * was an issue with the crypto store or with the request to the
     * homeserver.
     *
     * This will always return `None` if the client hasn't been logged in.
     */
open func userIdentity(userId: String, fallbackToServer: Bool)async throws  -> UserIdentity?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_user_identity(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId),FfiConverterBool.lower(fallbackToServer)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeUserIdentity.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func verificationState() -> VerificationState  {
    return try!  FfiConverterTypeVerificationState_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func verificationStateListener(listener: VerificationStateListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_encryption_verification_state_listener(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceVerificationStateListener_lower(listener),$0
    )
})
}
    
open func waitForBackupUploadSteadyState(progressListener: BackupSteadyStateListener?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_backup_upload_steady_state(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionCallbackInterfaceBackupSteadyStateListener.lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSteadyStateError_lift
        )
}
    
    /**
     * Waits for end-to-end encryption initialization tasks to finish, if any
     * was running in the background.
     */
open func waitForE2eeInitializationTasks()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_encryption_wait_for_e2ee_initialization_tasks(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryption: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Encryption

    public static func lift(_ handle: UInt64) throws -> Encryption {
        return Encryption(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Encryption) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Encryption {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Encryption, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryption_lift(_ handle: UInt64) throws -> Encryption {
    return try FfiConverterTypeEncryption.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryption_lower(_ value: Encryption) -> UInt64 {
    return FfiConverterTypeEncryption.lower(value)
}






/**
 * Handler for granting login in with a QR code.
 */
public protocol GrantLoginWithQrCodeHandlerProtocol: AnyObject, Sendable {
    
    /**
     * This method allows you to grant login by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the new device can scan to log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`GrantLoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    func generate(progressListener: GrantGeneratedQrLoginProgressListener) async throws 
    
    /**
     * This method allows you to grant login with a scanned QR code.
     *
     * The new device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to grant the
     * login.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`GrantLoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the new device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    func scan(qrCodeData: QrCodeData, progressListener: GrantQrLoginProgressListener) async throws 
    
}
/**
 * Handler for granting login in with a QR code.
 */
open class GrantLoginWithQrCodeHandler: GrantLoginWithQrCodeHandlerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_grantloginwithqrcodehandler(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_grantloginwithqrcodehandler(handle, $0) }
    }

    

    
    /**
     * This method allows you to grant login by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the new device can scan to log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`GrantLoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
open func generate(progressListener: GrantGeneratedQrLoginProgressListener)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_grantloginwithqrcodehandler_generate(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener_lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeHumanQrGrantLoginError_lift
        )
}
    
    /**
     * This method allows you to grant login with a scanned QR code.
     *
     * The new device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to grant the
     * login.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`GrantLoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the new device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
open func scan(qrCodeData: QrCodeData, progressListener: GrantQrLoginProgressListener)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_grantloginwithqrcodehandler_scan(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeQrCodeData_lower(qrCodeData),FfiConverterCallbackInterfaceGrantQrLoginProgressListener_lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeHumanQrGrantLoginError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGrantLoginWithQrCodeHandler: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = GrantLoginWithQrCodeHandler

    public static func lift(_ handle: UInt64) throws -> GrantLoginWithQrCodeHandler {
        return GrantLoginWithQrCodeHandler(unsafeFromHandle: handle)
    }

    public static func lower(_ value: GrantLoginWithQrCodeHandler) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GrantLoginWithQrCodeHandler {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: GrantLoginWithQrCodeHandler, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrantLoginWithQrCodeHandler_lift(_ handle: UInt64) throws -> GrantLoginWithQrCodeHandler {
    return try FfiConverterTypeGrantLoginWithQrCodeHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrantLoginWithQrCodeHandler_lower(_ value: GrantLoginWithQrCodeHandler) -> UInt64 {
    return FfiConverterTypeGrantLoginWithQrCodeHandler.lower(value)
}






public protocol HomeserverLoginDetailsProtocol: AnyObject, Sendable {
    
    /**
     * The sliding sync version.
     */
    func slidingSyncVersion()  -> SlidingSyncVersion
    
    /**
     * The prompts advertised by the authentication issuer for use in the login
     * URL.
     */
    func supportedOidcPrompts()  -> [OidcPrompt]
    
    /**
     * Whether the current homeserver supports login using OIDC.
     */
    func supportsOidcLogin()  -> Bool
    
    /**
     * Whether the current homeserver supports the password login flow.
     */
    func supportsPasswordLogin()  -> Bool
    
    /**
     * Whether the current homeserver supports login using legacy SSO.
     */
    func supportsSsoLogin()  -> Bool
    
    /**
     * The URL of the currently configured homeserver.
     */
    func url()  -> String
    
}
open class HomeserverLoginDetails: HomeserverLoginDetailsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_homeserverlogindetails(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_homeserverlogindetails(handle, $0) }
    }

    

    
    /**
     * The sliding sync version.
     */
open func slidingSyncVersion() -> SlidingSyncVersion  {
    return try!  FfiConverterTypeSlidingSyncVersion_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_sliding_sync_version(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * The prompts advertised by the authentication issuer for use in the login
     * URL.
     */
open func supportedOidcPrompts() -> [OidcPrompt]  {
    return try!  FfiConverterSequenceTypeOidcPrompt.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supported_oidc_prompts(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Whether the current homeserver supports login using OIDC.
     */
open func supportsOidcLogin() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_oidc_login(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Whether the current homeserver supports the password login flow.
     */
open func supportsPasswordLogin() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_password_login(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Whether the current homeserver supports login using legacy SSO.
     */
open func supportsSsoLogin() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_supports_sso_login(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * The URL of the currently configured homeserver.
     */
open func url() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_homeserverlogindetails_url(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHomeserverLoginDetails: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = HomeserverLoginDetails

    public static func lift(_ handle: UInt64) throws -> HomeserverLoginDetails {
        return HomeserverLoginDetails(unsafeFromHandle: handle)
    }

    public static func lower(_ value: HomeserverLoginDetails) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HomeserverLoginDetails {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: HomeserverLoginDetails, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeserverLoginDetails_lift(_ handle: UInt64) throws -> HomeserverLoginDetails {
    return try FfiConverterTypeHomeserverLoginDetails.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHomeserverLoginDetails_lower(_ value: HomeserverLoginDetails) -> UInt64 {
    return FfiConverterTypeHomeserverLoginDetails.lower(value)
}






public protocol IdentityResetHandleProtocol: AnyObject, Sendable {
    
    /**
     * Get the underlying [`CrossSigningResetAuthType`] this identity reset
     * process is using.
     */
    func authType()  -> CrossSigningResetAuthType
    
    func cancel() async 
    
    /**
     * This method starts the identity reset process and
     * will go through the following steps:
     *
     * 1. Disable backing up room keys and delete the active backup
     * 2. Disable recovery and delete secret storage
     * 3. Go through the cross-signing key reset flow
     * 4. Finally, re-enable key backups only if they were enabled before
     */
    func reset(auth: AuthData?) async throws 
    
}
open class IdentityResetHandle: IdentityResetHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_identityresethandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_identityresethandle(handle, $0) }
    }

    

    
    /**
     * Get the underlying [`CrossSigningResetAuthType`] this identity reset
     * process is using.
     */
open func authType() -> CrossSigningResetAuthType  {
    return try!  FfiConverterTypeCrossSigningResetAuthType_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_identityresethandle_auth_type(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func cancel()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_identityresethandle_cancel(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * This method starts the identity reset process and
     * will go through the following steps:
     *
     * 1. Disable backing up room keys and delete the active backup
     * 2. Disable recovery and delete secret storage
     * 3. Go through the cross-signing key reset flow
     * 4. Finally, re-enable key backups only if they were enabled before
     */
open func reset(auth: AuthData?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_identityresethandle_reset(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionTypeAuthData.lower(auth)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityResetHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = IdentityResetHandle

    public static func lift(_ handle: UInt64) throws -> IdentityResetHandle {
        return IdentityResetHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: IdentityResetHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityResetHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: IdentityResetHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityResetHandle_lift(_ handle: UInt64) throws -> IdentityResetHandle {
    return try FfiConverterTypeIdentityResetHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityResetHandle_lower(_ value: IdentityResetHandle) -> UInt64 {
    return FfiConverterTypeIdentityResetHandle.lower(value)
}






public protocol InReplyToDetailsProtocol: AnyObject, Sendable {
    
    func event()  -> EmbeddedEventDetails
    
    func eventId()  -> String
    
}
open class InReplyToDetails: InReplyToDetailsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_inreplytodetails(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_inreplytodetails(handle, $0) }
    }

    

    
open func event() -> EmbeddedEventDetails  {
    return try!  FfiConverterTypeEmbeddedEventDetails_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func eventId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_inreplytodetails_event_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInReplyToDetails: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = InReplyToDetails

    public static func lift(_ handle: UInt64) throws -> InReplyToDetails {
        return InReplyToDetails(unsafeFromHandle: handle)
    }

    public static func lower(_ value: InReplyToDetails) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InReplyToDetails {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: InReplyToDetails, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInReplyToDetails_lift(_ handle: UInt64) throws -> InReplyToDetails {
    return try FfiConverterTypeInReplyToDetails.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInReplyToDetails_lower(_ value: InReplyToDetails) -> UInt64 {
    return FfiConverterTypeInReplyToDetails.lower(value)
}






/**
 * A set of actions to perform for a knock request.
 */
public protocol KnockRequestActionsProtocol: AnyObject, Sendable {
    
    /**
     * Accepts the knock request by inviting the user to the room.
     */
    func accept() async throws 
    
    /**
     * Declines the knock request by kicking the user from the room with an
     * optional reason.
     */
    func decline(reason: String?) async throws 
    
    /**
     * Declines the knock request by banning the user from the room with an
     * optional reason.
     */
    func declineAndBan(reason: String?) async throws 
    
    /**
     * Marks the knock request as 'seen'.
     *
     * **IMPORTANT**: this won't update the current reference to this request,
     * a new one with the updated value should be emitted instead.
     */
    func markAsSeen() async throws 
    
}
/**
 * A set of actions to perform for a knock request.
 */
open class KnockRequestActions: KnockRequestActionsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_knockrequestactions(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_knockrequestactions(handle, $0) }
    }

    

    
    /**
     * Accepts the knock request by inviting the user to the room.
     */
open func accept()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_accept(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Declines the knock request by kicking the user from the room with an
     * optional reason.
     */
open func decline(reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Declines the knock request by banning the user from the room with an
     * optional reason.
     */
open func declineAndBan(reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_decline_and_ban(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Marks the knock request as 'seen'.
     *
     * **IMPORTANT**: this won't update the current reference to this request,
     * a new one with the updated value should be emitted instead.
     */
open func markAsSeen()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_knockrequestactions_mark_as_seen(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKnockRequestActions: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = KnockRequestActions

    public static func lift(_ handle: UInt64) throws -> KnockRequestActions {
        return KnockRequestActions(unsafeFromHandle: handle)
    }

    public static func lower(_ value: KnockRequestActions) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KnockRequestActions {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: KnockRequestActions, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKnockRequestActions_lift(_ handle: UInt64) throws -> KnockRequestActions {
    return try FfiConverterTypeKnockRequestActions.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKnockRequestActions_lower(_ value: KnockRequestActions) -> UInt64 {
    return FfiConverterTypeKnockRequestActions.lower(value)
}






/**
 * Wrapper to retrieve some timeline item info lazily.
 */
public protocol LazyTimelineItemProviderProtocol: AnyObject, Sendable {
    
    func containsOnlyEmojis()  -> Bool
    
    /**
     * Returns some debug information for this event timeline item.
     */
    func debugInfo()  -> EventTimelineItemDebugInfo
    
    /**
     * For local echoes, return the associated send handle; returns `None` for
     * remote echoes.
     */
    func getSendHandle()  -> SendHandle?
    
    /**
     * Returns the shields for this event timeline item.
     */
    func getShields(strict: Bool)  -> ShieldState?
    
}
/**
 * Wrapper to retrieve some timeline item info lazily.
 */
open class LazyTimelineItemProvider: LazyTimelineItemProviderProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_lazytimelineitemprovider(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_lazytimelineitemprovider(handle, $0) }
    }

    

    
open func containsOnlyEmojis() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_contains_only_emojis(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns some debug information for this event timeline item.
     */
open func debugInfo() -> EventTimelineItemDebugInfo  {
    return try!  FfiConverterTypeEventTimelineItemDebugInfo_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_debug_info(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * For local echoes, return the associated send handle; returns `None` for
     * remote echoes.
     */
open func getSendHandle() -> SendHandle?  {
    return try!  FfiConverterOptionTypeSendHandle.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_send_handle(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns the shields for this event timeline item.
     */
open func getShields(strict: Bool) -> ShieldState?  {
    return try!  FfiConverterOptionTypeShieldState.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_lazytimelineitemprovider_get_shields(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(strict),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLazyTimelineItemProvider: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = LazyTimelineItemProvider

    public static func lift(_ handle: UInt64) throws -> LazyTimelineItemProvider {
        return LazyTimelineItemProvider(unsafeFromHandle: handle)
    }

    public static func lower(_ value: LazyTimelineItemProvider) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LazyTimelineItemProvider {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: LazyTimelineItemProvider, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLazyTimelineItemProvider_lift(_ handle: UInt64) throws -> LazyTimelineItemProvider {
    return try FfiConverterTypeLazyTimelineItemProvider.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLazyTimelineItemProvider_lower(_ value: LazyTimelineItemProvider) -> UInt64 {
    return FfiConverterTypeLazyTimelineItemProvider.lower(value)
}






/**
 * The `LeaveSpaceHandle` processes rooms to be left in the order they were
 * provided by the [`SpaceService`] and annotates them with extra data to
 * inform the leave process e.g. if the current user is the last room admin.
 *
 * Once the upstream client decides what rooms should actually be left, the
 * handle provides a method to execute that too.
 */
public protocol LeaveSpaceHandleProtocol: AnyObject, Sendable {
    
    /**
     * Bulk leave the given rooms. Stops when encountering an error.
     */
    func leave(roomIds: [String]) async throws 
    
    /**
     * A list of rooms to be left which next to normal [`SpaceRoom`] data also
     * include leave specific information.
     */
    func rooms()  -> [LeaveSpaceRoom]
    
}
/**
 * The `LeaveSpaceHandle` processes rooms to be left in the order they were
 * provided by the [`SpaceService`] and annotates them with extra data to
 * inform the leave process e.g. if the current user is the last room admin.
 *
 * Once the upstream client decides what rooms should actually be left, the
 * handle provides a method to execute that too.
 */
open class LeaveSpaceHandle: LeaveSpaceHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_leavespacehandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_leavespacehandle(handle, $0) }
    }

    

    
    /**
     * Bulk leave the given rooms. Stops when encountering an error.
     */
open func leave(roomIds: [String])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_leave(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceString.lower(roomIds)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * A list of rooms to be left which next to normal [`SpaceRoom`] data also
     * include leave specific information.
     */
open func rooms() -> [LeaveSpaceRoom]  {
    return try!  FfiConverterSequenceTypeLeaveSpaceRoom.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_leavespacehandle_rooms(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLeaveSpaceHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = LeaveSpaceHandle

    public static func lift(_ handle: UInt64) throws -> LeaveSpaceHandle {
        return LeaveSpaceHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: LeaveSpaceHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LeaveSpaceHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: LeaveSpaceHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeaveSpaceHandle_lift(_ handle: UInt64) throws -> LeaveSpaceHandle {
    return try FfiConverterTypeLeaveSpaceHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeaveSpaceHandle_lower(_ value: LeaveSpaceHandle) -> UInt64 {
    return FfiConverterTypeLeaveSpaceHandle.lower(value)
}






/**
 * Handler for logging in with a QR code.
 */
public protocol LoginWithQrCodeHandlerProtocol: AnyObject, Sendable {
    
    /**
     * This method allows you to log in by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the existing device can scan and grant the
     * log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`LoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    func generate(progressListener: GeneratedQrLoginProgressListener) async throws 
    
    /**
     * This method allows you to log in with a scanned QR code.
     *
     * The existing device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to log in.
     *
     * For the login to succeed, the [`Client`] associated with the
     * [`LoginWithQrCodeHandler`] must have been built with
     * [`QrCodeData::server_name`] as the server name.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`LoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the existing device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
    func scan(qrCodeData: QrCodeData, progressListener: QrLoginProgressListener) async throws 
    
}
/**
 * Handler for logging in with a QR code.
 */
open class LoginWithQrCodeHandler: LoginWithQrCodeHandlerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_loginwithqrcodehandler(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_loginwithqrcodehandler(handle, $0) }
    }

    

    
    /**
     * This method allows you to log in by generating a QR code.
     *
     * This device needs to call this method and handle its progress updates to
     * generate a QR code which the existing device can scan and grant the
     * log in.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where the existing device generates the QR code
     * for this device to scan, use [`LoginWithQrCodeHandler::scan`].
     *
     * # Arguments
     *
     * * `progress_listener` - A progress listener that must also be used to
     * obtain the [`QrCodeData`] and collect the [`CheckCode`] from the user.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
open func generate(progressListener: GeneratedQrLoginProgressListener)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_generate(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener_lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeHumanQrLoginError_lift
        )
}
    
    /**
     * This method allows you to log in with a scanned QR code.
     *
     * The existing device needs to display the QR code which this device can
     * scan, call this method and handle its progress updates to log in.
     *
     * For the login to succeed, the [`Client`] associated with the
     * [`LoginWithQrCodeHandler`] must have been built with
     * [`QrCodeData::server_name`] as the server name.
     *
     * This method uses the login mechanism described in [MSC4108]. As such,
     * it requires OAuth 2.0 support.
     *
     * For the reverse flow where this device generates the QR code for the
     * existing device to scan, use [`LoginWithQrCodeHandler::generate`].
     *
     * # Arguments
     *
     * * `qr_code_data` - The [`QrCodeData`] scanned from the QR code.
     * * `progress_listener` - A progress listener that must also be used to
     * transfer the [`CheckCode`] to the existing device.
     *
     * [MSC4108]: https://github.com/matrix-org/matrix-spec-proposals/pull/4108
     */
open func scan(qrCodeData: QrCodeData, progressListener: QrLoginProgressListener)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_loginwithqrcodehandler_scan(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeQrCodeData_lower(qrCodeData),FfiConverterCallbackInterfaceQrLoginProgressListener_lower(progressListener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeHumanQrLoginError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLoginWithQrCodeHandler: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = LoginWithQrCodeHandler

    public static func lift(_ handle: UInt64) throws -> LoginWithQrCodeHandler {
        return LoginWithQrCodeHandler(unsafeFromHandle: handle)
    }

    public static func lower(_ value: LoginWithQrCodeHandler) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginWithQrCodeHandler {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: LoginWithQrCodeHandler, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoginWithQrCodeHandler_lift(_ handle: UInt64) throws -> LoginWithQrCodeHandler {
    return try FfiConverterTypeLoginWithQrCodeHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLoginWithQrCodeHandler_lower(_ value: LoginWithQrCodeHandler) -> UInt64 {
    return FfiConverterTypeLoginWithQrCodeHandler.lower(value)
}






/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
public protocol MediaFileHandleProtocol: AnyObject, Sendable {
    
    /**
     * Get the media file's path.
     */
    func path() throws  -> String
    
    func persist(path: String) throws  -> Bool
    
}
/**
 * A file handle that takes ownership of a media file on disk. When the handle
 * is dropped, the file will be removed from the disk.
 */
open class MediaFileHandle: MediaFileHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_mediafilehandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediafilehandle(handle, $0) }
    }

    

    
    /**
     * Get the media file's path.
     */
open func path()throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_path(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func persist(path: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_mediafilehandle_persist(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(path),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMediaFileHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = MediaFileHandle

    public static func lift(_ handle: UInt64) throws -> MediaFileHandle {
        return MediaFileHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: MediaFileHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaFileHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: MediaFileHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaFileHandle_lift(_ handle: UInt64) throws -> MediaFileHandle {
    return try FfiConverterTypeMediaFileHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaFileHandle_lower(_ value: MediaFileHandle) -> UInt64 {
    return FfiConverterTypeMediaFileHandle.lower(value)
}






public protocol MediaSourceProtocol: AnyObject, Sendable {
    
    func toJson()  -> String
    
    func url()  -> String
    
}
open class MediaSource: MediaSourceProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_mediasource(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_mediasource(handle, $0) }
    }

    
public static func fromJson(json: String)throws  -> MediaSource  {
    return try  FfiConverterTypeMediaSource_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_json(
        FfiConverterString.lower(json),$0
    )
})
}
    
public static func fromUrl(url: String)throws  -> MediaSource  {
    return try  FfiConverterTypeMediaSource_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_constructor_mediasource_from_url(
        FfiConverterString.lower(url),$0
    )
})
}
    

    
open func toJson() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_mediasource_to_json(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func url() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_mediasource_url(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMediaSource: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = MediaSource

    public static func lift(_ handle: UInt64) throws -> MediaSource {
        return MediaSource(unsafeFromHandle: handle)
    }

    public static func lower(_ value: MediaSource) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaSource {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: MediaSource, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaSource_lift(_ handle: UInt64) throws -> MediaSource {
    return try FfiConverterTypeMediaSource.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaSource_lower(_ value: MediaSource) -> UInt64 {
    return FfiConverterTypeMediaSource.lower(value)
}






public protocol NotificationClientProtocol: AnyObject, Sendable {
    
    /**
     * Fetches the content of a notification.
     *
     * This will first try to get the notification using a short-lived sliding
     * sync, and if the sliding-sync can't find the event, then it'll use a
     * `/context` query to find the event with associated member information.
     *
     * An error result means that we couldn't resolve the notification; in that
     * case, a dummy notification may be displayed instead.
     */
    func getNotification(roomId: String, eventId: String) async throws  -> NotificationStatus
    
    /**
     * Get several notification items in a single batch.
     *
     * Returns an error if the flow failed when preparing to fetch the
     * notifications, and a [`HashMap`] containing either a
     * [`BatchNotificationResult`], that indicates if the notification was
     * successfully fetched (in which case, it's a [`NotificationStatus`]), or
     * an error message if it couldn't be fetched.
     */
    func getNotifications(requests: [NotificationItemsRequest]) async throws  -> [String: BatchNotificationResult]
    
    /**
     * Fetches a room by its ID using the in-memory state store backed client.
     *
     * Useful to retrieve room information after running the limited
     * notification client sliding sync loop.
     */
    func getRoom(roomId: String) throws  -> Room?
    
}
open class NotificationClient: NotificationClientProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_notificationclient(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_notificationclient(handle, $0) }
    }

    

    
    /**
     * Fetches the content of a notification.
     *
     * This will first try to get the notification using a short-lived sliding
     * sync, and if the sliding-sync can't find the event, then it'll use a
     * `/context` query to find the event with associated member information.
     *
     * An error result means that we couldn't resolve the notification; in that
     * case, a dummy notification may be displayed instead.
     */
open func getNotification(roomId: String, eventId: String)async throws  -> NotificationStatus  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notification(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId),FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeNotificationStatus_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get several notification items in a single batch.
     *
     * Returns an error if the flow failed when preparing to fetch the
     * notifications, and a [`HashMap`] containing either a
     * [`BatchNotificationResult`], that indicates if the notification was
     * successfully fetched (in which case, it's a [`NotificationStatus`]), or
     * an error message if it couldn't be fetched.
     */
open func getNotifications(requests: [NotificationItemsRequest])async throws  -> [String: BatchNotificationResult]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_notifications(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceTypeNotificationItemsRequest.lower(requests)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterDictionaryStringTypeBatchNotificationResult.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Fetches a room by its ID using the in-memory state store backed client.
     *
     * Useful to retrieve room information after running the limited
     * notification client sliding sync loop.
     */
open func getRoom(roomId: String)throws  -> Room?  {
    return try  FfiConverterOptionTypeRoom.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_notificationclient_get_room(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(roomId),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationClient: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = NotificationClient

    public static func lift(_ handle: UInt64) throws -> NotificationClient {
        return NotificationClient(unsafeFromHandle: handle)
    }

    public static func lower(_ value: NotificationClient) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationClient {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: NotificationClient, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationClient_lift(_ handle: UInt64) throws -> NotificationClient {
    return try FfiConverterTypeNotificationClient.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationClient_lower(_ value: NotificationClient) -> UInt64 {
    return FfiConverterTypeNotificationClient.lower(value)
}






public protocol NotificationSettingsProtocol: AnyObject, Sendable {
    
    /**
     * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    func canHomeserverPushEncryptedEventToDevice() async  -> Bool
    
    /**
     * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
    func canPushEncryptedEventToDevice() async  -> Bool
    
    /**
     * Get whether some enabled keyword rules exist.
     */
    func containsKeywordsRules() async  -> Bool
    
    /**
     * Get the default room notification mode
     *
     * The mode will depend on the associated `PushRule` based on whether the
     * room is encrypted or not, and on the number of members.
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chats involving two
     * people
     */
    func getDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool) async  -> RoomNotificationMode
    
    /**
     * Returns the raw push rules in JSON format.
     */
    func getRawPushRules() async throws  -> String?
    
    /**
     * Get the notification settings for a room.
     *
     * # Arguments
     *
     * * `room_id` - the room ID
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    func getRoomNotificationSettings(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws  -> RoomNotificationSettings
    
    /**
     * Get all room IDs for which a user-defined rule exists.
     */
    func getRoomsWithUserDefinedRules(enabled: Bool?) async  -> [String]
    
    /**
     * Get the user defined room notification mode
     */
    func getUserDefinedRoomNotificationMode(roomId: String) async throws  -> RoomNotificationMode?
    
    /**
     * Get whether the `.m.rule.call` push rule is enabled
     */
    func isCallEnabled() async throws  -> Bool
    
    /**
     * Get whether the `.m.rule.invite_for_me` push rule is enabled
     */
    func isInviteForMeEnabled() async throws  -> Bool
    
    /**
     * Get whether room mentions are enabled.
     */
    func isRoomMentionEnabled() async throws  -> Bool
    
    /**
     * Get whether user mentions are enabled.
     */
    func isUserMentionEnabled() async throws  -> Bool
    
    /**
     * Restore the default notification mode for a room
     */
    func restoreDefaultRoomNotificationMode(roomId: String) async throws 
    
    /**
     * Set whether the `.m.rule.call` push rule is enabled
     */
    func setCallEnabled(enabled: Bool) async throws 
    
    /**
     * Sets a custom push rule with the given actions and conditions.
     */
    func setCustomPushRule(ruleId: String, ruleKind: RuleKind, actions: [Action], conditions: [PushCondition]) async throws 
    
    /**
     * Set the default room notification mode
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the mode is for encrypted rooms
     * * `is_one_to_one` - whether the mode is for direct chats involving two
     * people
     * * `mode` - the new default mode
     */
    func setDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool, mode: RoomNotificationMode) async throws 
    
    func setDelegate(delegate: NotificationSettingsDelegate?) 
    
    /**
     * Set whether the `.m.rule.invite_for_me` push rule is enabled
     */
    func setInviteForMeEnabled(enabled: Bool) async throws 
    
    /**
     * Set whether room mentions are enabled.
     */
    func setRoomMentionEnabled(enabled: Bool) async throws 
    
    /**
     * Set the notification mode for a room.
     */
    func setRoomNotificationMode(roomId: String, mode: RoomNotificationMode) async throws 
    
    /**
     * Set whether user mentions are enabled.
     */
    func setUserMentionEnabled(enabled: Bool) async throws 
    
    /**
     * Unmute a room.
     *
     * # Arguments
     *
     * * `room_id` - the room to unmute
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
    func unmuteRoom(roomId: String, isEncrypted: Bool, isOneToOne: Bool) async throws 
    
}
open class NotificationSettings: NotificationSettingsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_notificationsettings(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_notificationsettings(handle, $0) }
    }

    

    
    /**
     * Check whether [MSC 4028 push rule][rule] is enabled on the homeserver.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
open func canHomeserverPushEncryptedEventToDevice()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_homeserver_push_encrypted_event_to_device(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Returns true if [MSC 4028 push rule][rule] is supported and enabled.
     *
     * [rule]: https://github.com/matrix-org/matrix-spec-proposals/blob/giomfo/push_encrypted_events/proposals/4028-push-all-encrypted-events-except-for-muted-rooms.md
     */
open func canPushEncryptedEventToDevice()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_can_push_encrypted_event_to_device(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get whether some enabled keyword rules exist.
     */
open func containsKeywordsRules()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_contains_keywords_rules(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get the default room notification mode
     *
     * The mode will depend on the associated `PushRule` based on whether the
     * room is encrypted or not, and on the number of members.
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chats involving two
     * people
     */
open func getDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool)async  -> RoomNotificationMode  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_default_room_notification_mode(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomNotificationMode_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Returns the raw push rules in JSON format.
     */
open func getRawPushRules()async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_raw_push_rules(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get the notification settings for a room.
     *
     * # Arguments
     *
     * * `room_id` - the room ID
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
open func getRoomNotificationSettings(roomId: String, isEncrypted: Bool, isOneToOne: Bool)async throws  -> RoomNotificationSettings  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_room_notification_settings(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId),FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomNotificationSettings_lift,
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Get all room IDs for which a user-defined rule exists.
     */
open func getRoomsWithUserDefinedRules(enabled: Bool?)async  -> [String]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_rooms_with_user_defined_rules(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Get the user defined room notification mode
     */
open func getUserDefinedRoomNotificationMode(roomId: String)async throws  -> RoomNotificationMode?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_get_user_defined_room_notification_mode(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomNotificationMode.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Get whether the `.m.rule.call` push rule is enabled
     */
open func isCallEnabled()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_call_enabled(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Get whether the `.m.rule.invite_for_me` push rule is enabled
     */
open func isInviteForMeEnabled()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_invite_for_me_enabled(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Get whether room mentions are enabled.
     */
open func isRoomMentionEnabled()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_room_mention_enabled(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Get whether user mentions are enabled.
     */
open func isUserMentionEnabled()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_is_user_mention_enabled(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Restore the default notification mode for a room
     */
open func restoreDefaultRoomNotificationMode(roomId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_restore_default_room_notification_mode(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Set whether the `.m.rule.call` push rule is enabled
     */
open func setCallEnabled(enabled: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_call_enabled(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Sets a custom push rule with the given actions and conditions.
     */
open func setCustomPushRule(ruleId: String, ruleKind: RuleKind, actions: [Action], conditions: [PushCondition])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_custom_push_rule(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(ruleId),FfiConverterTypeRuleKind_lower(ruleKind),FfiConverterSequenceTypeAction.lower(actions),FfiConverterSequenceTypePushCondition.lower(conditions)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Set the default room notification mode
     *
     * # Arguments
     *
     * * `is_encrypted` - whether the mode is for encrypted rooms
     * * `is_one_to_one` - whether the mode is for direct chats involving two
     * people
     * * `mode` - the new default mode
     */
open func setDefaultRoomNotificationMode(isEncrypted: Bool, isOneToOne: Bool, mode: RoomNotificationMode)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_default_room_notification_mode(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne),FfiConverterTypeRoomNotificationMode_lower(mode)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
open func setDelegate(delegate: NotificationSettingsDelegate?)  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_delegate(
            self.uniffiCloneHandle(),
        FfiConverterOptionCallbackInterfaceNotificationSettingsDelegate.lower(delegate),$0
    )
}
}
    
    /**
     * Set whether the `.m.rule.invite_for_me` push rule is enabled
     */
open func setInviteForMeEnabled(enabled: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_invite_for_me_enabled(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Set whether room mentions are enabled.
     */
open func setRoomMentionEnabled(enabled: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_mention_enabled(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Set the notification mode for a room.
     */
open func setRoomNotificationMode(roomId: String, mode: RoomNotificationMode)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_room_notification_mode(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId),FfiConverterTypeRoomNotificationMode_lower(mode)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Set whether user mentions are enabled.
     */
open func setUserMentionEnabled(enabled: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_set_user_mention_enabled(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(enabled)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    
    /**
     * Unmute a room.
     *
     * # Arguments
     *
     * * `room_id` - the room to unmute
     * * `is_encrypted` - whether the room is encrypted
     * * `is_one_to_one` - whether the room is a direct chat involving two
     * people
     */
open func unmuteRoom(roomId: String, isEncrypted: Bool, isOneToOne: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_notificationsettings_unmute_room(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId),FfiConverterBool.lower(isEncrypted),FfiConverterBool.lower(isOneToOne)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeNotificationSettingsError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationSettings: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = NotificationSettings

    public static func lift(_ handle: UInt64) throws -> NotificationSettings {
        return NotificationSettings(unsafeFromHandle: handle)
    }

    public static func lower(_ value: NotificationSettings) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSettings {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: NotificationSettings, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationSettings_lift(_ handle: UInt64) throws -> NotificationSettings {
    return try FfiConverterTypeNotificationSettings.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationSettings_lower(_ value: NotificationSettings) -> UInt64 {
    return FfiConverterTypeNotificationSettings.lower(value)
}






/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
public protocol QrCodeDataProtocol: AnyObject, Sendable {
    
    /**
     * The server name contained within the scanned QR code data.
     *
     * Note: This value is only present when scanning a QR code the belongs to
     * a logged in client. The mode where the new client shows the QR code
     * will return `None`.
     */
    func serverName()  -> String?
    
    /**
     * Serialize the [`QrCodeData`] into a byte vector for encoding as a QR
     * code.
     */
    func toBytes()  -> Data
    
}
/**
 * Data for the QR code login mechanism.
 *
 * The [`QrCodeData`] can be serialized and encoded as a QR code or it can be
 * decoded from a QR code.
 */
open class QrCodeData: QrCodeDataProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_qrcodedata(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_qrcodedata(handle, $0) }
    }

    
    /**
     * Attempt to decode a slice of bytes into a [`QrCodeData`] object.
     *
     * The slice of bytes would generally be returned by a QR code decoder.
     */
public static func fromBytes(bytes: Data)throws  -> QrCodeData  {
    return try  FfiConverterTypeQrCodeData_lift(try rustCallWithError(FfiConverterTypeQrCodeDecodeError_lift) {
    uniffi_matrix_sdk_ffi_fn_constructor_qrcodedata_from_bytes(
        FfiConverterData.lower(bytes),$0
    )
})
}
    

    
    /**
     * The server name contained within the scanned QR code data.
     *
     * Note: This value is only present when scanning a QR code the belongs to
     * a logged in client. The mode where the new client shows the QR code
     * will return `None`.
     */
open func serverName() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_qrcodedata_server_name(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Serialize the [`QrCodeData`] into a byte vector for encoding as a QR
     * code.
     */
open func toBytes() -> Data  {
    return try!  FfiConverterData.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_qrcodedata_to_bytes(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQrCodeData: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = QrCodeData

    public static func lift(_ handle: UInt64) throws -> QrCodeData {
        return QrCodeData(unsafeFromHandle: handle)
    }

    public static func lower(_ value: QrCodeData) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCodeData {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: QrCodeData, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrCodeData_lift(_ handle: UInt64) throws -> QrCodeData {
    return try FfiConverterTypeQrCodeData.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrCodeData_lower(_ value: QrCodeData) -> UInt64 {
    return FfiConverterTypeQrCodeData.lower(value)
}






public protocol RoomProtocol: AnyObject, Sendable {
    
    func activeMembersCount()  -> UInt64
    
    /**
     * Returns a Vec of userId's that participate in the room call.
     *
     * MatrixRTC memberships with application "m.call" and scope "m.room" are
     * considered. A user can occur twice if they join with two devices.
     * convert to a set depending if the different users are required or the
     * amount of sessions.
     *
     * The vector is ordered by oldest membership user to newest.
     */
    func activeRoomCallParticipants()  -> [String]
    
    func alternativeAliases()  -> [String]
    
    func applyPowerLevelChanges(changes: RoomPowerLevelChanges) async throws 
    
    func avatarUrl()  -> String?
    
    func banUser(userId: String, reason: String?) async throws 
    
    func canonicalAlias()  -> String?
    
    /**
     * Remove the `ComposerDraft` stored in the state store for this room.
     */
    func clearComposerDraft(threadRoot: String?) async throws 
    
    /**
     * Clear the event cache storage for the current room.
     *
     * This will remove all the information related to the event cache, in
     * memory and in the persisted storage, if enabled.
     */
    func clearEventCacheStorage() async throws 
    
    /**
     * Declines a call (and stop ringing).
     *
     * # Arguments
     *
     * * `rtc_notification_event_id` - the event id of the m.rtc.notification
     * event.
     */
    func declineCall(rtcNotificationEventId: String) async throws 
    
    /**
     * Forces the currently active room key, which is used to encrypt messages,
     * to be rotated.
     *
     * A new room key will be crated and shared with all the room members the
     * next time a message will be sent. You don't have to call this method,
     * room keys will be rotated automatically when necessary. This method is
     * still useful for debugging purposes.
     */
    func discardRoomKey() async throws 
    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
    func displayName()  -> String?
    
    /**
     * Edit an event given its event id.
     *
     * Useful outside the context of a timeline, or when a timeline doesn't
     * have the full content of an event.
     */
    func edit(eventId: String, newContent: RoomMessageEventContentWithoutRelation) async throws 
    
    /**
     * Enable End-to-end encryption in this room.
     */
    func enableEncryption() async throws 
    
    /**
     * Enable or disable the send queue for that particular room.
     */
    func enableSendQueue(enable: Bool) 
    
    func encryptionState()  -> EncryptionState
    
    /**
     * Return the current MSC4306 thread subscription for the given thread root
     * in this room.
     *
     * Returns `None` if the thread doesn't exist, or isn't subscribed to, or
     * the server can't handle MSC4306; otherwise, returns the thread
     * subscription status.
     */
    func fetchThreadSubscription(threadRootEventId: String) async throws  -> ThreadSubscription?
    
    /**
     * Forget this room.
     *
     * This communicates to the homeserver that it should forget the room.
     *
     * Only left or banned-from rooms can be forgotten.
     */
    func forget() async throws 
    
    func getPowerLevels() async throws  -> RoomPowerLevels
    
    /**
     * Returns the visibility for this room in the room directory.
     *
     * [Public](`RoomVisibility::Public`) rooms are listed in the room
     * directory and can be found using it.
     */
    func getRoomVisibility() async throws  -> RoomVisibility
    
    /**
     * Is there a non expired membership with application "m.call" and scope
     * "m.room" in this room.
     */
    func hasActiveRoomCall()  -> Bool
    
    /**
     * Returns the room heroes for this room.
     */
    func heroes()  -> [RoomHero]
    
    func id()  -> String
    
    /**
     * Set the local trust for the given devices to `LocalTrust::Ignored`
     * and resend messages that failed to send because said devices are
     * unverified (in response to
     * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
     * # Arguments
     *
     * * `devices` - The map of users identifiers to device identifiers
     * received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    func ignoreDeviceTrustAndResend(devices: [String: [String]], sendHandle: SendHandle) async throws 
    
    /**
     * Ignores a user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user to ignore.
     */
    func ignoreUser(userId: String) async throws 
    
    func inviteUserById(userId: String) async throws 
    
    func invitedMembersCount()  -> UInt64
    
    /**
     * Get the user who created the invite, if any.
     */
    func inviter() async throws  -> RoomMember?
    
    func isDirect() async  -> Bool
    
    /**
     * Checks whether the room is encrypted or not.
     *
     * **Note**: this info may not be reliable if you don't set up
     * `m.room.encryption` as required state.
     */
    func isEncrypted() async  -> Bool
    
    /**
     * Whether the room can be publicly joined or not, based on its join rule.
     *
     * Can return `None` if the join rule state event is missing.
     */
    func isPublic()  -> Bool?
    
    /**
     * Returns whether the send queue for that particular room is enabled or
     * not.
     */
    func isSendQueueEnabled()  -> Bool
    
    func isSpace()  -> Bool
    
    /**
     * Join this room.
     *
     * Only invited and left rooms can be joined via this method.
     */
    func join() async throws 
    
    func joinedMembersCount()  -> UInt64
    
    func kickUser(userId: String, reason: String?) async throws 
    
    func latestEncryptionState() async throws  -> EncryptionState
    
    func latestEvent() async  -> LatestEventValue
    
    /**
     * Leave this room.
     *
     * Only invited and joined rooms can be left.
     */
    func leave() async throws 
    
    /**
     * Retrieve the `ComposerDraft` stored in the state store for this room.
     */
    func loadComposerDraft(threadRoot: String?) async throws  -> ComposerDraft?
    
    /**
     * Either loads the event associated with the `event_id` from the event
     * cache or fetches it from the homeserver.
     */
    func loadOrFetchEvent(eventId: String) async throws  -> TimelineEvent
    
    /**
     * Mark a room as fully read, by attaching a read receipt to the provided
     * `event_id`.
     *
     * **Warning:** using this method is **NOT** recommended, as providing the
     * latest event id can cause incorrect read receipts. This method won't
     * check if sending the read receipt is necessary or valid. It should
     * *only* be used when some constraint prevents you from instantiating a
     * [`Timeline`]. For any other case use [`Timeline::mark_as_read`]
     * instead.
     */
    func markAsFullyReadUnchecked(eventId: String) async throws 
    
    /**
     * Mark a room as read, by attaching a read receipt on the latest event.
     *
     * Note: this does NOT unset the unread flag; it's the caller's
     * responsibility to do so, if need be.
     */
    func markAsRead(receiptType: ReceiptType) async throws 
    
    func matrixToEventPermalink(eventId: String) async throws  -> String
    
    func matrixToPermalink() async throws  -> String
    
    func member(userId: String) async throws  -> RoomMember
    
    func memberAvatarUrl(userId: String) async throws  -> String?
    
    func memberDisplayName(userId: String) async throws  -> String?
    
    /**
     * Get the membership details for the current user.
     *
     * Returns:
     * - If the user was present in the room, a
     * [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
     * user info and the member info of the sender of the `m.room.member`
     * event.
     * - If the current user is not present, an error.
     */
    func memberWithSenderInfo(userId: String) async throws  -> RoomMemberWithSenderInfo
    
    func members() async throws  -> RoomMembersIterator
    
    func membersNoSync() async throws  -> RoomMembersIterator
    
    /**
     * The room's current membership state.
     */
    func membership()  -> Membership
    
    func ownUserId()  -> String
    
    /**
     * If this room is the successor of a tombstoned room, return the
     * â€œreferenceâ€ to the predecessor room.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * To determine if a room is the successor of a tombstoned room, the
     * [`m.room.create`] must have been received, **with** a `predecessor`
     * field.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
     */
    func predecessorRoom()  -> PredecessorRoom?
    
    /**
     * Builds a `RoomPreview` from a room list item. This is intended for
     * invited, knocked or banned rooms.
     */
    func previewRoom(via: [String]) async throws  -> RoomPreview
    
    /**
     * Publish a new room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias didn't exist and it's now published.
     * - `false` if the room alias was already present so it couldn't be
     * published.
     */
    func publishRoomAliasInRoomDirectory(alias: String) async throws  -> Bool
    
    /**
     * The raw name as present in the room state event.
     */
    func rawName()  -> String?
    
    /**
     * Redacts an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to redact
     *
     * * `reason` - The reason for the event being redacted (optional). its
     * transaction ID (optional). If not given one is created.
     */
    func redact(eventId: String, reason: String?) async throws 
    
    /**
     * Removes the current room avatar
     */
    func removeAvatar() async throws 
    
    /**
     * Remove an existing room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias was present and it's now removed from the
     * room directory.
     * - `false` if the room alias didn't exist so it couldn't be removed.
     */
    func removeRoomAliasFromRoomDirectory(alias: String) async throws  -> Bool
    
    /**
     * Reports an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to report
     *
     * * `reason` - The reason for the event being reported (optional).
     *
     * * `score` - The score to rate this content as where -100 is most
     * offensive and 0 is inoffensive (optional).
     */
    func reportContent(eventId: String, score: Int32?, reason: String?) async throws 
    
    /**
     * Reports a room as inappropriate to the server.
     * The caller is not required to be joined to the room to report it.
     *
     * # Arguments
     *
     * * `reason` - The reason the room is being reported.
     *
     * # Errors
     *
     * Returns an error if the room is not found or on rate limit
     */
    func reportRoom(reason: String) async throws 
    
    func resetPowerLevels() async throws  -> RoomPowerLevels
    
    /**
     * Return a debug representation for the internal room events data
     * structure, one line per entry in the resulting vector.
     */
    func roomEventsDebugString() async throws  -> [String]
    
    func roomInfo() async throws  -> RoomInfo
    
    /**
     * Store the given `ComposerDraft` in the state store using the current
     * room id, as identifier.
     */
    func saveComposerDraft(draft: ComposerDraft, threadRoot: String?) async throws 
    
    /**
     * Send the current users live location beacon in the room.
     */
    func sendLiveLocation(geoUri: String) async throws 
    
    /**
     * Send a raw event to the room.
     *
     * # Arguments
     *
     * * `event_type` - The type of the event to send.
     *
     * * `content` - The content of the event to send encoded as JSON string.
     */
    func sendRaw(eventType: String, content: String) async throws 
    
    func setIsFavourite(isFavourite: Bool, tagOrder: Double?) async throws 
    
    func setIsLowPriority(isLowPriority: Bool, tagOrder: Double?) async throws 
    
    /**
     * Sets a new name to the room.
     */
    func setName(name: String) async throws 
    
    /**
     * Set a MSC4306 subscription to a thread in this room, based on the thread
     * root event id.
     *
     * If `subscribed` is `true`, it will subscribe to the thread, with a
     * precision that the subscription was manually requested by the user
     * (i.e. not automatic).
     *
     * If the thread was already subscribed to (resp. unsubscribed from), while
     * trying to subscribe to it (resp. unsubscribe from it), it will do
     * nothing, i.e. subscribing (resp. unsubscribing) to a thread is an
     * idempotent operation.
     */
    func setThreadSubscription(threadRootEventId: String, subscribed: Bool) async throws 
    
    /**
     * Sets a new topic in the room.
     */
    func setTopic(topic: String) async throws 
    
    /**
     * Set (or unset) a flag on the room to indicate that the user has
     * explicitly marked it as unread.
     */
    func setUnreadFlag(newValue: Bool) async throws 
    
    /**
     * Start the current users live location share in the room.
     */
    func startLiveLocationShare(durationMillis: UInt64) async throws 
    
    /**
     * Stop the current users live location share in the room.
     */
    func stopLiveLocationShare() async throws 
    
    /**
     * Subscribes to call decline for a currently ringing call, using a
     * `listener` to be notified when someone declines.
     *
     * Will error if `rtc_notification_event_id` is not a valid event id.
     * Use the [`TaskHandle`] to cancel the subscription.
     */
    func subscribeToCallDeclineEvents(rtcNotificationEventId: String, listener: CallDeclineListener) throws  -> TaskHandle
    
    func subscribeToIdentityStatusChanges(listener: IdentityStatusChangeListener) async throws  -> TaskHandle
    
    /**
     * Subscribes to requests to join this room (knock member events), using a
     * `listener` to be notified of the changes.
     *
     * The current requests to join the room will be emitted immediately
     * when subscribing, along with a [`TaskHandle`] to cancel the
     * subscription.
     */
    func subscribeToKnockRequests(listener: KnockRequestsListener) async throws  -> TaskHandle
    
    /**
     * Subscribes to live location shares in this room, using a `listener` to
     * be notified of the changes.
     *
     * The current live location shares will be emitted immediately when
     * subscribing, along with a [`TaskHandle`] to cancel the subscription.
     */
    func subscribeToLiveLocationShares(listener: LiveLocationShareListener)  -> TaskHandle
    
    func subscribeToRoomInfoUpdates(listener: RoomInfoListener)  -> TaskHandle
    
    /**
     * Subscribe to all send queue updates in this room.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
    func subscribeToSendQueueUpdates(listener: SendQueueListener) async throws  -> TaskHandle
    
    func subscribeToTypingNotifications(listener: TypingNotificationsListener)  -> TaskHandle
    
    /**
     * If this room is tombstoned, return the â€œreferenceâ€ to the successor room
     * â€”i.e. the room replacing this one.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     */
    func successorRoom()  -> SuccessorRoom?
    
    func suggestedRoleForUser(userId: String) async throws  -> RoomMemberRole
    
    /**
     * Create a timeline with a default configuration, i.e. a live timeline
     * with read receipts and read marker tracking.
     */
    func timeline() async throws  -> Timeline
    
    /**
     * Build a new timeline instance with the given configuration.
     */
    func timelineWithConfiguration(configuration: TimelineConfiguration) async throws  -> Timeline
    
    func topic()  -> String?
    
    func typingNotice(isTyping: Bool) async throws 
    
    func unbanUser(userId: String, reason: String?) async throws 
    
    /**
     * Update the canonical alias of the room.
     *
     * Note that publishing the alias in the room directory is done separately.
     */
    func updateCanonicalAlias(alias: String?, altAliases: [String]) async throws 
    
    /**
     * Update room history visibility for this room.
     */
    func updateHistoryVisibility(visibility: RoomHistoryVisibility) async throws 
    
    /**
     * Update the join rule for this room.
     */
    func updateJoinRules(newRule: JoinRule) async throws 
    
    func updatePowerLevelsForUsers(updates: [UserPowerLevelUpdate]) async throws 
    
    /**
     * Update the room's visibility in the room directory.
     */
    func updateRoomVisibility(visibility: RoomVisibility) async throws 
    
    /**
     * Upload and set the room's avatar.
     *
     * This will upload the data produced by the reader to the homeserver's
     * content repository, and set the room's avatar to the MXC URI for the
     * uploaded file.
     *
     * # Arguments
     *
     * * `mime_type` - The mime description of the avatar, for example
     * image/jpeg
     * * `data` - The raw data that will be uploaded to the homeserver's
     * content repository
     * * `media_info` - The media info used as avatar image info.
     */
    func uploadAvatar(mimeType: String, data: Data, mediaInfo: ImageInfo?) async throws 
    
    /**
     * Remove verification requirements for the given users and
     * resend messages that failed to send because their identities were no
     * longer verified (in response to
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
     *
     * # Arguments
     *
     * * `user_ids` - The list of users identifiers received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
    func withdrawVerificationAndResend(userIds: [String], sendHandle: SendHandle) async throws 
    
}
open class Room: RoomProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_room(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_room(handle, $0) }
    }

    

    
open func activeMembersCount() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_active_members_count(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns a Vec of userId's that participate in the room call.
     *
     * MatrixRTC memberships with application "m.call" and scope "m.room" are
     * considered. A user can occur twice if they join with two devices.
     * convert to a set depending if the different users are required or the
     * amount of sessions.
     *
     * The vector is ordered by oldest membership user to newest.
     */
open func activeRoomCallParticipants() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_active_room_call_participants(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func alternativeAliases() -> [String]  {
    return try!  FfiConverterSequenceString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_alternative_aliases(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func applyPowerLevelChanges(changes: RoomPowerLevelChanges)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_apply_power_level_changes(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeRoomPowerLevelChanges_lower(changes)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func avatarUrl() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_avatar_url(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func banUser(userId: String, reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_ban_user(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func canonicalAlias() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_canonical_alias(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Remove the `ComposerDraft` stored in the state store for this room.
     */
open func clearComposerDraft(threadRoot: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_clear_composer_draft(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionString.lower(threadRoot)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Clear the event cache storage for the current room.
     *
     * This will remove all the information related to the event cache, in
     * memory and in the persisted storage, if enabled.
     */
open func clearEventCacheStorage()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_clear_event_cache_storage(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Declines a call (and stop ringing).
     *
     * # Arguments
     *
     * * `rtc_notification_event_id` - the event id of the m.rtc.notification
     * event.
     */
open func declineCall(rtcNotificationEventId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_decline_call(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(rtcNotificationEventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Forces the currently active room key, which is used to encrypt messages,
     * to be rotated.
     *
     * A new room key will be crated and shared with all the room members the
     * next time a message will be sent. You don't have to call this method,
     * room keys will be rotated automatically when necessary. This method is
     * still useful for debugging purposes.
     */
open func discardRoomKey()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_discard_room_key(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns the room's name from the state event if available, otherwise
     * compute a room name based on the room's nature (DM or not) and number of
     * members.
     */
open func displayName() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_display_name(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Edit an event given its event id.
     *
     * Useful outside the context of a timeline, or when a timeline doesn't
     * have the full content of an event.
     */
open func edit(eventId: String, newContent: RoomMessageEventContentWithoutRelation)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_edit(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId),FfiConverterTypeRoomMessageEventContentWithoutRelation_lower(newContent)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Enable End-to-end encryption in this room.
     */
open func enableEncryption()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_enable_encryption(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Enable or disable the send queue for that particular room.
     */
open func enableSendQueue(enable: Bool)  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_enable_send_queue(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(enable),$0
    )
}
}
    
open func encryptionState() -> EncryptionState  {
    return try!  FfiConverterTypeEncryptionState_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_encryption_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Return the current MSC4306 thread subscription for the given thread root
     * in this room.
     *
     * Returns `None` if the thread doesn't exist, or isn't subscribed to, or
     * the server can't handle MSC4306; otherwise, returns the thread
     * subscription status.
     */
open func fetchThreadSubscription(threadRootEventId: String)async throws  -> ThreadSubscription?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_fetch_thread_subscription(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(threadRootEventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeThreadSubscription.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Forget this room.
     *
     * This communicates to the homeserver that it should forget the room.
     *
     * Only left or banned-from rooms can be forgotten.
     */
open func forget()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_forget(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func getPowerLevels()async throws  -> RoomPowerLevels  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_get_power_levels(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomPowerLevels_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns the visibility for this room in the room directory.
     *
     * [Public](`RoomVisibility::Public`) rooms are listed in the room
     * directory and can be found using it.
     */
open func getRoomVisibility()async throws  -> RoomVisibility  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_get_room_visibility(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomVisibility_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Is there a non expired membership with application "m.call" and scope
     * "m.room" in this room.
     */
open func hasActiveRoomCall() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_has_active_room_call(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns the room heroes for this room.
     */
open func heroes() -> [RoomHero]  {
    return try!  FfiConverterSequenceTypeRoomHero.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_heroes(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func id() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Set the local trust for the given devices to `LocalTrust::Ignored`
     * and resend messages that failed to send because said devices are
     * unverified (in response to
     * `SessionRecipientCollectionError::VerifiedUserHasUnsignedDevice`).
     * # Arguments
     *
     * * `devices` - The map of users identifiers to device identifiers
     * received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
open func ignoreDeviceTrustAndResend(devices: [String: [String]], sendHandle: SendHandle)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_ignore_device_trust_and_resend(
                    self.uniffiCloneHandle(),
                    FfiConverterDictionaryStringSequenceString.lower(devices),FfiConverterTypeSendHandle_lower(sendHandle)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Ignores a user.
     *
     * # Arguments
     *
     * * `user_id` - The ID of the user to ignore.
     */
open func ignoreUser(userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_ignore_user(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func inviteUserById(userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_invite_user_by_id(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func invitedMembersCount() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_invited_members_count(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get the user who created the invite, if any.
     */
open func inviter()async throws  -> RoomMember?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_inviter(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomMember.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func isDirect()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_is_direct(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Checks whether the room is encrypted or not.
     *
     * **Note**: this info may not be reliable if you don't set up
     * `m.room.encryption` as required state.
     */
open func isEncrypted()async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_is_encrypted(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Whether the room can be publicly joined or not, based on its join rule.
     *
     * Can return `None` if the join rule state event is missing.
     */
open func isPublic() -> Bool?  {
    return try!  FfiConverterOptionBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_public(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns whether the send queue for that particular room is enabled or
     * not.
     */
open func isSendQueueEnabled() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_send_queue_enabled(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func isSpace() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_is_space(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Join this room.
     *
     * Only invited and left rooms can be joined via this method.
     */
open func join()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_join(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func joinedMembersCount() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_joined_members_count(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func kickUser(userId: String, reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_kick_user(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func latestEncryptionState()async throws  -> EncryptionState  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_latest_encryption_state(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEncryptionState_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func latestEvent()async  -> LatestEventValue  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_latest_event(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeLatestEventValue_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Leave this room.
     *
     * Only invited and joined rooms can be left.
     */
open func leave()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_leave(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Retrieve the `ComposerDraft` stored in the state store for this room.
     */
open func loadComposerDraft(threadRoot: String?)async throws  -> ComposerDraft?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_load_composer_draft(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionString.lower(threadRoot)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeComposerDraft.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Either loads the event associated with the `event_id` from the event
     * cache or fetches it from the homeserver.
     */
open func loadOrFetchEvent(eventId: String)async throws  -> TimelineEvent  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_load_or_fetch_event(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTimelineEvent_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Mark a room as fully read, by attaching a read receipt to the provided
     * `event_id`.
     *
     * **Warning:** using this method is **NOT** recommended, as providing the
     * latest event id can cause incorrect read receipts. This method won't
     * check if sending the read receipt is necessary or valid. It should
     * *only* be used when some constraint prevents you from instantiating a
     * [`Timeline`]. For any other case use [`Timeline::mark_as_read`]
     * instead.
     */
open func markAsFullyReadUnchecked(eventId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_mark_as_fully_read_unchecked(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Mark a room as read, by attaching a read receipt on the latest event.
     *
     * Note: this does NOT unset the unread flag; it's the caller's
     * responsibility to do so, if need be.
     */
open func markAsRead(receiptType: ReceiptType)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_mark_as_read(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeReceiptType_lower(receiptType)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func matrixToEventPermalink(eventId: String)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_event_permalink(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func matrixToPermalink()async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_matrix_to_permalink(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func member(userId: String)async throws  -> RoomMember  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_member(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomMember_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func memberAvatarUrl(userId: String)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_member_avatar_url(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func memberDisplayName(userId: String)async throws  -> String?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_member_display_name(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get the membership details for the current user.
     *
     * Returns:
     * - If the user was present in the room, a
     * [`matrix_sdk::room::RoomMemberWithSenderInfo`] containing both the
     * user info and the member info of the sender of the `m.room.member`
     * event.
     * - If the current user is not present, an error.
     */
open func memberWithSenderInfo(userId: String)async throws  -> RoomMemberWithSenderInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_member_with_sender_info(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomMemberWithSenderInfo_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func members()async throws  -> RoomMembersIterator  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_members(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomMembersIterator_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func membersNoSync()async throws  -> RoomMembersIterator  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_members_no_sync(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomMembersIterator_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * The room's current membership state.
     */
open func membership() -> Membership  {
    return try!  FfiConverterTypeMembership_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_membership(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func ownUserId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_own_user_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * If this room is the successor of a tombstoned room, return the
     * â€œreferenceâ€ to the predecessor room.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * To determine if a room is the successor of a tombstoned room, the
     * [`m.room.create`] must have been received, **with** a `predecessor`
     * field.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
     */
open func predecessorRoom() -> PredecessorRoom?  {
    return try!  FfiConverterOptionTypePredecessorRoom.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_predecessor_room(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Builds a `RoomPreview` from a room list item. This is intended for
     * invited, knocked or banned rooms.
     */
open func previewRoom(via: [String])async throws  -> RoomPreview  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_preview_room(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceString.lower(via)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomPreview_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Publish a new room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias didn't exist and it's now published.
     * - `false` if the room alias was already present so it couldn't be
     * published.
     */
open func publishRoomAliasInRoomDirectory(alias: String)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_publish_room_alias_in_room_directory(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(alias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * The raw name as present in the room state event.
     */
open func rawName() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_raw_name(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Redacts an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to redact
     *
     * * `reason` - The reason for the event being redacted (optional). its
     * transaction ID (optional). If not given one is created.
     */
open func redact(eventId: String, reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_redact(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Removes the current room avatar
     */
open func removeAvatar()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_remove_avatar(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Remove an existing room alias for this room in the room directory.
     *
     * Returns:
     * - `true` if the room alias was present and it's now removed from the
     * room directory.
     * - `false` if the room alias didn't exist so it couldn't be removed.
     */
open func removeRoomAliasFromRoomDirectory(alias: String)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_remove_room_alias_from_room_directory(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(alias)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Reports an event from the room.
     *
     * # Arguments
     *
     * * `event_id` - The ID of the event to report
     *
     * * `reason` - The reason for the event being reported (optional).
     *
     * * `score` - The score to rate this content as where -100 is most
     * offensive and 0 is inoffensive (optional).
     */
open func reportContent(eventId: String, score: Int32?, reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_report_content(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId),FfiConverterOptionInt32.lower(score),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Reports a room as inappropriate to the server.
     * The caller is not required to be joined to the room to report it.
     *
     * # Arguments
     *
     * * `reason` - The reason the room is being reported.
     *
     * # Errors
     *
     * Returns an error if the room is not found or on rate limit
     */
open func reportRoom(reason: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_report_room(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func resetPowerLevels()async throws  -> RoomPowerLevels  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_reset_power_levels(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomPowerLevels_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Return a debug representation for the internal room events data
     * structure, one line per entry in the resulting vector.
     */
open func roomEventsDebugString()async throws  -> [String]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_room_events_debug_string(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceString.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func roomInfo()async throws  -> RoomInfo  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_room_info(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomInfo_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Store the given `ComposerDraft` in the state store using the current
     * room id, as identifier.
     */
open func saveComposerDraft(draft: ComposerDraft, threadRoot: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_save_composer_draft(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeComposerDraft_lower(draft),FfiConverterOptionString.lower(threadRoot)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Send the current users live location beacon in the room.
     */
open func sendLiveLocation(geoUri: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_send_live_location(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(geoUri)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Send a raw event to the room.
     *
     * # Arguments
     *
     * * `event_type` - The type of the event to send.
     *
     * * `content` - The content of the event to send encoded as JSON string.
     */
open func sendRaw(eventType: String, content: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_send_raw(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventType),FfiConverterString.lower(content)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setIsFavourite(isFavourite: Bool, tagOrder: Double?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_is_favourite(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(isFavourite),FfiConverterOptionDouble.lower(tagOrder)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setIsLowPriority(isLowPriority: Bool, tagOrder: Double?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_is_low_priority(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(isLowPriority),FfiConverterOptionDouble.lower(tagOrder)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Sets a new name to the room.
     */
open func setName(name: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_name(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(name)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Set a MSC4306 subscription to a thread in this room, based on the thread
     * root event id.
     *
     * If `subscribed` is `true`, it will subscribe to the thread, with a
     * precision that the subscription was manually requested by the user
     * (i.e. not automatic).
     *
     * If the thread was already subscribed to (resp. unsubscribed from), while
     * trying to subscribe to it (resp. unsubscribe from it), it will do
     * nothing, i.e. subscribing (resp. unsubscribing) to a thread is an
     * idempotent operation.
     */
open func setThreadSubscription(threadRootEventId: String, subscribed: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_thread_subscription(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(threadRootEventId),FfiConverterBool.lower(subscribed)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Sets a new topic in the room.
     */
open func setTopic(topic: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_topic(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(topic)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Set (or unset) a flag on the room to indicate that the user has
     * explicitly marked it as unread.
     */
open func setUnreadFlag(newValue: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_set_unread_flag(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(newValue)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Start the current users live location share in the room.
     */
open func startLiveLocationShare(durationMillis: UInt64)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_start_live_location_share(
                    self.uniffiCloneHandle(),
                    FfiConverterUInt64.lower(durationMillis)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Stop the current users live location share in the room.
     */
open func stopLiveLocationShare()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_stop_live_location_share(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Subscribes to call decline for a currently ringing call, using a
     * `listener` to be notified when someone declines.
     *
     * Will error if `rtc_notification_event_id` is not a valid event id.
     * Use the [`TaskHandle`] to cancel the subscription.
     */
open func subscribeToCallDeclineEvents(rtcNotificationEventId: String, listener: CallDeclineListener)throws  -> TaskHandle  {
    return try  FfiConverterTypeTaskHandle_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_call_decline_events(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(rtcNotificationEventId),
        FfiConverterCallbackInterfaceCallDeclineListener_lower(listener),$0
    )
})
}
    
open func subscribeToIdentityStatusChanges(listener: IdentityStatusChangeListener)async throws  -> TaskHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_identity_status_changes(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceIdentityStatusChangeListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Subscribes to requests to join this room (knock member events), using a
     * `listener` to be notified of the changes.
     *
     * The current requests to join the room will be emitted immediately
     * when subscribing, along with a [`TaskHandle`] to cancel the
     * subscription.
     */
open func subscribeToKnockRequests(listener: KnockRequestsListener)async throws  -> TaskHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_knock_requests(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceKnockRequestsListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Subscribes to live location shares in this room, using a `listener` to
     * be notified of the changes.
     *
     * The current live location shares will be emitted immediately when
     * subscribing, along with a [`TaskHandle`] to cancel the subscription.
     */
open func subscribeToLiveLocationShares(listener: LiveLocationShareListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_live_location_shares(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceLiveLocationShareListener_lower(listener),$0
    )
})
}
    
open func subscribeToRoomInfoUpdates(listener: RoomInfoListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_room_info_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceRoomInfoListener_lower(listener),$0
    )
})
}
    
    /**
     * Subscribe to all send queue updates in this room.
     *
     * The given listener will be immediately called with
     * `RoomSendQueueUpdate::NewLocalEvent` for each local echo existing in
     * the queue.
     */
open func subscribeToSendQueueUpdates(listener: SendQueueListener)async throws  -> TaskHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_send_queue_updates(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceSendQueueListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func subscribeToTypingNotifications(listener: TypingNotificationsListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_subscribe_to_typing_notifications(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceTypingNotificationsListener_lower(listener),$0
    )
})
}
    
    /**
     * If this room is tombstoned, return the â€œreferenceâ€ to the successor room
     * â€”i.e. the room replacing this one.
     *
     * A room is tombstoned if it has received a [`m.room.tombstone`] state
     * event.
     *
     * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
     */
open func successorRoom() -> SuccessorRoom?  {
    return try!  FfiConverterOptionTypeSuccessorRoom.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_successor_room(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func suggestedRoleForUser(userId: String)async throws  -> RoomMemberRole  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_suggested_role_for_user(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeRoomMemberRole_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Create a timeline with a default configuration, i.e. a live timeline
     * with read receipts and read marker tracking.
     */
open func timeline()async throws  -> Timeline  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_timeline(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTimeline_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Build a new timeline instance with the given configuration.
     */
open func timelineWithConfiguration(configuration: TimelineConfiguration)async throws  -> Timeline  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_timeline_with_configuration(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeTimelineConfiguration_lower(configuration)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTimeline_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func topic() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_room_topic(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func typingNotice(isTyping: Bool)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_typing_notice(
                    self.uniffiCloneHandle(),
                    FfiConverterBool.lower(isTyping)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func unbanUser(userId: String, reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_unban_user(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Update the canonical alias of the room.
     *
     * Note that publishing the alias in the room directory is done separately.
     */
open func updateCanonicalAlias(alias: String?, altAliases: [String])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_update_canonical_alias(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionString.lower(alias),FfiConverterSequenceString.lower(altAliases)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Update room history visibility for this room.
     */
open func updateHistoryVisibility(visibility: RoomHistoryVisibility)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_update_history_visibility(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeRoomHistoryVisibility_lower(visibility)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Update the join rule for this room.
     */
open func updateJoinRules(newRule: JoinRule)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_update_join_rules(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeJoinRule_lower(newRule)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func updatePowerLevelsForUsers(updates: [UserPowerLevelUpdate])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_update_power_levels_for_users(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceTypeUserPowerLevelUpdate.lower(updates)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Update the room's visibility in the room directory.
     */
open func updateRoomVisibility(visibility: RoomVisibility)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_update_room_visibility(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeRoomVisibility_lower(visibility)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Upload and set the room's avatar.
     *
     * This will upload the data produced by the reader to the homeserver's
     * content repository, and set the room's avatar to the MXC URI for the
     * uploaded file.
     *
     * # Arguments
     *
     * * `mime_type` - The mime description of the avatar, for example
     * image/jpeg
     * * `data` - The raw data that will be uploaded to the homeserver's
     * content repository
     * * `media_info` - The media info used as avatar image info.
     */
open func uploadAvatar(mimeType: String, data: Data, mediaInfo: ImageInfo?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_upload_avatar(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(mimeType),FfiConverterData.lower(data),FfiConverterOptionTypeImageInfo.lower(mediaInfo)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Remove verification requirements for the given users and
     * resend messages that failed to send because their identities were no
     * longer verified (in response to
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity`)
     *
     * # Arguments
     *
     * * `user_ids` - The list of users identifiers received in the error
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo the send error applies to
     */
open func withdrawVerificationAndResend(userIds: [String], sendHandle: SendHandle)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_room_withdraw_verification_and_resend(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceString.lower(userIds),FfiConverterTypeSendHandle_lower(sendHandle)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoom: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Room

    public static func lift(_ handle: UInt64) throws -> Room {
        return Room(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Room) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Room {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Room, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoom_lift(_ handle: UInt64) throws -> Room {
    return try FfiConverterTypeRoom.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoom_lower(_ value: Room) -> UInt64 {
    return FfiConverterTypeRoom.lower(value)
}






/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
public protocol RoomDirectorySearchProtocol: AnyObject, Sendable {
    
    /**
     * Get whether the search is at the last page.
     */
    func isAtLastPage() async throws  -> Bool
    
    /**
     * Get the number of pages that have been loaded so far.
     */
    func loadedPages() async throws  -> UInt32
    
    /**
     * Asks the server for the next page of the current search.
     */
    func nextPage() async throws 
    
    /**
     * Registers a callback to receive new search results when starting a
     * search or getting new paginated results.
     */
    func results(listener: RoomDirectorySearchEntriesListener) async  -> TaskHandle
    
    /**
     * Starts a filtered search for the server.
     *
     * If the `filter` is not provided it will search for all the rooms.
     * You can specify a `batch_size` to control the number of rooms to fetch
     * per request.
     *
     * If the `via_server` is not provided it will search in the current
     * homeserver by default.
     *
     * This method will clear the current search results and start a new one.
     */
    func search(filter: String?, batchSize: UInt32, viaServerName: String?) async throws 
    
}
/**
 * A helper for performing room searches in the room directory.
 * The way this is intended to be used is:
 *
 * 1. Register a callback using [`RoomDirectorySearch::results`].
 * 2. Start the room search with [`RoomDirectorySearch::search`].
 * 3. To get more results, use [`RoomDirectorySearch::next_page`].
 */
open class RoomDirectorySearch: RoomDirectorySearchProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomdirectorysearch(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomdirectorysearch(handle, $0) }
    }

    

    
    /**
     * Get whether the search is at the last page.
     */
open func isAtLastPage()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_is_at_last_page(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get the number of pages that have been loaded so far.
     */
open func loadedPages()async throws  -> UInt32  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_loaded_pages(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u32,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u32,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u32,
            liftFunc: FfiConverterUInt32.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Asks the server for the next page of the current search.
     */
open func nextPage()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_next_page(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Registers a callback to receive new search results when starting a
     * search or getting new paginated results.
     */
open func results(listener: RoomDirectorySearchEntriesListener)async  -> TaskHandle  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_results(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Starts a filtered search for the server.
     *
     * If the `filter` is not provided it will search for all the rooms.
     * You can specify a `batch_size` to control the number of rooms to fetch
     * per request.
     *
     * If the `via_server` is not provided it will search in the current
     * homeserver by default.
     *
     * This method will clear the current search results and start a new one.
     */
open func search(filter: String?, batchSize: UInt32, viaServerName: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomdirectorysearch_search(
                    self.uniffiCloneHandle(),
                    FfiConverterOptionString.lower(filter),FfiConverterUInt32.lower(batchSize),FfiConverterOptionString.lower(viaServerName)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomDirectorySearch: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomDirectorySearch

    public static func lift(_ handle: UInt64) throws -> RoomDirectorySearch {
        return RoomDirectorySearch(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomDirectorySearch) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDirectorySearch {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomDirectorySearch, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDirectorySearch_lift(_ handle: UInt64) throws -> RoomDirectorySearch {
    return try FfiConverterTypeRoomDirectorySearch.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDirectorySearch_lower(_ value: RoomDirectorySearch) -> UInt64 {
    return FfiConverterTypeRoomDirectorySearch.lower(value)
}






public protocol RoomListProtocol: AnyObject, Sendable {
    
    func entriesWithDynamicAdapters(pageSize: UInt32, listener: RoomListEntriesListener)  -> RoomListEntriesWithDynamicAdaptersResult
    
    func entriesWithDynamicAdaptersWith(pageSize: UInt32, enableLatestEventSorter: Bool, listener: RoomListEntriesListener)  -> RoomListEntriesWithDynamicAdaptersResult
    
    func loadingState(listener: RoomListLoadingStateListener) throws  -> RoomListLoadingStateResult
    
    func room(roomId: String) throws  -> Room
    
}
open class RoomList: RoomListProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlist(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlist(handle, $0) }
    }

    

    
open func entriesWithDynamicAdapters(pageSize: UInt32, listener: RoomListEntriesListener) -> RoomListEntriesWithDynamicAdaptersResult  {
    return try!  FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters(
            self.uniffiCloneHandle(),
        FfiConverterUInt32.lower(pageSize),
        FfiConverterCallbackInterfaceRoomListEntriesListener_lower(listener),$0
    )
})
}
    
open func entriesWithDynamicAdaptersWith(pageSize: UInt32, enableLatestEventSorter: Bool, listener: RoomListEntriesListener) -> RoomListEntriesWithDynamicAdaptersResult  {
    return try!  FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_entries_with_dynamic_adapters_with(
            self.uniffiCloneHandle(),
        FfiConverterUInt32.lower(pageSize),
        FfiConverterBool.lower(enableLatestEventSorter),
        FfiConverterCallbackInterfaceRoomListEntriesListener_lower(listener),$0
    )
})
}
    
open func loadingState(listener: RoomListLoadingStateListener)throws  -> RoomListLoadingStateResult  {
    return try  FfiConverterTypeRoomListLoadingStateResult_lift(try rustCallWithError(FfiConverterTypeRoomListError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_loading_state(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceRoomListLoadingStateListener_lower(listener),$0
    )
})
}
    
open func room(roomId: String)throws  -> Room  {
    return try  FfiConverterTypeRoom_lift(try rustCallWithError(FfiConverterTypeRoomListError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlist_room(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(roomId),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomList: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomList

    public static func lift(_ handle: UInt64) throws -> RoomList {
        return RoomList(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomList) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomList {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomList, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomList_lift(_ handle: UInt64) throws -> RoomList {
    return try FfiConverterTypeRoomList.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomList_lower(_ value: RoomList) -> UInt64 {
    return FfiConverterTypeRoomList.lower(value)
}






public protocol RoomListDynamicEntriesControllerProtocol: AnyObject, Sendable {
    
    func addOnePage() 
    
    func resetToOnePage() 
    
    func setFilter(kind: RoomListEntriesDynamicFilterKind)  -> Bool
    
}
open class RoomListDynamicEntriesController: RoomListDynamicEntriesControllerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlistdynamicentriescontroller(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistdynamicentriescontroller(handle, $0) }
    }

    

    
open func addOnePage()  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_add_one_page(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func resetToOnePage()  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_reset_to_one_page(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func setFilter(kind: RoomListEntriesDynamicFilterKind) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistdynamicentriescontroller_set_filter(
            self.uniffiCloneHandle(),
        FfiConverterTypeRoomListEntriesDynamicFilterKind_lower(kind),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListDynamicEntriesController: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomListDynamicEntriesController

    public static func lift(_ handle: UInt64) throws -> RoomListDynamicEntriesController {
        return RoomListDynamicEntriesController(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomListDynamicEntriesController) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListDynamicEntriesController {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomListDynamicEntriesController, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListDynamicEntriesController_lift(_ handle: UInt64) throws -> RoomListDynamicEntriesController {
    return try FfiConverterTypeRoomListDynamicEntriesController.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListDynamicEntriesController_lower(_ value: RoomListDynamicEntriesController) -> UInt64 {
    return FfiConverterTypeRoomListDynamicEntriesController.lower(value)
}






public protocol RoomListEntriesWithDynamicAdaptersResultProtocol: AnyObject, Sendable {
    
    func controller()  -> RoomListDynamicEntriesController
    
    func entriesStream()  -> TaskHandle
    
}
open class RoomListEntriesWithDynamicAdaptersResult: RoomListEntriesWithDynamicAdaptersResultProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlistentrieswithdynamicadaptersresult(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistentrieswithdynamicadaptersresult(handle, $0) }
    }

    

    
open func controller() -> RoomListDynamicEntriesController  {
    return try!  FfiConverterTypeRoomListDynamicEntriesController_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_controller(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func entriesStream() -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistentrieswithdynamicadaptersresult_entries_stream(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomListEntriesWithDynamicAdaptersResult

    public static func lift(_ handle: UInt64) throws -> RoomListEntriesWithDynamicAdaptersResult {
        return RoomListEntriesWithDynamicAdaptersResult(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomListEntriesWithDynamicAdaptersResult) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesWithDynamicAdaptersResult {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomListEntriesWithDynamicAdaptersResult, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult_lift(_ handle: UInt64) throws -> RoomListEntriesWithDynamicAdaptersResult {
    return try FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult_lower(_ value: RoomListEntriesWithDynamicAdaptersResult) -> UInt64 {
    return FfiConverterTypeRoomListEntriesWithDynamicAdaptersResult.lower(value)
}






public protocol RoomListServiceProtocol: AnyObject, Sendable {
    
    func allRooms() async throws  -> RoomList
    
    func room(roomId: String) throws  -> Room
    
    func state(listener: RoomListServiceStateListener)  -> TaskHandle
    
    func subscribeToRooms(roomIds: [String]) async throws 
    
    func syncIndicator(delayBeforeShowingInMs: UInt32, delayBeforeHidingInMs: UInt32, listener: RoomListServiceSyncIndicatorListener)  -> TaskHandle
    
}
open class RoomListService: RoomListServiceProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roomlistservice(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roomlistservice(handle, $0) }
    }

    

    
open func allRooms()async throws  -> RoomList  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistservice_all_rooms(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeRoomList_lift,
            errorHandler: FfiConverterTypeRoomListError_lift
        )
}
    
open func room(roomId: String)throws  -> Room  {
    return try  FfiConverterTypeRoom_lift(try rustCallWithError(FfiConverterTypeRoomListError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_room(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(roomId),$0
    )
})
}
    
open func state(listener: RoomListServiceStateListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_state(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceRoomListServiceStateListener_lower(listener),$0
    )
})
}
    
open func subscribeToRooms(roomIds: [String])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roomlistservice_subscribe_to_rooms(
                    self.uniffiCloneHandle(),
                    FfiConverterSequenceString.lower(roomIds)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRoomListError_lift
        )
}
    
open func syncIndicator(delayBeforeShowingInMs: UInt32, delayBeforeHidingInMs: UInt32, listener: RoomListServiceSyncIndicatorListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roomlistservice_sync_indicator(
            self.uniffiCloneHandle(),
        FfiConverterUInt32.lower(delayBeforeShowingInMs),
        FfiConverterUInt32.lower(delayBeforeHidingInMs),
        FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener_lower(listener),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListService: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomListService

    public static func lift(_ handle: UInt64) throws -> RoomListService {
        return RoomListService(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomListService) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListService {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomListService, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListService_lift(_ handle: UInt64) throws -> RoomListService {
    return try FfiConverterTypeRoomListService.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListService_lower(_ value: RoomListService) -> UInt64 {
    return FfiConverterTypeRoomListService.lower(value)
}






public protocol RoomMembersIteratorProtocol: AnyObject, Sendable {
    
    func len()  -> UInt32
    
    func nextChunk(chunkSize: UInt32)  -> [RoomMember]?
    
}
open class RoomMembersIterator: RoomMembersIteratorProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roommembersiterator(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommembersiterator(handle, $0) }
    }

    

    
open func len() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_len(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func nextChunk(chunkSize: UInt32) -> [RoomMember]?  {
    return try!  FfiConverterOptionSequenceTypeRoomMember.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roommembersiterator_next_chunk(
            self.uniffiCloneHandle(),
        FfiConverterUInt32.lower(chunkSize),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomMembersIterator: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomMembersIterator

    public static func lift(_ handle: UInt64) throws -> RoomMembersIterator {
        return RoomMembersIterator(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomMembersIterator) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMembersIterator {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomMembersIterator, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMembersIterator_lift(_ handle: UInt64) throws -> RoomMembersIterator {
    return try FfiConverterTypeRoomMembersIterator.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMembersIterator_lower(_ value: RoomMembersIterator) -> UInt64 {
    return FfiConverterTypeRoomMembersIterator.lower(value)
}






public protocol RoomMessageEventContentWithoutRelationProtocol: AnyObject, Sendable {
    
    func withMentions(mentions: Mentions)  -> RoomMessageEventContentWithoutRelation
    
}
open class RoomMessageEventContentWithoutRelation: RoomMessageEventContentWithoutRelationProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roommessageeventcontentwithoutrelation(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roommessageeventcontentwithoutrelation(handle, $0) }
    }

    

    
open func withMentions(mentions: Mentions) -> RoomMessageEventContentWithoutRelation  {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roommessageeventcontentwithoutrelation_with_mentions(
            self.uniffiCloneHandle(),
        FfiConverterTypeMentions_lower(mentions),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomMessageEventContentWithoutRelation: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomMessageEventContentWithoutRelation

    public static func lift(_ handle: UInt64) throws -> RoomMessageEventContentWithoutRelation {
        return RoomMessageEventContentWithoutRelation(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomMessageEventContentWithoutRelation) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventContentWithoutRelation {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomMessageEventContentWithoutRelation, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(_ handle: UInt64) throws -> RoomMessageEventContentWithoutRelation {
    return try FfiConverterTypeRoomMessageEventContentWithoutRelation.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMessageEventContentWithoutRelation_lower(_ value: RoomMessageEventContentWithoutRelation) -> UInt64 {
    return FfiConverterTypeRoomMessageEventContentWithoutRelation.lower(value)
}






public protocol RoomPowerLevelsProtocol: AnyObject, Sendable {
    
    /**
     * Returns true if the current user is able to ban in the room.
     */
    func canOwnUserBan()  -> Bool
    
    /**
     * Returns true if the current user is able to invite in the room.
     */
    func canOwnUserInvite()  -> Bool
    
    /**
     * Returns true if the current user is able to kick in the room.
     */
    func canOwnUserKick()  -> Bool
    
    /**
     * Returns true if the current user is able to pin or unpin events in the
     * room.
     */
    func canOwnUserPinUnpin()  -> Bool
    
    /**
     * Returns true if the current user user is able to redact messages of
     * other users in the room.
     */
    func canOwnUserRedactOther()  -> Bool
    
    /**
     * Returns true if the current user is able to redact their own messages in
     * the room.
     */
    func canOwnUserRedactOwn()  -> Bool
    
    /**
     * Returns true if the current user is able to send a specific message type
     * in the room.
     */
    func canOwnUserSendMessage(message: MessageLikeEventType)  -> Bool
    
    /**
     * Returns true if the current user is able to send a specific state event
     * type in the room.
     */
    func canOwnUserSendState(stateEvent: StateEventType)  -> Bool
    
    /**
     * Returns true if the current user is able to trigger a notification in
     * the room.
     */
    func canOwnUserTriggerRoomNotification()  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to ban in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserBan(userId: String) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to invite in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserInvite(userId: String) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to kick in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserKick(userId: String) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to pin or unpin
     * events in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserPinUnpin(userId: String) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to redact
     * messages of other users in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserRedactOther(userId: String) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to redact
     * their own messages in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserRedactOwn(userId: String) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific message type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserSendMessage(userId: String, message: MessageLikeEventType) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific state event type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserSendState(userId: String, stateEvent: StateEventType) throws  -> Bool
    
    /**
     * Returns true if the user with the given user_id is able to trigger a
     * notification in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
    func canUserTriggerRoomNotification(userId: String) throws  -> Bool
    
    func events()  -> [TimelineEventType: Int64]
    
    /**
     * Gets a map with the `UserId` of users with power levels other than `0`
     * and their power level.
     */
    func userPowerLevels()  -> [String: Int64]
    
    func values()  -> RoomPowerLevelsValues
    
}
open class RoomPowerLevels: RoomPowerLevelsProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roompowerlevels(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roompowerlevels(handle, $0) }
    }

    

    
    /**
     * Returns true if the current user is able to ban in the room.
     */
open func canOwnUserBan() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_ban(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns true if the current user is able to invite in the room.
     */
open func canOwnUserInvite() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_invite(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns true if the current user is able to kick in the room.
     */
open func canOwnUserKick() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_kick(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns true if the current user is able to pin or unpin events in the
     * room.
     */
open func canOwnUserPinUnpin() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_pin_unpin(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns true if the current user user is able to redact messages of
     * other users in the room.
     */
open func canOwnUserRedactOther() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_other(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns true if the current user is able to redact their own messages in
     * the room.
     */
open func canOwnUserRedactOwn() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_redact_own(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns true if the current user is able to send a specific message type
     * in the room.
     */
open func canOwnUserSendMessage(message: MessageLikeEventType) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_message(
            self.uniffiCloneHandle(),
        FfiConverterTypeMessageLikeEventType_lower(message),$0
    )
})
}
    
    /**
     * Returns true if the current user is able to send a specific state event
     * type in the room.
     */
open func canOwnUserSendState(stateEvent: StateEventType) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_send_state(
            self.uniffiCloneHandle(),
        FfiConverterTypeStateEventType_lower(stateEvent),$0
    )
})
}
    
    /**
     * Returns true if the current user is able to trigger a notification in
     * the room.
     */
open func canOwnUserTriggerRoomNotification() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_own_user_trigger_room_notification(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to ban in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserBan(userId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_ban(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to invite in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserInvite(userId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_invite(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to kick in the
     * room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserKick(userId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_kick(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to pin or unpin
     * events in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserPinUnpin(userId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_pin_unpin(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to redact
     * messages of other users in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserRedactOther(userId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_other(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to redact
     * their own messages in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserRedactOwn(userId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_redact_own(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific message type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserSendMessage(userId: String, message: MessageLikeEventType)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_message(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),
        FfiConverterTypeMessageLikeEventType_lower(message),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to send a
     * specific state event type in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserSendState(userId: String, stateEvent: StateEventType)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_send_state(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),
        FfiConverterTypeStateEventType_lower(stateEvent),$0
    )
})
}
    
    /**
     * Returns true if the user with the given user_id is able to trigger a
     * notification in the room.
     *
     * The call may fail if there is an error in getting the power levels.
     */
open func canUserTriggerRoomNotification(userId: String)throws  -> Bool  {
    return try  FfiConverterBool.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_can_user_trigger_room_notification(
            self.uniffiCloneHandle(),
        FfiConverterString.lower(userId),$0
    )
})
}
    
open func events() -> [TimelineEventType: Int64]  {
    return try!  FfiConverterDictionaryTypeTimelineEventTypeInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_events(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Gets a map with the `UserId` of users with power levels other than `0`
     * and their power level.
     */
open func userPowerLevels() -> [String: Int64]  {
    return try!  FfiConverterDictionaryStringInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_user_power_levels(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func values() -> RoomPowerLevelsValues  {
    return try!  FfiConverterTypeRoomPowerLevelsValues_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompowerlevels_values(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomPowerLevels: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomPowerLevels

    public static func lift(_ handle: UInt64) throws -> RoomPowerLevels {
        return RoomPowerLevels(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomPowerLevels) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPowerLevels {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomPowerLevels, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPowerLevels_lift(_ handle: UInt64) throws -> RoomPowerLevels {
    return try FfiConverterTypeRoomPowerLevels.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPowerLevels_lower(_ value: RoomPowerLevels) -> UInt64 {
    return FfiConverterTypeRoomPowerLevels.lower(value)
}






/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
public protocol RoomPreviewProtocol: AnyObject, Sendable {
    
    /**
     * Forget the room if we had access to it, and it was left or banned.
     */
    func forget() async throws 
    
    /**
     * Returns the room info the preview contains.
     */
    func info()  -> RoomPreviewInfo
    
    /**
     * Get the user who created the invite, if any.
     */
    func inviter() async  -> RoomMember?
    
    /**
     * Leave the room if the room preview state is either joined, invited or
     * knocked.
     *
     * If rejecting an invite then also forget it as an extra layer of
     * protection against spam attacks.
     *
     * Will return an error otherwise.
     */
    func leave() async throws 
    
    /**
     * Get the membership details for the current user.
     */
    func ownMembershipDetails() async  -> RoomMemberWithSenderInfo?
    
}
/**
 * A room preview for a room. It's intended to be used to represent rooms that
 * aren't joined yet.
 */
open class RoomPreview: RoomPreviewProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_roompreview(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_roompreview(handle, $0) }
    }

    

    
    /**
     * Forget the room if we had access to it, and it was left or banned.
     */
open func forget()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roompreview_forget(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns the room info the preview contains.
     */
open func info() -> RoomPreviewInfo  {
    return try!  FfiConverterTypeRoomPreviewInfo_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_roompreview_info(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get the user who created the invite, if any.
     */
open func inviter()async  -> RoomMember?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roompreview_inviter(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomMember.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Leave the room if the room preview state is either joined, invited or
     * knocked.
     *
     * If rejecting an invite then also forget it as an extra layer of
     * protection against spam attacks.
     *
     * Will return an error otherwise.
     */
open func leave()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roompreview_leave(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Get the membership details for the current user.
     */
open func ownMembershipDetails()async  -> RoomMemberWithSenderInfo?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_roompreview_own_membership_details(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeRoomMemberWithSenderInfo.lift,
            errorHandler: nil
            
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomPreview: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = RoomPreview

    public static func lift(_ handle: UInt64) throws -> RoomPreview {
        return RoomPreview(unsafeFromHandle: handle)
    }

    public static func lower(_ value: RoomPreview) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreview {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: RoomPreview, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPreview_lift(_ handle: UInt64) throws -> RoomPreview {
    return try FfiConverterTypeRoomPreview.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPreview_lower(_ value: RoomPreview) -> UInt64 {
    return FfiConverterTypeRoomPreview.lower(value)
}






public protocol SendAttachmentJoinHandleProtocol: AnyObject, Sendable {
    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
    func cancel() 
    
    /**
     * Wait until the attachment has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    func join() async throws 
    
}
open class SendAttachmentJoinHandle: SendAttachmentJoinHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sendattachmentjoinhandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sendattachmentjoinhandle(handle, $0) }
    }

    

    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
open func cancel()  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_cancel(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Wait until the attachment has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
open func join()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sendattachmentjoinhandle_join(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRoomError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendAttachmentJoinHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SendAttachmentJoinHandle

    public static func lift(_ handle: UInt64) throws -> SendAttachmentJoinHandle {
        return SendAttachmentJoinHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SendAttachmentJoinHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendAttachmentJoinHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SendAttachmentJoinHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendAttachmentJoinHandle_lift(_ handle: UInt64) throws -> SendAttachmentJoinHandle {
    return try FfiConverterTypeSendAttachmentJoinHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendAttachmentJoinHandle_lower(_ value: SendAttachmentJoinHandle) -> UInt64 {
    return FfiConverterTypeSendAttachmentJoinHandle.lower(value)
}






public protocol SendGalleryJoinHandleProtocol: AnyObject, Sendable {
    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
    func cancel() 
    
    /**
     * Wait until the gallery has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
    func join() async throws 
    
}
open class SendGalleryJoinHandle: SendGalleryJoinHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sendgalleryjoinhandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sendgalleryjoinhandle(handle, $0) }
    }

    

    
    /**
     * Cancel the current sending task.
     *
     * A subsequent call to [`Self::join`] will return immediately.
     */
open func cancel()  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_cancel(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Wait until the gallery has been sent.
     *
     * If the sending had been cancelled, will return immediately.
     */
open func join()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sendgalleryjoinhandle_join(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeRoomError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendGalleryJoinHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SendGalleryJoinHandle

    public static func lift(_ handle: UInt64) throws -> SendGalleryJoinHandle {
        return SendGalleryJoinHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SendGalleryJoinHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendGalleryJoinHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SendGalleryJoinHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendGalleryJoinHandle_lift(_ handle: UInt64) throws -> SendGalleryJoinHandle {
    return try FfiConverterTypeSendGalleryJoinHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendGalleryJoinHandle_lower(_ value: SendGalleryJoinHandle) -> UInt64 {
    return FfiConverterTypeSendGalleryJoinHandle.lower(value)
}






/**
 * A handle to perform actions onto a local echo.
 */
public protocol SendHandleProtocol: AnyObject, Sendable {
    
    /**
     * Try to abort the sending of the current event.
     *
     * If this returns `true`, then the sending could be aborted, because the
     * event hasn't been sent yet. Otherwise, if this returns `false`, the
     * event had already been sent and could not be aborted.
     *
     * This has an effect only on the first call; subsequent calls will always
     * return `false`.
     */
    func abort() async throws  -> Bool
    
    /**
     * Attempt to manually resend messages that failed to send due to issues
     * that should now have been fixed.
     *
     * This is useful for example, when there's a
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
     * the user may have re-verified on a different device and would now
     * like to send the failed message that's waiting on this device.
     *
     * # Arguments
     *
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo that should be unwedged.
     */
    func tryResend() async throws 
    
}
/**
 * A handle to perform actions onto a local echo.
 */
open class SendHandle: SendHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sendhandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sendhandle(handle, $0) }
    }

    

    
    /**
     * Try to abort the sending of the current event.
     *
     * If this returns `true`, then the sending could be aborted, because the
     * event hasn't been sent yet. Otherwise, if this returns `false`, the
     * event had already been sent and could not be aborted.
     *
     * This has an effect only on the first call; subsequent calls will always
     * return `false`.
     */
open func abort()async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sendhandle_abort(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Attempt to manually resend messages that failed to send due to issues
     * that should now have been fixed.
     *
     * This is useful for example, when there's a
     * `SessionRecipientCollectionError::VerifiedUserChangedIdentity` error;
     * the user may have re-verified on a different device and would now
     * like to send the failed message that's waiting on this device.
     *
     * # Arguments
     *
     * * `transaction_id` - The send queue transaction identifier of the local
     * echo that should be unwedged.
     */
open func tryResend()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sendhandle_try_resend(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSendHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SendHandle

    public static func lift(_ handle: UInt64) throws -> SendHandle {
        return SendHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SendHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SendHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SendHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendHandle_lift(_ handle: UInt64) throws -> SendHandle {
    return try FfiConverterTypeSendHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSendHandle_lower(_ value: SendHandle) -> UInt64 {
    return FfiConverterTypeSendHandle.lower(value)
}






public protocol SessionVerificationControllerProtocol: AnyObject, Sendable {
    
    /**
     * Accept the previously acknowledged verification request
     */
    func acceptVerificationRequest() async throws 
    
    /**
     * Set this particular request as the currently active one and register for
     * events pertaining it.
     * * `sender_id` - The user requesting verification.
     * * `flow_id` - - The ID that uniquely identifies the verification flow.
     */
    func acknowledgeVerificationRequest(senderId: String, flowId: String) async throws 
    
    /**
     * Confirm that the short auth strings match on both sides.
     */
    func approveVerification() async throws 
    
    /**
     * Cancel the current verification request
     */
    func cancelVerification() async throws 
    
    /**
     * Reject the short auth string
     */
    func declineVerification() async throws 
    
    /**
     * Request verification for the current device
     */
    func requestDeviceVerification() async throws 
    
    /**
     * Request verification for the given user
     */
    func requestUserVerification(userId: String) async throws 
    
    func setDelegate(delegate: SessionVerificationControllerDelegate?) 
    
    /**
     * Transition the current verification request into a SAS verification
     * flow.
     */
    func startSasVerification() async throws 
    
}
open class SessionVerificationController: SessionVerificationControllerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sessionverificationcontroller(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationcontroller(handle, $0) }
    }

    

    
    /**
     * Accept the previously acknowledged verification request
     */
open func acceptVerificationRequest()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_accept_verification_request(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Set this particular request as the currently active one and register for
     * events pertaining it.
     * * `sender_id` - The user requesting verification.
     * * `flow_id` - - The ID that uniquely identifies the verification flow.
     */
open func acknowledgeVerificationRequest(senderId: String, flowId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_acknowledge_verification_request(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(senderId),FfiConverterString.lower(flowId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Confirm that the short auth strings match on both sides.
     */
open func approveVerification()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_approve_verification(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Cancel the current verification request
     */
open func cancelVerification()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_cancel_verification(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Reject the short auth string
     */
open func declineVerification()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_decline_verification(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Request verification for the current device
     */
open func requestDeviceVerification()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_device_verification(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Request verification for the given user
     */
open func requestUserVerification(userId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_request_user_verification(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(userId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func setDelegate(delegate: SessionVerificationControllerDelegate?)  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_set_delegate(
            self.uniffiCloneHandle(),
        FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate.lower(delegate),$0
    )
}
}
    
    /**
     * Transition the current verification request into a SAS verification
     * flow.
     */
open func startSasVerification()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_sessionverificationcontroller_start_sas_verification(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionVerificationController: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SessionVerificationController

    public static func lift(_ handle: UInt64) throws -> SessionVerificationController {
        return SessionVerificationController(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SessionVerificationController) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationController {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SessionVerificationController, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationController_lift(_ handle: UInt64) throws -> SessionVerificationController {
    return try FfiConverterTypeSessionVerificationController.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationController_lower(_ value: SessionVerificationController) -> UInt64 {
    return FfiConverterTypeSessionVerificationController.lower(value)
}






public protocol SessionVerificationEmojiProtocol: AnyObject, Sendable {
    
    func description()  -> String
    
    func symbol()  -> String
    
}
open class SessionVerificationEmoji: SessionVerificationEmojiProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sessionverificationemoji(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sessionverificationemoji(handle, $0) }
    }

    

    
open func description() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_description(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func symbol() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sessionverificationemoji_symbol(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionVerificationEmoji: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SessionVerificationEmoji

    public static func lift(_ handle: UInt64) throws -> SessionVerificationEmoji {
        return SessionVerificationEmoji(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SessionVerificationEmoji) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationEmoji {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SessionVerificationEmoji, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationEmoji_lift(_ handle: UInt64) throws -> SessionVerificationEmoji {
    return try FfiConverterTypeSessionVerificationEmoji.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationEmoji_lower(_ value: SessionVerificationEmoji) -> UInt64 {
    return FfiConverterTypeSessionVerificationEmoji.lower(value)
}






/**
 * The `SpaceRoomList`represents a paginated list of direct rooms
 * that belong to a particular space.
 *
 * It can be used to paginate through the list (and have live updates on the
 * pagination state) as well as subscribe to changes as rooms are joined or
 * left.
 *
 * The `SpaceRoomList` also automatically subscribes to client room changes
 * and updates the list accordingly as rooms are joined or left.
 */
public protocol SpaceRoomListProtocol: AnyObject, Sendable {
    
    /**
     * Ask the list to retrieve the next page if the end hasn't been reached
     * yet. Otherwise it no-ops.
     */
    func paginate() async throws 
    
    /**
     * Returns if the room list is currently paginating or not.
     */
    func paginationState()  -> SpaceRoomListPaginationState
    
    /**
     * Return the current list of rooms.
     */
    func rooms()  -> [SpaceRoom]
    
    /**
     * Returns the space of the room list if known.
     */
    func space()  -> SpaceRoom?
    
    /**
     * Subscribe to pagination updates.
     */
    func subscribeToPaginationStateUpdates(listener: SpaceRoomListPaginationStateListener)  -> TaskHandle
    
    /**
     * Subscribes to room list updates.
     */
    func subscribeToRoomUpdate(listener: SpaceRoomListEntriesListener)  -> TaskHandle
    
    /**
     * Subscribe to space updates.
     */
    func subscribeToSpaceUpdates(listener: SpaceRoomListSpaceListener)  -> TaskHandle
    
}
/**
 * The `SpaceRoomList`represents a paginated list of direct rooms
 * that belong to a particular space.
 *
 * It can be used to paginate through the list (and have live updates on the
 * pagination state) as well as subscribe to changes as rooms are joined or
 * left.
 *
 * The `SpaceRoomList` also automatically subscribes to client room changes
 * and updates the list accordingly as rooms are joined or left.
 */
open class SpaceRoomList: SpaceRoomListProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_spaceroomlist(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_spaceroomlist(handle, $0) }
    }

    

    
    /**
     * Ask the list to retrieve the next page if the end hasn't been reached
     * yet. Otherwise it no-ops.
     */
open func paginate()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_paginate(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns if the room list is currently paginating or not.
     */
open func paginationState() -> SpaceRoomListPaginationState  {
    return try!  FfiConverterTypeSpaceRoomListPaginationState_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_pagination_state(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Return the current list of rooms.
     */
open func rooms() -> [SpaceRoom]  {
    return try!  FfiConverterSequenceTypeSpaceRoom.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_rooms(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns the space of the room list if known.
     */
open func space() -> SpaceRoom?  {
    return try!  FfiConverterOptionTypeSpaceRoom.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_space(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Subscribe to pagination updates.
     */
open func subscribeToPaginationStateUpdates(listener: SpaceRoomListPaginationStateListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_pagination_state_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener_lower(listener),$0
    )
})
}
    
    /**
     * Subscribes to room list updates.
     */
open func subscribeToRoomUpdate(listener: SpaceRoomListEntriesListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_room_update(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceSpaceRoomListEntriesListener_lower(listener),$0
    )
})
}
    
    /**
     * Subscribe to space updates.
     */
open func subscribeToSpaceUpdates(listener: SpaceRoomListSpaceListener) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_spaceroomlist_subscribe_to_space_updates(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceSpaceRoomListSpaceListener_lower(listener),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpaceRoomList: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SpaceRoomList

    public static func lift(_ handle: UInt64) throws -> SpaceRoomList {
        return SpaceRoomList(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SpaceRoomList) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpaceRoomList {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SpaceRoomList, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceRoomList_lift(_ handle: UInt64) throws -> SpaceRoomList {
    return try FfiConverterTypeSpaceRoomList.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceRoomList_lower(_ value: SpaceRoomList) -> UInt64 {
    return FfiConverterTypeSpaceRoomList.lower(value)
}






/**
 * The main entry point into the Spaces facilities.
 *
 * The spaces service is responsible for retrieving one's joined rooms,
 * building a graph out of their `m.space.parent` and `m.space.child` state
 * events, and providing access to the top-level spaces and their children.
 */
public protocol SpaceServiceProtocol: AnyObject, Sendable {
    
    func addChildToSpace(childId: String, spaceId: String) async throws 
    
    /**
     * Returns a flattened list containing all the spaces where the user has
     * permission to send `m.space.child` state events.
     *
     * Note: Unlike [`Self::top_level_joined_spaces()`], this method does not
     * recompute the space graph, nor does it notify subscribers about changes.
     */
    func editableSpaces() async  -> [SpaceRoom]
    
    /**
     * Returns the corresponding `SpaceRoom` for the given room ID, or `None`
     * if it isn't known.
     */
    func getSpaceRoom(roomId: String) async throws  -> SpaceRoom?
    
    /**
     * Returns all known direct-parents of a given space room ID.
     */
    func joinedParentsOfChild(childId: String) async throws  -> [SpaceRoom]
    
    /**
     * Start a space leave process returning a [`LeaveSpaceHandle`] from which
     * rooms can be retrieved in reversed BFS order starting from the requested
     * `space_id` graph node. If the room is unknown then an error will be
     * returned.
     *
     * Once the rooms to be left are chosen the handle can be used to leave
     * them.
     */
    func leaveSpace(spaceId: String) async throws  -> LeaveSpaceHandle
    
    func removeChildFromSpace(childId: String, spaceId: String) async throws 
    
    /**
     * Returns a `SpaceRoomList` for the given space ID.
     */
    func spaceRoomList(spaceId: String) async throws  -> SpaceRoomList
    
    /**
     * Subscribes to updates on the joined spaces list. If space rooms are
     * joined or left, the stream will yield diffs that reflect the changes.
     */
    func subscribeToTopLevelJoinedSpaces(listener: SpaceServiceJoinedSpacesListener) async  -> TaskHandle
    
    /**
     * Returns a list of all the top-level joined spaces. It will eagerly
     * compute the latest version and also notify subscribers if there were
     * any changes.
     */
    func topLevelJoinedSpaces() async  -> [SpaceRoom]
    
}
/**
 * The main entry point into the Spaces facilities.
 *
 * The spaces service is responsible for retrieving one's joined rooms,
 * building a graph out of their `m.space.parent` and `m.space.child` state
 * events, and providing access to the top-level spaces and their children.
 */
open class SpaceService: SpaceServiceProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_spaceservice(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_spaceservice(handle, $0) }
    }

    

    
open func addChildToSpace(childId: String, spaceId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_add_child_to_space(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(childId),FfiConverterString.lower(spaceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns a flattened list containing all the spaces where the user has
     * permission to send `m.space.child` state events.
     *
     * Note: Unlike [`Self::top_level_joined_spaces()`], this method does not
     * recompute the space graph, nor does it notify subscribers about changes.
     */
open func editableSpaces()async  -> [SpaceRoom]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_editable_spaces(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSpaceRoom.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Returns the corresponding `SpaceRoom` for the given room ID, or `None`
     * if it isn't known.
     */
open func getSpaceRoom(roomId: String)async throws  -> SpaceRoom?  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_get_space_room(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(roomId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionTypeSpaceRoom.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns all known direct-parents of a given space room ID.
     */
open func joinedParentsOfChild(childId: String)async throws  -> [SpaceRoom]  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_joined_parents_of_child(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(childId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSpaceRoom.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Start a space leave process returning a [`LeaveSpaceHandle`] from which
     * rooms can be retrieved in reversed BFS order starting from the requested
     * `space_id` graph node. If the room is unknown then an error will be
     * returned.
     *
     * Once the rooms to be left are chosen the handle can be used to leave
     * them.
     */
open func leaveSpace(spaceId: String)async throws  -> LeaveSpaceHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_leave_space(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(spaceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeLeaveSpaceHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func removeChildFromSpace(childId: String, spaceId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_remove_child_from_space(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(childId),FfiConverterString.lower(spaceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns a `SpaceRoomList` for the given space ID.
     */
open func spaceRoomList(spaceId: String)async throws  -> SpaceRoomList  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_space_room_list(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(spaceId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeSpaceRoomList_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Subscribes to updates on the joined spaces list. If space rooms are
     * joined or left, the stream will yield diffs that reflect the changes.
     */
open func subscribeToTopLevelJoinedSpaces(listener: SpaceServiceJoinedSpacesListener)async  -> TaskHandle  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_subscribe_to_top_level_joined_spaces(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Returns a list of all the top-level joined spaces. It will eagerly
     * compute the latest version and also notify subscribers if there were
     * any changes.
     */
open func topLevelJoinedSpaces()async  -> [SpaceRoom]  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_spaceservice_top_level_joined_spaces(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterSequenceTypeSpaceRoom.lift,
            errorHandler: nil
            
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpaceService: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SpaceService

    public static func lift(_ handle: UInt64) throws -> SpaceService {
        return SpaceService(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SpaceService) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpaceService {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SpaceService, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceService_lift(_ handle: UInt64) throws -> SpaceService {
    return try FfiConverterTypeSpaceService.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceService_lower(_ value: SpaceService) -> UInt64 {
    return FfiConverterTypeSpaceService.lower(value)
}






public protocol SpanProtocol: AnyObject, Sendable {
    
    func enter() 
    
    func exit() 
    
    func isNone()  -> Bool
    
}
open class Span: SpanProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_span(self.handle, $0) }
    }
    /**
     * Create a span originating at the given callsite (file, line and column).
     *
     * The target should be something like a module path, and can be referenced
     * in the filter string given to `setup_tracing`. `level` and `target`
     * for a callsite are fixed at the first creation of a span for that
     * callsite and can not be changed afterwards, i.e. the level and
     * target passed for second and following creation of a span with the same
     * callsite will be ignored.
     *
     * This function leaks a little bit of memory for each unique (file +
     * line + level + target + name) it is called with. Please make sure that
     * the number of different combinations of those parameters this can be
     * called with is constant in the final executable.
     *
     * For a span to have an effect, you must `.enter()` it at the start of a
     * logical unit of work and `.exit()` it at the end of the same (including
     * on failure). Entering registers the span in thread-local storage, so
     * future calls to `log_event` on the same thread are able to attach the
     * events they create to the span, exiting unregisters it. For this to
     * work, exiting a span must be done on the same thread where it was
     * entered. It is possible to enter a span on multiple threads, in which
     * case it should also be exited on all of them individually; that is,
     * unless you *want* the span to be attached to all further events created
     * on that thread.
     */
public convenience init(file: String, line: UInt32?, level: LogLevel, target: String, name: String, bridgeTraceId: String?) {
    let handle =
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_new(
        FfiConverterString.lower(file),
        FfiConverterOptionUInt32.lower(line),
        FfiConverterTypeLogLevel_lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(name),
        FfiConverterOptionString.lower(bridgeTraceId),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_span(handle, $0) }
    }

    
public static func current() -> Span  {
    return try!  FfiConverterTypeSpan_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_current($0
    )
})
}
    
    /**
     * Creates a [`Span`] that acts as a bridge between the client spans and
     * the SDK ones, allowing them to be joined in Sentry. This function
     * will only return a valid span if the `sentry` feature is enabled,
     * otherwise it will return a noop span.
     */
public static func newBridgeSpan(target: String, parentTraceId: String?) -> Span  {
    return try!  FfiConverterTypeSpan_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_span_new_bridge_span(
        FfiConverterString.lower(target),
        FfiConverterOptionString.lower(parentTraceId),$0
    )
})
}
    

    
open func enter()  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_span_enter(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func exit()  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_span_exit(
            self.uniffiCloneHandle(),$0
    )
}
}
    
open func isNone() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_span_is_none(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpan: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Span

    public static func lift(_ handle: UInt64) throws -> Span {
        return Span(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Span) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Span {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Span, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpan_lift(_ handle: UInt64) throws -> Span {
    return try FfiConverterTypeSpan.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpan_lower(_ value: Span) -> UInt64 {
    return FfiConverterTypeSpan.lower(value)
}






/**
 * A builder for configuring a Sqlite session store.
 */
public protocol SqliteStoreBuilderProtocol: AnyObject, Sendable {
    
    /**
     * Set the cache size for the stores.
     *
     * Each store exposes a SQLite connection. This method controls the
     * cache size, in **bytes (!)**.
     *
     * The cache represents data SQLite holds in memory at once per open
     * database file. The default cache implementation does not allocate
     * the full amount of cache memory all at once. Cache memory is
     * allocated in smaller chunks on an as-needed basis.
     *
     * See [`SqliteStoreConfig::cache_size`] to learn more.
     */
    func cacheSize(cacheSize: UInt32?)  -> SqliteStoreBuilder
    
    /**
     * Set the size limit for the SQLite WAL files of stores.
     *
     * Each store uses the WAL journal mode. This method controls the size
     * limit of the WAL files, in **bytes (!)**.
     *
     * See [`SqliteStoreConfig::journal_size_limit`] to learn more.
     */
    func journalSizeLimit(limit: UInt32?)  -> SqliteStoreBuilder
    
    /**
     * Set the passphrase for the stores.
     */
    func passphrase(passphrase: String?)  -> SqliteStoreBuilder
    
    /**
     * Set the pool max size for the stores.
     *
     * Each store exposes an async pool of connections. This method
     * controls the size of the pool. The larger the pool is, the more
     * memory is consumed, but also the more the app is reactive because it
     * doesn't need to wait on a pool to be available to run queries.
     *
     * See [`SqliteStoreConfig::pool_max_size`] to learn more.
     */
    func poolMaxSize(poolMaxSize: UInt32?)  -> SqliteStoreBuilder
    
    /**
     * Tell the client that the system is memory constrained, like in a
     * push notification process for example.
     *
     * So far, at the time of writing (2025-04-07), it changes
     * the defaults of [`SqliteStoreConfig`]. Please check
     * [`SqliteStoreConfig::with_low_memory_config`].
     */
    func systemIsMemoryConstrained()  -> SqliteStoreBuilder
    
}
/**
 * A builder for configuring a Sqlite session store.
 */
open class SqliteStoreBuilder: SqliteStoreBuilderProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_sqlitestorebuilder(self.handle, $0) }
    }
    /**
     * Construct a [`SqliteStoreBuilder`] and set the paths that the client
     * will use to store its data and caches.
     *
     * Both paths **must** be unique per session as the SDK stores aren't
     * capable of handling multiple users, however it is valid to use the
     * same path for both stores on a single session.
     */
public convenience init(dataPath: String, cachePath: String) {
    let handle =
        try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_sqlitestorebuilder_new(
        FfiConverterString.lower(dataPath),
        FfiConverterString.lower(cachePath),$0
    )
}
    self.init(unsafeFromHandle: handle)
}

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_sqlitestorebuilder(handle, $0) }
    }

    

    
    /**
     * Set the cache size for the stores.
     *
     * Each store exposes a SQLite connection. This method controls the
     * cache size, in **bytes (!)**.
     *
     * The cache represents data SQLite holds in memory at once per open
     * database file. The default cache implementation does not allocate
     * the full amount of cache memory all at once. Cache memory is
     * allocated in smaller chunks on an as-needed basis.
     *
     * See [`SqliteStoreConfig::cache_size`] to learn more.
     */
open func cacheSize(cacheSize: UInt32?) -> SqliteStoreBuilder  {
    return try!  FfiConverterTypeSqliteStoreBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sqlitestorebuilder_cache_size(
            self.uniffiCloneHandle(),
        FfiConverterOptionUInt32.lower(cacheSize),$0
    )
})
}
    
    /**
     * Set the size limit for the SQLite WAL files of stores.
     *
     * Each store uses the WAL journal mode. This method controls the size
     * limit of the WAL files, in **bytes (!)**.
     *
     * See [`SqliteStoreConfig::journal_size_limit`] to learn more.
     */
open func journalSizeLimit(limit: UInt32?) -> SqliteStoreBuilder  {
    return try!  FfiConverterTypeSqliteStoreBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sqlitestorebuilder_journal_size_limit(
            self.uniffiCloneHandle(),
        FfiConverterOptionUInt32.lower(limit),$0
    )
})
}
    
    /**
     * Set the passphrase for the stores.
     */
open func passphrase(passphrase: String?) -> SqliteStoreBuilder  {
    return try!  FfiConverterTypeSqliteStoreBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sqlitestorebuilder_passphrase(
            self.uniffiCloneHandle(),
        FfiConverterOptionString.lower(passphrase),$0
    )
})
}
    
    /**
     * Set the pool max size for the stores.
     *
     * Each store exposes an async pool of connections. This method
     * controls the size of the pool. The larger the pool is, the more
     * memory is consumed, but also the more the app is reactive because it
     * doesn't need to wait on a pool to be available to run queries.
     *
     * See [`SqliteStoreConfig::pool_max_size`] to learn more.
     */
open func poolMaxSize(poolMaxSize: UInt32?) -> SqliteStoreBuilder  {
    return try!  FfiConverterTypeSqliteStoreBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sqlitestorebuilder_pool_max_size(
            self.uniffiCloneHandle(),
        FfiConverterOptionUInt32.lower(poolMaxSize),$0
    )
})
}
    
    /**
     * Tell the client that the system is memory constrained, like in a
     * push notification process for example.
     *
     * So far, at the time of writing (2025-04-07), it changes
     * the defaults of [`SqliteStoreConfig`]. Please check
     * [`SqliteStoreConfig::with_low_memory_config`].
     */
open func systemIsMemoryConstrained() -> SqliteStoreBuilder  {
    return try!  FfiConverterTypeSqliteStoreBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_sqlitestorebuilder_system_is_memory_constrained(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSqliteStoreBuilder: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SqliteStoreBuilder

    public static func lift(_ handle: UInt64) throws -> SqliteStoreBuilder {
        return SqliteStoreBuilder(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SqliteStoreBuilder) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SqliteStoreBuilder {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SqliteStoreBuilder, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqliteStoreBuilder_lift(_ handle: UInt64) throws -> SqliteStoreBuilder {
    return try FfiConverterTypeSqliteStoreBuilder.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSqliteStoreBuilder_lower(_ value: SqliteStoreBuilder) -> UInt64 {
    return FfiConverterTypeSqliteStoreBuilder.lower(value)
}






/**
 * An object encapsulating the SSO login flow
 */
public protocol SsoHandlerProtocol: AnyObject, Sendable {
    
    /**
     * Completes the SSO login process.
     */
    func finish(callbackUrl: String) async throws 
    
    /**
     * Returns the URL for starting SSO authentication. The URL should be
     * opened in a web view. Once the web view succeeds, call `finish` with
     * the callback URL.
     */
    func url()  -> String
    
}
/**
 * An object encapsulating the SSO login flow
 */
open class SsoHandler: SsoHandlerProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_ssohandler(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_ssohandler(handle, $0) }
    }

    

    
    /**
     * Completes the SSO login process.
     */
open func finish(callbackUrl: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_ssohandler_finish(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(callbackUrl)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeSsoError_lift
        )
}
    
    /**
     * Returns the URL for starting SSO authentication. The URL should be
     * opened in a web view. Once the web view succeeds, call `finish` with
     * the callback URL.
     */
open func url() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_ssohandler_url(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSsoHandler: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SsoHandler

    public static func lift(_ handle: UInt64) throws -> SsoHandler {
        return SsoHandler(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SsoHandler) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SsoHandler {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SsoHandler, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSsoHandler_lift(_ handle: UInt64) throws -> SsoHandler {
    return try FfiConverterTypeSsoHandler.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSsoHandler_lower(_ value: SsoHandler) -> UInt64 {
    return FfiConverterTypeSsoHandler.lower(value)
}






public protocol SyncServiceProtocol: AnyObject, Sendable {
    
    /**
     * Force expiring both sliding sync sessions.
     *
     * This ensures that the sync service is stopped before expiring both
     * sessions. It should be used sparingly, as it will cause a restart of
     * the sessions on the server as well.
     */
    func expireSessions() async 
    
    func roomListService()  -> RoomListService
    
    func start() async 
    
    func state(listener: SyncServiceStateObserver)  -> TaskHandle
    
    func stop() async 
    
}
open class SyncService: SyncServiceProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_syncservice(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_syncservice(handle, $0) }
    }

    

    
    /**
     * Force expiring both sliding sync sessions.
     *
     * This ensures that the sync service is stopped before expiring both
     * sessions. It should be used sparingly, as it will cause a restart of
     * the sessions on the server as well.
     */
open func expireSessions()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservice_expire_sessions(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func roomListService() -> RoomListService  {
    return try!  FfiConverterTypeRoomListService_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservice_room_list_service(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func start()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservice_start(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
open func state(listener: SyncServiceStateObserver) -> TaskHandle  {
    return try!  FfiConverterTypeTaskHandle_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservice_state(
            self.uniffiCloneHandle(),
        FfiConverterCallbackInterfaceSyncServiceStateObserver_lower(listener),$0
    )
})
}
    
open func stop()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservice_stop(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncService: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SyncService

    public static func lift(_ handle: UInt64) throws -> SyncService {
        return SyncService(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SyncService) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncService {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SyncService, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncService_lift(_ handle: UInt64) throws -> SyncService {
    return try FfiConverterTypeSyncService.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncService_lower(_ value: SyncService) -> UInt64 {
    return FfiConverterTypeSyncService.lower(value)
}






public protocol SyncServiceBuilderProtocol: AnyObject, Sendable {
    
    func finish() async throws  -> SyncService
    
    func withCrossProcessLock()  -> SyncServiceBuilder
    
    /**
     * Enable the "offline" mode for the [`SyncService`].
     */
    func withOfflineMode()  -> SyncServiceBuilder
    
    func withSharePos(enable: Bool)  -> SyncServiceBuilder
    
}
open class SyncServiceBuilder: SyncServiceBuilderProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_syncservicebuilder(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_syncservicebuilder(handle, $0) }
    }

    

    
open func finish()async throws  -> SyncService  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_finish(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeSyncService_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func withCrossProcessLock() -> SyncServiceBuilder  {
    return try!  FfiConverterTypeSyncServiceBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_cross_process_lock(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Enable the "offline" mode for the [`SyncService`].
     */
open func withOfflineMode() -> SyncServiceBuilder  {
    return try!  FfiConverterTypeSyncServiceBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_offline_mode(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func withSharePos(enable: Bool) -> SyncServiceBuilder  {
    return try!  FfiConverterTypeSyncServiceBuilder_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_syncservicebuilder_with_share_pos(
            self.uniffiCloneHandle(),
        FfiConverterBool.lower(enable),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncServiceBuilder: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = SyncServiceBuilder

    public static func lift(_ handle: UInt64) throws -> SyncServiceBuilder {
        return SyncServiceBuilder(unsafeFromHandle: handle)
    }

    public static func lower(_ value: SyncServiceBuilder) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncServiceBuilder {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: SyncServiceBuilder, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncServiceBuilder_lift(_ handle: UInt64) throws -> SyncServiceBuilder {
    return try FfiConverterTypeSyncServiceBuilder.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncServiceBuilder_lower(_ value: SyncServiceBuilder) -> UInt64 {
    return FfiConverterTypeSyncServiceBuilder.lower(value)
}






/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
public protocol TaskHandleProtocol: AnyObject, Sendable {
    
    func cancel() 
    
    /**
     * Check whether the handle is finished.
     */
    func isFinished()  -> Bool
    
}
/**
 * A task handle is a way to keep the handle a task running by itself in
 * detached mode.
 *
 * It's a thin wrapper around [`JoinHandle`].
 */
open class TaskHandle: TaskHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_taskhandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_taskhandle(handle, $0) }
    }

    

    
open func cancel()  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_taskhandle_cancel(
            self.uniffiCloneHandle(),$0
    )
}
}
    
    /**
     * Check whether the handle is finished.
     */
open func isFinished() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_taskhandle_is_finished(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTaskHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TaskHandle

    public static func lift(_ handle: UInt64) throws -> TaskHandle {
        return TaskHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TaskHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TaskHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TaskHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskHandle_lift(_ handle: UInt64) throws -> TaskHandle {
    return try FfiConverterTypeTaskHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTaskHandle_lower(_ value: TaskHandle) -> UInt64 {
    return FfiConverterTypeTaskHandle.lower(value)
}






public protocol ThreadSummaryProtocol: AnyObject, Sendable {
    
    func latestEvent()  -> EmbeddedEventDetails
    
    func numReplies()  -> UInt64
    
}
open class ThreadSummary: ThreadSummaryProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_threadsummary(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_threadsummary(handle, $0) }
    }

    

    
open func latestEvent() -> EmbeddedEventDetails  {
    return try!  FfiConverterTypeEmbeddedEventDetails_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_threadsummary_latest_event(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func numReplies() -> UInt64  {
    return try!  FfiConverterUInt64.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_threadsummary_num_replies(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeThreadSummary: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = ThreadSummary

    public static func lift(_ handle: UInt64) throws -> ThreadSummary {
        return ThreadSummary(unsafeFromHandle: handle)
    }

    public static func lower(_ value: ThreadSummary) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThreadSummary {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: ThreadSummary, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThreadSummary_lift(_ handle: UInt64) throws -> ThreadSummary {
    return try FfiConverterTypeThreadSummary.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThreadSummary_lower(_ value: ThreadSummary) -> UInt64 {
    return FfiConverterTypeThreadSummary.lower(value)
}






public protocol TimelineProtocol: AnyObject, Sendable {
    
    func addListener(listener: TimelineListener) async  -> TaskHandle
    
    func createMessageContent(msgType: MessageType)  -> RoomMessageEventContentWithoutRelation?
    
    func createPoll(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind) async throws 
    
    /**
     * Edits an event from the timeline.
     *
     * If it was a local event, this will *try* to edit it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending an edit request to the server.
     *
     * Returns whether the edit did happen. It can only return false for
     * local events that are being processed.
     */
    func edit(eventOrTransactionId: EventOrTransactionId, newContent: EditedContent) async throws 
    
    func endPoll(pollStartEventId: String, text: String) async throws 
    
    func fetchDetailsForEvent(eventId: String) async throws 
    
    func fetchMembers() async 
    
    /**
     * Get the current timeline item for the given event ID, if any.
     *
     * Will return a remote event, *or* a local echo that has been sent but not
     * yet replaced by a remote echo.
     *
     * It's preferable to store the timeline items in the model for your UI, if
     * possible, instead of just storing IDs and coming back to the timeline
     * object to look up items.
     */
    func getEventTimelineItemByEventId(eventId: String) async throws  -> EventTimelineItem
    
    /**
     * Returns the latest [`EventId`] in the timeline.
     */
    func latestEventId() async  -> String?
    
    /**
     * Load the reply details for the given event id.
     *
     * This will return an `InReplyToDetails` object that contains the details
     * which will either be ready or an error.
     */
    func loadReplyDetails(eventIdStr: String) async throws  -> InReplyToDetails
    
    /**
     * Mark the timeline as read by attempting to send a read receipt on the
     * latest visible event.
     *
     * The latest visible event is determined from the timeline's focus kind
     * and whether or not it hides threaded events. If no latest event can
     * be determined and the timeline is live, the room's unread marker is
     * unset instead.
     *
     * # Arguments
     *
     * * `receipt_type` - The type of receipt to send. When using
     * [`ReceiptType::FullyRead`], an unthreaded receipt will be sent. This
     * works even if the latest event belongs to a thread, as a threaded
     * reply also belongs to the unthreaded timeline. Otherwise the receipt
     * thread will be determined based on the timeline's focus kind.
     */
    func markAsRead(receiptType: ReceiptType) async throws 
    
    /**
     * Paginate backwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the start of the timeline or not.
     */
    func paginateBackwards(numEvents: UInt16) async throws  -> Bool
    
    /**
     * Paginate forwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
    func paginateForwards(numEvents: UInt16) async throws  -> Bool
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event containing the new event id.
     *
     * Returns `true` if we sent the request, `false` if the event was already
     * pinned.
     */
    func pinEvent(eventId: String) async throws  -> Bool
    
    /**
     * Redacts an event from the timeline.
     *
     * Only works for events that exist as timeline items.
     *
     * If it was a local event, this will *try* to cancel it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending a redaction request to the server.
     *
     * Will return an error if the event couldn't be redacted.
     */
    func redactEvent(eventOrTransactionId: EventOrTransactionId, reason: String?) async throws 
    
    func retryDecryption(sessionIds: [String]) 
    
    /**
     * Queues an event in the room's send queue so it's processed for
     * sending later.
     *
     * Returns an abort handle that allows to abort sending, if it hasn't
     * happened yet.
     */
    func send(msg: RoomMessageEventContentWithoutRelation) async throws  -> SendHandle
    
    func sendAudio(params: UploadParameters, audioInfo: AudioInfo) throws  -> SendAttachmentJoinHandle
    
    func sendFile(params: UploadParameters, fileInfo: FileInfo) throws  -> SendAttachmentJoinHandle
    
    func sendImage(params: UploadParameters, thumbnailSource: UploadSource?, imageInfo: ImageInfo) throws  -> SendAttachmentJoinHandle
    
    func sendLocation(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, assetType: AssetType?, repliedToEventId: String?) async throws 
    
    func sendPollResponse(pollStartEventId: String, answers: [String]) async throws 
    
    func sendReadReceipt(receiptType: ReceiptType, eventId: String) async throws 
    
    /**
     * Send a reply.
     *
     * If the replied to event has a thread relation, it is forwarded on the
     * reply so that clients that support threads can render the reply
     * inside the thread.
     */
    func sendReply(msg: RoomMessageEventContentWithoutRelation, eventId: String) async throws 
    
    func sendVideo(params: UploadParameters, thumbnailSource: UploadSource?, videoInfo: VideoInfo) throws  -> SendAttachmentJoinHandle
    
    func sendVoiceMessage(params: UploadParameters, audioInfo: AudioInfo, waveform: [Float]) throws  -> SendAttachmentJoinHandle
    
    func subscribeToBackPaginationStatus(listener: PaginationStatusListener) async throws  -> TaskHandle
    
    /**
     * Toggle a reaction on an event.
     *
     * Adds or redacts a reaction based on the state of the reaction at the
     * time it is called.
     *
     * This method works both on local echoes and remote items.
     *
     * When redacting a previous reaction, the redaction reason is not set.
     *
     * Ensures that only one reaction is sent at a time to avoid race
     * conditions and spamming the homeserver with requests.
     *
     * Returns `true` if the reaction was added, `false` if it was removed.
     */
    func toggleReaction(itemId: EventOrTransactionId, key: String) async throws  -> Bool
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event without the event id we want to remove.
     *
     * Returns `true` if we sent the request, `false` if the event wasn't
     * pinned
     */
    func unpinEvent(eventId: String) async throws  -> Bool
    
    func sendGallery(params: GalleryUploadParameters, itemInfos: [GalleryItemInfo]) throws  -> SendGalleryJoinHandle
    
}
open class Timeline: TimelineProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timeline(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timeline(handle, $0) }
    }

    

    
open func addListener(listener: TimelineListener)async  -> TaskHandle  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_add_listener(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfaceTimelineListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: nil
            
        )
}
    
open func createMessageContent(msgType: MessageType) -> RoomMessageEventContentWithoutRelation?  {
    return try!  FfiConverterOptionTypeRoomMessageEventContentWithoutRelation.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_create_message_content(
            self.uniffiCloneHandle(),
        FfiConverterTypeMessageType_lower(msgType),$0
    )
})
}
    
open func createPoll(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_create_poll(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(question),FfiConverterSequenceString.lower(answers),FfiConverterUInt8.lower(maxSelections),FfiConverterTypePollKind_lower(pollKind)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Edits an event from the timeline.
     *
     * If it was a local event, this will *try* to edit it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending an edit request to the server.
     *
     * Returns whether the edit did happen. It can only return false for
     * local events that are being processed.
     */
open func edit(eventOrTransactionId: EventOrTransactionId, newContent: EditedContent)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_edit(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeEventOrTransactionId_lower(eventOrTransactionId),FfiConverterTypeEditedContent_lower(newContent)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func endPoll(pollStartEventId: String, text: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_end_poll(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(pollStartEventId),FfiConverterString.lower(text)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func fetchDetailsForEvent(eventId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_details_for_event(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func fetchMembers()async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_fetch_members(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    
    /**
     * Get the current timeline item for the given event ID, if any.
     *
     * Will return a remote event, *or* a local echo that has been sent but not
     * yet replaced by a remote echo.
     *
     * It's preferable to store the timeline items in the model for your UI, if
     * possible, instead of just storing IDs and coming back to the timeline
     * object to look up items.
     */
open func getEventTimelineItemByEventId(eventId: String)async throws  -> EventTimelineItem  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_get_event_timeline_item_by_event_id(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterTypeEventTimelineItem_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Returns the latest [`EventId`] in the timeline.
     */
open func latestEventId()async  -> String?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_latest_event_id(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     * Load the reply details for the given event id.
     *
     * This will return an `InReplyToDetails` object that contains the details
     * which will either be ready or an error.
     */
open func loadReplyDetails(eventIdStr: String)async throws  -> InReplyToDetails  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_load_reply_details(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventIdStr)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeInReplyToDetails_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Mark the timeline as read by attempting to send a read receipt on the
     * latest visible event.
     *
     * The latest visible event is determined from the timeline's focus kind
     * and whether or not it hides threaded events. If no latest event can
     * be determined and the timeline is live, the room's unread marker is
     * unset instead.
     *
     * # Arguments
     *
     * * `receipt_type` - The type of receipt to send. When using
     * [`ReceiptType::FullyRead`], an unthreaded receipt will be sent. This
     * works even if the latest event belongs to a thread, as a threaded
     * reply also belongs to the unthreaded timeline. Otherwise the receipt
     * thread will be determined based on the timeline's focus kind.
     */
open func markAsRead(receiptType: ReceiptType)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_mark_as_read(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeReceiptType_lower(receiptType)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Paginate backwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the start of the timeline or not.
     */
open func paginateBackwards(numEvents: UInt16)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_backwards(
                    self.uniffiCloneHandle(),
                    FfiConverterUInt16.lower(numEvents)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Paginate forwards, whether we are in focused mode or in live mode.
     *
     * Returns whether we hit the end of the timeline or not.
     */
open func paginateForwards(numEvents: UInt16)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_paginate_forwards(
                    self.uniffiCloneHandle(),
                    FfiConverterUInt16.lower(numEvents)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event containing the new event id.
     *
     * Returns `true` if we sent the request, `false` if the event was already
     * pinned.
     */
open func pinEvent(eventId: String)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_pin_event(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Redacts an event from the timeline.
     *
     * Only works for events that exist as timeline items.
     *
     * If it was a local event, this will *try* to cancel it, if it was not
     * being sent already. If the event was a remote event, then it will be
     * redacted by sending a redaction request to the server.
     *
     * Will return an error if the event couldn't be redacted.
     */
open func redactEvent(eventOrTransactionId: EventOrTransactionId, reason: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_redact_event(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeEventOrTransactionId_lower(eventOrTransactionId),FfiConverterOptionString.lower(reason)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func retryDecryption(sessionIds: [String])  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timeline_retry_decryption(
            self.uniffiCloneHandle(),
        FfiConverterSequenceString.lower(sessionIds),$0
    )
}
}
    
    /**
     * Queues an event in the room's send queue so it's processed for
     * sending later.
     *
     * Returns an abort handle that allows to abort sending, if it hasn't
     * happened yet.
     */
open func send(msg: RoomMessageEventContentWithoutRelation)async throws  -> SendHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeRoomMessageEventContentWithoutRelation_lower(msg)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeSendHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendAudio(params: UploadParameters, audioInfo: AudioInfo)throws  -> SendAttachmentJoinHandle  {
    return try  FfiConverterTypeSendAttachmentJoinHandle_lift(try rustCallWithError(FfiConverterTypeRoomError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_audio(
            self.uniffiCloneHandle(),
        FfiConverterTypeUploadParameters_lower(params),
        FfiConverterTypeAudioInfo_lower(audioInfo),$0
    )
})
}
    
open func sendFile(params: UploadParameters, fileInfo: FileInfo)throws  -> SendAttachmentJoinHandle  {
    return try  FfiConverterTypeSendAttachmentJoinHandle_lift(try rustCallWithError(FfiConverterTypeRoomError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_file(
            self.uniffiCloneHandle(),
        FfiConverterTypeUploadParameters_lower(params),
        FfiConverterTypeFileInfo_lower(fileInfo),$0
    )
})
}
    
open func sendImage(params: UploadParameters, thumbnailSource: UploadSource?, imageInfo: ImageInfo)throws  -> SendAttachmentJoinHandle  {
    return try  FfiConverterTypeSendAttachmentJoinHandle_lift(try rustCallWithError(FfiConverterTypeRoomError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_image(
            self.uniffiCloneHandle(),
        FfiConverterTypeUploadParameters_lower(params),
        FfiConverterOptionTypeUploadSource.lower(thumbnailSource),
        FfiConverterTypeImageInfo_lower(imageInfo),$0
    )
})
}
    
open func sendLocation(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, assetType: AssetType?, repliedToEventId: String?)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_location(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(body),FfiConverterString.lower(geoUri),FfiConverterOptionString.lower(description),FfiConverterOptionUInt8.lower(zoomLevel),FfiConverterOptionTypeAssetType.lower(assetType),FfiConverterOptionString.lower(repliedToEventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendPollResponse(pollStartEventId: String, answers: [String])async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_poll_response(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(pollStartEventId),FfiConverterSequenceString.lower(answers)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendReadReceipt(receiptType: ReceiptType, eventId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_read_receipt(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeReceiptType_lower(receiptType),FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Send a reply.
     *
     * If the replied to event has a thread relation, it is forwarded on the
     * reply so that clients that support threads can render the reply
     * inside the thread.
     */
open func sendReply(msg: RoomMessageEventContentWithoutRelation, eventId: String)async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_send_reply(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeRoomMessageEventContentWithoutRelation_lower(msg),FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendVideo(params: UploadParameters, thumbnailSource: UploadSource?, videoInfo: VideoInfo)throws  -> SendAttachmentJoinHandle  {
    return try  FfiConverterTypeSendAttachmentJoinHandle_lift(try rustCallWithError(FfiConverterTypeRoomError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_video(
            self.uniffiCloneHandle(),
        FfiConverterTypeUploadParameters_lower(params),
        FfiConverterOptionTypeUploadSource.lower(thumbnailSource),
        FfiConverterTypeVideoInfo_lower(videoInfo),$0
    )
})
}
    
open func sendVoiceMessage(params: UploadParameters, audioInfo: AudioInfo, waveform: [Float])throws  -> SendAttachmentJoinHandle  {
    return try  FfiConverterTypeSendAttachmentJoinHandle_lift(try rustCallWithError(FfiConverterTypeRoomError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_voice_message(
            self.uniffiCloneHandle(),
        FfiConverterTypeUploadParameters_lower(params),
        FfiConverterTypeAudioInfo_lower(audioInfo),
        FfiConverterSequenceFloat.lower(waveform),$0
    )
})
}
    
open func subscribeToBackPaginationStatus(listener: PaginationStatusListener)async throws  -> TaskHandle  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_subscribe_to_back_pagination_status(
                    self.uniffiCloneHandle(),
                    FfiConverterCallbackInterfacePaginationStatusListener_lower(listener)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_u64,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_u64,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_u64,
            liftFunc: FfiConverterTypeTaskHandle_lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Toggle a reaction on an event.
     *
     * Adds or redacts a reaction based on the state of the reaction at the
     * time it is called.
     *
     * This method works both on local echoes and remote items.
     *
     * When redacting a previous reaction, the redaction reason is not set.
     *
     * Ensures that only one reaction is sent at a time to avoid race
     * conditions and spamming the homeserver with requests.
     *
     * Returns `true` if the reaction was added, `false` if it was removed.
     */
open func toggleReaction(itemId: EventOrTransactionId, key: String)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_toggle_reaction(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeEventOrTransactionId_lower(itemId),FfiConverterString.lower(key)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * Adds a new pinned event by sending an updated `m.room.pinned_events`
     * event without the event id we want to remove.
     *
     * Returns `true` if we sent the request, `false` if the event wasn't
     * pinned
     */
open func unpinEvent(eventId: String)async throws  -> Bool  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_timeline_unpin_event(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(eventId)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
open func sendGallery(params: GalleryUploadParameters, itemInfos: [GalleryItemInfo])throws  -> SendGalleryJoinHandle  {
    return try  FfiConverterTypeSendGalleryJoinHandle_lift(try rustCallWithError(FfiConverterTypeRoomError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_timeline_send_gallery(
            self.uniffiCloneHandle(),
        FfiConverterTypeGalleryUploadParameters_lower(params),
        FfiConverterSequenceTypeGalleryItemInfo.lower(itemInfos),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimeline: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = Timeline

    public static func lift(_ handle: UInt64) throws -> Timeline {
        return Timeline(unsafeFromHandle: handle)
    }

    public static func lower(_ value: Timeline) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timeline {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: Timeline, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimeline_lift(_ handle: UInt64) throws -> Timeline {
    return try FfiConverterTypeTimeline.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimeline_lower(_ value: Timeline) -> UInt64 {
    return FfiConverterTypeTimeline.lower(value)
}






public protocol TimelineEventProtocol: AnyObject, Sendable {
    
    func content() throws  -> TimelineEventContent
    
    func eventId()  -> String
    
    func senderId()  -> String
    
    /**
     * Returns the thread root event id for the event, if it's part of a
     * thread.
     */
    func threadRootEventId()  -> String?
    
    func timestamp()  -> Timestamp
    
}
open class TimelineEvent: TimelineEventProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timelineevent(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineevent(handle, $0) }
    }

    

    
open func content()throws  -> TimelineEventContent  {
    return try  FfiConverterTypeTimelineEventContent_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_content(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func eventId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_event_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func senderId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_sender_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Returns the thread root event id for the event, if it's part of a
     * thread.
     */
open func threadRootEventId() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_thread_root_event_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func timestamp() -> Timestamp  {
    return try!  FfiConverterTypeTimestamp_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineevent_timestamp(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineEvent: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TimelineEvent

    public static func lift(_ handle: UInt64) throws -> TimelineEvent {
        return TimelineEvent(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TimelineEvent) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEvent {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TimelineEvent, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEvent_lift(_ handle: UInt64) throws -> TimelineEvent {
    return try FfiConverterTypeTimelineEvent.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEvent_lower(_ value: TimelineEvent) -> UInt64 {
    return FfiConverterTypeTimelineEvent.lower(value)
}






public protocol TimelineEventTypeFilterProtocol: AnyObject, Sendable {
    
}
open class TimelineEventTypeFilter: TimelineEventTypeFilterProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timelineeventtypefilter(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineeventtypefilter(handle, $0) }
    }

    
public static func exclude(eventTypes: [FilterTimelineEventType]) -> TimelineEventTypeFilter  {
    return try!  FfiConverterTypeTimelineEventTypeFilter_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_exclude(
        FfiConverterSequenceTypeFilterTimelineEventType.lower(eventTypes),$0
    )
})
}
    
public static func include(eventTypes: [FilterTimelineEventType]) -> TimelineEventTypeFilter  {
    return try!  FfiConverterTypeTimelineEventTypeFilter_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_constructor_timelineeventtypefilter_include(
        FfiConverterSequenceTypeFilterTimelineEventType.lower(eventTypes),$0
    )
})
}
    

    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineEventTypeFilter: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TimelineEventTypeFilter

    public static func lift(_ handle: UInt64) throws -> TimelineEventTypeFilter {
        return TimelineEventTypeFilter(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TimelineEventTypeFilter) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEventTypeFilter {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TimelineEventTypeFilter, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEventTypeFilter_lift(_ handle: UInt64) throws -> TimelineEventTypeFilter {
    return try FfiConverterTypeTimelineEventTypeFilter.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEventTypeFilter_lower(_ value: TimelineEventTypeFilter) -> UInt64 {
    return FfiConverterTypeTimelineEventTypeFilter.lower(value)
}






public protocol TimelineItemProtocol: AnyObject, Sendable {
    
    func asEvent()  -> EventTimelineItem?
    
    func asVirtual()  -> VirtualTimelineItem?
    
    func fmtDebug()  -> String
    
    /**
     * An opaque unique identifier for this timeline item.
     */
    func uniqueId()  -> TimelineUniqueId
    
}
open class TimelineItem: TimelineItemProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_timelineitem(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_timelineitem(handle, $0) }
    }

    

    
open func asEvent() -> EventTimelineItem?  {
    return try!  FfiConverterOptionTypeEventTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_event(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func asVirtual() -> VirtualTimelineItem?  {
    return try!  FfiConverterOptionTypeVirtualTimelineItem.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_as_virtual(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func fmtDebug() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_fmt_debug(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * An opaque unique identifier for this timeline item.
     */
open func uniqueId() -> TimelineUniqueId  {
    return try!  FfiConverterTypeTimelineUniqueId_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_timelineitem_unique_id(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineItem: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = TimelineItem

    public static func lift(_ handle: UInt64) throws -> TimelineItem {
        return TimelineItem(unsafeFromHandle: handle)
    }

    public static func lower(_ value: TimelineItem) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItem {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: TimelineItem, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineItem_lift(_ handle: UInt64) throws -> TimelineItem {
    return try FfiConverterTypeTimelineItem.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineItem_lower(_ value: TimelineItem) -> UInt64 {
    return FfiConverterTypeTimelineItem.lower(value)
}






public protocol UnreadNotificationsCountProtocol: AnyObject, Sendable {
    
    func hasNotifications()  -> Bool
    
    func highlightCount()  -> UInt32
    
    func notificationCount()  -> UInt32
    
}
open class UnreadNotificationsCount: UnreadNotificationsCountProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_unreadnotificationscount(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_unreadnotificationscount(handle, $0) }
    }

    

    
open func hasNotifications() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_has_notifications(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func highlightCount() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_highlight_count(
            self.uniffiCloneHandle(),$0
    )
})
}
    
open func notificationCount() -> UInt32  {
    return try!  FfiConverterUInt32.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_unreadnotificationscount_notification_count(
            self.uniffiCloneHandle(),$0
    )
})
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnreadNotificationsCount: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UnreadNotificationsCount

    public static func lift(_ handle: UInt64) throws -> UnreadNotificationsCount {
        return UnreadNotificationsCount(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UnreadNotificationsCount) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnreadNotificationsCount {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UnreadNotificationsCount, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnreadNotificationsCount_lift(_ handle: UInt64) throws -> UnreadNotificationsCount {
    return try FfiConverterTypeUnreadNotificationsCount.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnreadNotificationsCount_lower(_ value: UnreadNotificationsCount) -> UInt64 {
    return FfiConverterTypeUnreadNotificationsCount.lower(value)
}






/**
 * The E2EE identity of a user.
 */
public protocol UserIdentityProtocol: AnyObject, Sendable {
    
    /**
     * Was this identity previously verified, and is no longer?
     */
    func hasVerificationViolation()  -> Bool
    
    /**
     * Is the user identity considered to be verified.
     *
     * If the identity belongs to another user, our own user identity needs to
     * be verified as well for the identity to be considered to be verified.
     */
    func isVerified()  -> Bool
    
    /**
     * Get the public part of the Master key of this user identity.
     *
     * The public part of the Master key is usually used to uniquely identify
     * the identity.
     *
     * Returns None if the master key does not actually contain any keys.
     */
    func masterKey()  -> String?
    
    /**
     * Remember this identity, ensuring it does not result in a pin violation.
     *
     * When we first see a user, we assume their cryptographic identity has not
     * been tampered with by the homeserver or another entity with
     * man-in-the-middle capabilities. We remember this identity and call this
     * action "pinning".
     *
     * If the identity presented for the user changes later on, the newly
     * presented identity is considered to be in "pin violation". This
     * method explicitly accepts the new identity, allowing it to replace
     * the previously pinned one and bringing it out of pin violation.
     *
     * UIs should display a warning to the user when encountering an identity
     * which is not verified and is in pin violation.
     */
    func pin() async throws 
    
    /**
     * True if we verified this identity at some point in the past.
     *
     * To reset this latch back to `false`, one must call
     * [`UserIdentity::withdraw_verification()`].
     */
    func wasPreviouslyVerified()  -> Bool
    
    /**
     * Remove the requirement for this identity to be verified.
     *
     * If an identity was previously verified and is not anymore it will be
     * reported to the user. In order to remove this notice users have to
     * verify again or to withdraw the verification requirement.
     */
    func withdrawVerification() async throws 
    
}
/**
 * The E2EE identity of a user.
 */
open class UserIdentity: UserIdentityProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_useridentity(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_useridentity(handle, $0) }
    }

    

    
    /**
     * Was this identity previously verified, and is no longer?
     */
open func hasVerificationViolation() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_useridentity_has_verification_violation(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Is the user identity considered to be verified.
     *
     * If the identity belongs to another user, our own user identity needs to
     * be verified as well for the identity to be considered to be verified.
     */
open func isVerified() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_useridentity_is_verified(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Get the public part of the Master key of this user identity.
     *
     * The public part of the Master key is usually used to uniquely identify
     * the identity.
     *
     * Returns None if the master key does not actually contain any keys.
     */
open func masterKey() -> String?  {
    return try!  FfiConverterOptionString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_useridentity_master_key(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Remember this identity, ensuring it does not result in a pin violation.
     *
     * When we first see a user, we assume their cryptographic identity has not
     * been tampered with by the homeserver or another entity with
     * man-in-the-middle capabilities. We remember this identity and call this
     * action "pinning".
     *
     * If the identity presented for the user changes later on, the newly
     * presented identity is considered to be in "pin violation". This
     * method explicitly accepts the new identity, allowing it to replace
     * the previously pinned one and bringing it out of pin violation.
     *
     * UIs should display a warning to the user when encountering an identity
     * which is not verified and is in pin violation.
     */
open func pin()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_useridentity_pin(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    
    /**
     * True if we verified this identity at some point in the past.
     *
     * To reset this latch back to `false`, one must call
     * [`UserIdentity::withdraw_verification()`].
     */
open func wasPreviouslyVerified() -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_method_useridentity_was_previously_verified(
            self.uniffiCloneHandle(),$0
    )
})
}
    
    /**
     * Remove the requirement for this identity to be verified.
     *
     * If an identity was previously verified and is not anymore it will be
     * reported to the user. In order to remove this notice users have to
     * verify again or to withdraw the verification requirement.
     */
open func withdrawVerification()async throws   {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_useridentity_withdraw_verification(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: FfiConverterTypeClientError_lift
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserIdentity: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = UserIdentity

    public static func lift(_ handle: UInt64) throws -> UserIdentity {
        return UserIdentity(unsafeFromHandle: handle)
    }

    public static func lower(_ value: UserIdentity) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserIdentity {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: UserIdentity, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserIdentity_lift(_ handle: UInt64) throws -> UserIdentity {
    return try FfiConverterTypeUserIdentity.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserIdentity_lower(_ value: UserIdentity) -> UInt64 {
    return FfiConverterTypeUserIdentity.lower(value)
}






/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
public protocol WidgetDriverProtocol: AnyObject, Sendable {
    
    func run(room: Room, capabilitiesProvider: WidgetCapabilitiesProvider) async 
    
}
/**
 * An object that handles all interactions of a widget living inside a webview
 * or IFrame with the Matrix world.
 */
open class WidgetDriver: WidgetDriverProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_widgetdriver(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_widgetdriver(handle, $0) }
    }

    

    
open func run(room: Room, capabilitiesProvider: WidgetCapabilitiesProvider)async   {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_widgetdriver_run(
                    self.uniffiCloneHandle(),
                    FfiConverterTypeRoom_lower(room),FfiConverterCallbackInterfaceWidgetCapabilitiesProvider_lower(capabilitiesProvider)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_void,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_void,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_void,
            liftFunc: { $0 },
            errorHandler: nil
            
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWidgetDriver: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = WidgetDriver

    public static func lift(_ handle: UInt64) throws -> WidgetDriver {
        return WidgetDriver(unsafeFromHandle: handle)
    }

    public static func lower(_ value: WidgetDriver) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetDriver {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: WidgetDriver, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetDriver_lift(_ handle: UInt64) throws -> WidgetDriver {
    return try FfiConverterTypeWidgetDriver.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetDriver_lower(_ value: WidgetDriver) -> UInt64 {
    return FfiConverterTypeWidgetDriver.lower(value)
}






/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
public protocol WidgetDriverHandleProtocol: AnyObject, Sendable {
    
    /**
     * Receive a message from the widget driver.
     *
     * The message must be passed on to the widget.
     *
     * Returns `None` if the widget driver is no longer running.
     */
    func recv() async  -> String?
    
    /**
     *
     * Returns `false` if the widget driver is no longer running.
     */
    func send(msg: String) async  -> Bool
    
}
/**
 * A handle that encapsulates the communication between a widget driver and the
 * corresponding widget (inside a webview or IFrame).
 */
open class WidgetDriverHandle: WidgetDriverHandleProtocol, @unchecked Sendable {
    fileprivate let handle: UInt64

    /// Used to instantiate a [FFIObject] without an actual handle, for fakes in tests, mostly.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public struct NoHandle {
        public init() {}
    }

    // TODO: We'd like this to be `private` but for Swifty reasons,
    // we can't implement `FfiConverter` without making this `required` and we can't
    // make it `required` without making it `public`.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    required public init(unsafeFromHandle handle: UInt64) {
        self.handle = handle
    }

    // This constructor can be used to instantiate a fake object.
    // - Parameter noHandle: Placeholder value so we can have a constructor separate from the default empty one that may be implemented for classes extending [FFIObject].
    //
    // - Warning:
    //     Any object instantiated with this constructor cannot be passed to an actual Rust-backed object. Since there isn't a backing handle the FFI lower functions will crash.
#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public init(noHandle: NoHandle) {
        self.handle = 0
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public func uniffiCloneHandle() -> UInt64 {
        return try! rustCall { uniffi_matrix_sdk_ffi_fn_clone_widgetdriverhandle(self.handle, $0) }
    }
    // No primary constructor declared for this class.

    deinit {
        if handle == 0 {
            // Mock objects have handle=0 don't try to free them
            return
        }

        try! rustCall { uniffi_matrix_sdk_ffi_fn_free_widgetdriverhandle(handle, $0) }
    }

    

    
    /**
     * Receive a message from the widget driver.
     *
     * The message must be passed on to the widget.
     *
     * Returns `None` if the widget driver is no longer running.
     */
open func recv()async  -> String?  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_recv(
                    self.uniffiCloneHandle()
                    
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterOptionString.lift,
            errorHandler: nil
            
        )
}
    
    /**
     *
     * Returns `false` if the widget driver is no longer running.
     */
open func send(msg: String)async  -> Bool  {
    return
        try!  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_method_widgetdriverhandle_send(
                    self.uniffiCloneHandle(),
                    FfiConverterString.lower(msg)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_i8,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_i8,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_i8,
            liftFunc: FfiConverterBool.lift,
            errorHandler: nil
            
        )
}
    

    
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWidgetDriverHandle: FfiConverter {
    typealias FfiType = UInt64
    typealias SwiftType = WidgetDriverHandle

    public static func lift(_ handle: UInt64) throws -> WidgetDriverHandle {
        return WidgetDriverHandle(unsafeFromHandle: handle)
    }

    public static func lower(_ value: WidgetDriverHandle) -> UInt64 {
        return value.uniffiCloneHandle()
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetDriverHandle {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

    public static func write(_ value: WidgetDriverHandle, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetDriverHandle_lift(_ handle: UInt64) throws -> WidgetDriverHandle {
    return try FfiConverterTypeWidgetDriverHandle.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetDriverHandle_lower(_ value: WidgetDriverHandle) -> UInt64 {
    return FfiConverterTypeWidgetDriverHandle.lower(value)
}




/**
 * Progress of an operation in abstract units.
 *
 * Contrary to [`TransmissionProgress`], this allows tracking the progress
 * of sending or receiving a payload in estimated pseudo units representing a
 * percentage. This is helpful in cases where the exact progress in bytes isn't
 * known, for instance, because encryption (which changes the size) happens on
 * the fly.
 */
public struct AbstractProgress: Equatable, Hashable {
    /**
     * How many units were already transferred.
     */
    public var current: UInt64
    /**
     * How many units there are in total.
     */
    public var total: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * How many units were already transferred.
         */current: UInt64, 
        /**
         * How many units there are in total.
         */total: UInt64) {
        self.current = current
        self.total = total
    }

    

    
}

#if compiler(>=6)
extension AbstractProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAbstractProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AbstractProgress {
        return
            try AbstractProgress(
                current: FfiConverterUInt64.read(from: &buf), 
                total: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: AbstractProgress, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.current, into: &buf)
        FfiConverterUInt64.write(value.total, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAbstractProgress_lift(_ buf: RustBuffer) throws -> AbstractProgress {
    return try FfiConverterTypeAbstractProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAbstractProgress_lower(_ value: AbstractProgress) -> RustBuffer {
    return FfiConverterTypeAbstractProgress.lower(value)
}


public struct AudioInfo: Equatable, Hashable {
    public var duration: TimeInterval?
    public var size: UInt64?
    public var mimetype: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval?, size: UInt64?, mimetype: String?) {
        self.duration = duration
        self.size = size
        self.mimetype = mimetype
    }

    

    
}

#if compiler(>=6)
extension AudioInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioInfo {
        return
            try AudioInfo(
                duration: FfiConverterOptionDuration.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: AudioInfo, into buf: inout [UInt8]) {
        FfiConverterOptionDuration.write(value.duration, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioInfo_lift(_ buf: RustBuffer) throws -> AudioInfo {
    return try FfiConverterTypeAudioInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioInfo_lower(_ value: AudioInfo) -> RustBuffer {
    return FfiConverterTypeAudioInfo.lower(value)
}


public struct AudioMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: AudioInfo?
    public var audio: UnstableAudioDetailsContent?
    public var voice: UnstableVoiceContent?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: AudioInfo?, audio: UnstableAudioDetailsContent?, voice: UnstableVoiceContent?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
        self.audio = audio
        self.voice = voice
    }

    

    
}

#if compiler(>=6)
extension AudioMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAudioMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AudioMessageContent {
        return
            try AudioMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeAudioInfo.read(from: &buf), 
                audio: FfiConverterOptionTypeUnstableAudioDetailsContent.read(from: &buf), 
                voice: FfiConverterOptionTypeUnstableVoiceContent.read(from: &buf)
        )
    }

    public static func write(_ value: AudioMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeAudioInfo.write(value.info, into: &buf)
        FfiConverterOptionTypeUnstableAudioDetailsContent.write(value.audio, into: &buf)
        FfiConverterOptionTypeUnstableVoiceContent.write(value.voice, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioMessageContent_lift(_ buf: RustBuffer) throws -> AudioMessageContent {
    return try FfiConverterTypeAudioMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAudioMessageContent_lower(_ value: AudioMessageContent) -> RustBuffer {
    return FfiConverterTypeAudioMessageContent.lower(value)
}


public struct AuthDataPasswordDetails: Equatable, Hashable {
    /**
     * One of the user's identifiers.
     */
    public var identifier: String
    /**
     * The plaintext password.
     */
    public var password: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * One of the user's identifiers.
         */identifier: String, 
        /**
         * The plaintext password.
         */password: String) {
        self.identifier = identifier
        self.password = password
    }

    

    
}

#if compiler(>=6)
extension AuthDataPasswordDetails: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthDataPasswordDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthDataPasswordDetails {
        return
            try AuthDataPasswordDetails(
                identifier: FfiConverterString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthDataPasswordDetails, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identifier, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthDataPasswordDetails_lift(_ buf: RustBuffer) throws -> AuthDataPasswordDetails {
    return try FfiConverterTypeAuthDataPasswordDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthDataPasswordDetails_lower(_ value: AuthDataPasswordDetails) -> RustBuffer {
    return FfiConverterTypeAuthDataPasswordDetails.lower(value)
}


public struct ClientProperties: Equatable, Hashable {
    /**
     * The client_id provides the widget with the option to behave differently
     * for different clients. e.g org.example.ios.
     */
    public var clientId: String
    /**
     * The language tag the client is set to e.g. en-us. (Undefined and invalid
     * becomes: `en-US`)
     */
    public var languageTag: String?
    /**
     * A string describing the theme (dark, light) or org.example.dark.
     * (default: `light`)
     */
    public var theme: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The client_id provides the widget with the option to behave differently
         * for different clients. e.g org.example.ios.
         */clientId: String, 
        /**
         * The language tag the client is set to e.g. en-us. (Undefined and invalid
         * becomes: `en-US`)
         */languageTag: String?, 
        /**
         * A string describing the theme (dark, light) or org.example.dark.
         * (default: `light`)
         */theme: String?) {
        self.clientId = clientId
        self.languageTag = languageTag
        self.theme = theme
    }

    

    
}

#if compiler(>=6)
extension ClientProperties: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientProperties: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientProperties {
        return
            try ClientProperties(
                clientId: FfiConverterString.read(from: &buf), 
                languageTag: FfiConverterOptionString.read(from: &buf), 
                theme: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: ClientProperties, into buf: inout [UInt8]) {
        FfiConverterString.write(value.clientId, into: &buf)
        FfiConverterOptionString.write(value.languageTag, into: &buf)
        FfiConverterOptionString.write(value.theme, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientProperties_lift(_ buf: RustBuffer) throws -> ClientProperties {
    return try FfiConverterTypeClientProperties.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientProperties_lower(_ value: ClientProperties) -> RustBuffer {
    return FfiConverterTypeClientProperties.lower(value)
}


/**
 * Current draft of the composer for the room.
 */
public struct ComposerDraft {
    /**
     * The draft content in plain text.
     */
    public var plainText: String
    /**
     * If the message is formatted in HTML, the HTML representation of the
     * message.
     */
    public var htmlText: String?
    /**
     * The type of draft.
     */
    public var draftType: ComposerDraftType
    /**
     * Attachments associated with this draft.
     */
    public var attachments: [DraftAttachment]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The draft content in plain text.
         */plainText: String, 
        /**
         * If the message is formatted in HTML, the HTML representation of the
         * message.
         */htmlText: String?, 
        /**
         * The type of draft.
         */draftType: ComposerDraftType, 
        /**
         * Attachments associated with this draft.
         */attachments: [DraftAttachment]) {
        self.plainText = plainText
        self.htmlText = htmlText
        self.draftType = draftType
        self.attachments = attachments
    }

    

    
}

#if compiler(>=6)
extension ComposerDraft: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeComposerDraft: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComposerDraft {
        return
            try ComposerDraft(
                plainText: FfiConverterString.read(from: &buf), 
                htmlText: FfiConverterOptionString.read(from: &buf), 
                draftType: FfiConverterTypeComposerDraftType.read(from: &buf), 
                attachments: FfiConverterSequenceTypeDraftAttachment.read(from: &buf)
        )
    }

    public static func write(_ value: ComposerDraft, into buf: inout [UInt8]) {
        FfiConverterString.write(value.plainText, into: &buf)
        FfiConverterOptionString.write(value.htmlText, into: &buf)
        FfiConverterTypeComposerDraftType.write(value.draftType, into: &buf)
        FfiConverterSequenceTypeDraftAttachment.write(value.attachments, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComposerDraft_lift(_ buf: RustBuffer) throws -> ComposerDraft {
    return try FfiConverterTypeComposerDraft.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComposerDraft_lower(_ value: ComposerDraft) -> RustBuffer {
    return FfiConverterTypeComposerDraft.lower(value)
}


/**
 * Like [`SimplePushRule`], but with an additional `conditions` field.
 */
public struct ConditionalPushRule: Equatable, Hashable {
    /**
     * Actions to determine if and how a notification is delivered for events
     * matching this rule.
     */
    public var actions: [Action]
    /**
     * Whether this is a default rule, or has been set explicitly.
     */
    public var `default`: Bool
    /**
     * Whether the push rule is enabled or not.
     */
    public var enabled: Bool
    /**
     * The ID of this rule.
     */
    public var ruleId: String
    /**
     * The conditions that must hold true for an event in order for a rule to
     * be applied to an event.
     *
     * A rule with no conditions always matches.
     */
    public var conditions: [PushCondition]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Actions to determine if and how a notification is delivered for events
         * matching this rule.
         */actions: [Action], 
        /**
         * Whether this is a default rule, or has been set explicitly.
         */`default`: Bool, 
        /**
         * Whether the push rule is enabled or not.
         */enabled: Bool, 
        /**
         * The ID of this rule.
         */ruleId: String, 
        /**
         * The conditions that must hold true for an event in order for a rule to
         * be applied to an event.
         *
         * A rule with no conditions always matches.
         */conditions: [PushCondition]) {
        self.actions = actions
        self.`default` = `default`
        self.enabled = enabled
        self.ruleId = ruleId
        self.conditions = conditions
    }

    

    
}

#if compiler(>=6)
extension ConditionalPushRule: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeConditionalPushRule: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ConditionalPushRule {
        return
            try ConditionalPushRule(
                actions: FfiConverterSequenceTypeAction.read(from: &buf), 
                default: FfiConverterBool.read(from: &buf), 
                enabled: FfiConverterBool.read(from: &buf), 
                ruleId: FfiConverterString.read(from: &buf), 
                conditions: FfiConverterSequenceTypePushCondition.read(from: &buf)
        )
    }

    public static func write(_ value: ConditionalPushRule, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAction.write(value.actions, into: &buf)
        FfiConverterBool.write(value.`default`, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterString.write(value.ruleId, into: &buf)
        FfiConverterSequenceTypePushCondition.write(value.conditions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConditionalPushRule_lift(_ buf: RustBuffer) throws -> ConditionalPushRule {
    return try FfiConverterTypeConditionalPushRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeConditionalPushRule_lower(_ value: ConditionalPushRule) -> RustBuffer {
    return FfiConverterTypeConditionalPushRule.lower(value)
}


public struct CreateRoomParameters: Equatable, Hashable {
    public var name: String?
    public var topic: String?
    public var isEncrypted: Bool
    public var isDirect: Bool
    public var visibility: RoomVisibility
    public var preset: RoomPreset
    public var invite: [String]?
    public var avatar: String?
    public var powerLevelContentOverride: PowerLevels?
    public var joinRuleOverride: JoinRule?
    public var historyVisibilityOverride: RoomHistoryVisibility?
    public var canonicalAlias: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, topic: String? = nil, isEncrypted: Bool, isDirect: Bool = false, visibility: RoomVisibility, preset: RoomPreset, invite: [String]? = nil, avatar: String? = nil, powerLevelContentOverride: PowerLevels? = nil, joinRuleOverride: JoinRule? = nil, historyVisibilityOverride: RoomHistoryVisibility? = nil, canonicalAlias: String? = nil) {
        self.name = name
        self.topic = topic
        self.isEncrypted = isEncrypted
        self.isDirect = isDirect
        self.visibility = visibility
        self.preset = preset
        self.invite = invite
        self.avatar = avatar
        self.powerLevelContentOverride = powerLevelContentOverride
        self.joinRuleOverride = joinRuleOverride
        self.historyVisibilityOverride = historyVisibilityOverride
        self.canonicalAlias = canonicalAlias
    }

    

    
}

#if compiler(>=6)
extension CreateRoomParameters: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCreateRoomParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CreateRoomParameters {
        return
            try CreateRoomParameters(
                name: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                isEncrypted: FfiConverterBool.read(from: &buf), 
                isDirect: FfiConverterBool.read(from: &buf), 
                visibility: FfiConverterTypeRoomVisibility.read(from: &buf), 
                preset: FfiConverterTypeRoomPreset.read(from: &buf), 
                invite: FfiConverterOptionSequenceString.read(from: &buf), 
                avatar: FfiConverterOptionString.read(from: &buf), 
                powerLevelContentOverride: FfiConverterOptionTypePowerLevels.read(from: &buf), 
                joinRuleOverride: FfiConverterOptionTypeJoinRule.read(from: &buf), 
                historyVisibilityOverride: FfiConverterOptionTypeRoomHistoryVisibility.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CreateRoomParameters, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterBool.write(value.isEncrypted, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
        FfiConverterTypeRoomVisibility.write(value.visibility, into: &buf)
        FfiConverterTypeRoomPreset.write(value.preset, into: &buf)
        FfiConverterOptionSequenceString.write(value.invite, into: &buf)
        FfiConverterOptionString.write(value.avatar, into: &buf)
        FfiConverterOptionTypePowerLevels.write(value.powerLevelContentOverride, into: &buf)
        FfiConverterOptionTypeJoinRule.write(value.joinRuleOverride, into: &buf)
        FfiConverterOptionTypeRoomHistoryVisibility.write(value.historyVisibilityOverride, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateRoomParameters_lift(_ buf: RustBuffer) throws -> CreateRoomParameters {
    return try FfiConverterTypeCreateRoomParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCreateRoomParameters_lower(_ value: CreateRoomParameters) -> RustBuffer {
    return FfiConverterTypeCreateRoomParameters.lower(value)
}


public struct EmoteMessageContent: Equatable, Hashable {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }

    

    
}

#if compiler(>=6)
extension EmoteMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmoteMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmoteMessageContent {
        return
            try EmoteMessageContent(
                body: FfiConverterString.read(from: &buf), 
                formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: EmoteMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmoteMessageContent_lift(_ buf: RustBuffer) throws -> EmoteMessageContent {
    return try FfiConverterTypeEmoteMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmoteMessageContent_lower(_ value: EmoteMessageContent) -> RustBuffer {
    return FfiConverterTypeEmoteMessageContent.lower(value)
}


public struct EventTimelineItem {
    /**
     * Indicates that an event is remote.
     */
    public var isRemote: Bool
    public var eventOrTransactionId: EventOrTransactionId
    public var sender: String
    public var senderProfile: ProfileDetails
    public var isOwn: Bool
    public var isEditable: Bool
    public var content: TimelineItemContent
    public var timestamp: Timestamp
    public var localSendState: EventSendState?
    public var localCreatedAt: UInt64?
    public var readReceipts: [String: Receipt]
    public var origin: EventItemOrigin?
    public var canBeRepliedTo: Bool
    public var lazyProvider: LazyTimelineItemProvider

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Indicates that an event is remote.
         */isRemote: Bool, eventOrTransactionId: EventOrTransactionId, sender: String, senderProfile: ProfileDetails, isOwn: Bool, isEditable: Bool, content: TimelineItemContent, timestamp: Timestamp, localSendState: EventSendState?, localCreatedAt: UInt64?, readReceipts: [String: Receipt], origin: EventItemOrigin?, canBeRepliedTo: Bool, lazyProvider: LazyTimelineItemProvider) {
        self.isRemote = isRemote
        self.eventOrTransactionId = eventOrTransactionId
        self.sender = sender
        self.senderProfile = senderProfile
        self.isOwn = isOwn
        self.isEditable = isEditable
        self.content = content
        self.timestamp = timestamp
        self.localSendState = localSendState
        self.localCreatedAt = localCreatedAt
        self.readReceipts = readReceipts
        self.origin = origin
        self.canBeRepliedTo = canBeRepliedTo
        self.lazyProvider = lazyProvider
    }

    

    
}

#if compiler(>=6)
extension EventTimelineItem: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventTimelineItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItem {
        return
            try EventTimelineItem(
                isRemote: FfiConverterBool.read(from: &buf), 
                eventOrTransactionId: FfiConverterTypeEventOrTransactionId.read(from: &buf), 
                sender: FfiConverterString.read(from: &buf), 
                senderProfile: FfiConverterTypeProfileDetails.read(from: &buf), 
                isOwn: FfiConverterBool.read(from: &buf), 
                isEditable: FfiConverterBool.read(from: &buf), 
                content: FfiConverterTypeTimelineItemContent.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf), 
                localSendState: FfiConverterOptionTypeEventSendState.read(from: &buf), 
                localCreatedAt: FfiConverterOptionUInt64.read(from: &buf), 
                readReceipts: FfiConverterDictionaryStringTypeReceipt.read(from: &buf), 
                origin: FfiConverterOptionTypeEventItemOrigin.read(from: &buf), 
                canBeRepliedTo: FfiConverterBool.read(from: &buf), 
                lazyProvider: FfiConverterTypeLazyTimelineItemProvider.read(from: &buf)
        )
    }

    public static func write(_ value: EventTimelineItem, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.isRemote, into: &buf)
        FfiConverterTypeEventOrTransactionId.write(value.eventOrTransactionId, into: &buf)
        FfiConverterString.write(value.sender, into: &buf)
        FfiConverterTypeProfileDetails.write(value.senderProfile, into: &buf)
        FfiConverterBool.write(value.isOwn, into: &buf)
        FfiConverterBool.write(value.isEditable, into: &buf)
        FfiConverterTypeTimelineItemContent.write(value.content, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
        FfiConverterOptionTypeEventSendState.write(value.localSendState, into: &buf)
        FfiConverterOptionUInt64.write(value.localCreatedAt, into: &buf)
        FfiConverterDictionaryStringTypeReceipt.write(value.readReceipts, into: &buf)
        FfiConverterOptionTypeEventItemOrigin.write(value.origin, into: &buf)
        FfiConverterBool.write(value.canBeRepliedTo, into: &buf)
        FfiConverterTypeLazyTimelineItemProvider.write(value.lazyProvider, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventTimelineItem_lift(_ buf: RustBuffer) throws -> EventTimelineItem {
    return try FfiConverterTypeEventTimelineItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventTimelineItem_lower(_ value: EventTimelineItem) -> RustBuffer {
    return FfiConverterTypeEventTimelineItem.lower(value)
}


public struct EventTimelineItemDebugInfo: Equatable, Hashable {
    public var model: String
    public var originalJson: String?
    public var latestEditJson: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(model: String, originalJson: String?, latestEditJson: String?) {
        self.model = model
        self.originalJson = originalJson
        self.latestEditJson = latestEditJson
    }

    

    
}

#if compiler(>=6)
extension EventTimelineItemDebugInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventTimelineItemDebugInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventTimelineItemDebugInfo {
        return
            try EventTimelineItemDebugInfo(
                model: FfiConverterString.read(from: &buf), 
                originalJson: FfiConverterOptionString.read(from: &buf), 
                latestEditJson: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: EventTimelineItemDebugInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.model, into: &buf)
        FfiConverterOptionString.write(value.originalJson, into: &buf)
        FfiConverterOptionString.write(value.latestEditJson, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventTimelineItemDebugInfo_lift(_ buf: RustBuffer) throws -> EventTimelineItemDebugInfo {
    return try FfiConverterTypeEventTimelineItemDebugInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventTimelineItemDebugInfo_lower(_ value: EventTimelineItemDebugInfo) -> RustBuffer {
    return FfiConverterTypeEventTimelineItemDebugInfo.lower(value)
}


public struct FileInfo {
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?) {
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
    }

    

    
}

#if compiler(>=6)
extension FileInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileInfo {
        return
            try FileInfo(
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
                thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf)
        )
    }

    public static func write(_ value: FileInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileInfo_lift(_ buf: RustBuffer) throws -> FileInfo {
    return try FfiConverterTypeFileInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileInfo_lower(_ value: FileInfo) -> RustBuffer {
    return FfiConverterTypeFileInfo.lower(value)
}


public struct FileMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: FileInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: FileInfo?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
    }

    

    
}

#if compiler(>=6)
extension FileMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFileMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FileMessageContent {
        return
            try FileMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeFileInfo.read(from: &buf)
        )
    }

    public static func write(_ value: FileMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeFileInfo.write(value.info, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileMessageContent_lift(_ buf: RustBuffer) throws -> FileMessageContent {
    return try FfiConverterTypeFileMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFileMessageContent_lower(_ value: FileMessageContent) -> RustBuffer {
    return FfiConverterTypeFileMessageContent.lower(value)
}


public struct FormattedBody: Equatable, Hashable {
    public var format: MessageFormat
    public var body: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(format: MessageFormat, body: String) {
        self.format = format
        self.body = body
    }

    

    
}

#if compiler(>=6)
extension FormattedBody: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFormattedBody: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FormattedBody {
        return
            try FormattedBody(
                format: FfiConverterTypeMessageFormat.read(from: &buf), 
                body: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FormattedBody, into buf: inout [UInt8]) {
        FfiConverterTypeMessageFormat.write(value.format, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFormattedBody_lift(_ buf: RustBuffer) throws -> FormattedBody {
    return try FfiConverterTypeFormattedBody.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFormattedBody_lower(_ value: FormattedBody) -> RustBuffer {
    return FfiConverterTypeFormattedBody.lower(value)
}


public struct GalleryMessageContent {
    public var body: String
    public var formatted: FormattedBody?
    public var itemtypes: [GalleryItemType]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?, itemtypes: [GalleryItemType]) {
        self.body = body
        self.formatted = formatted
        self.itemtypes = itemtypes
    }

    

    
}

#if compiler(>=6)
extension GalleryMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGalleryMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GalleryMessageContent {
        return
            try GalleryMessageContent(
                body: FfiConverterString.read(from: &buf), 
                formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                itemtypes: FfiConverterSequenceTypeGalleryItemType.read(from: &buf)
        )
    }

    public static func write(_ value: GalleryMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
        FfiConverterSequenceTypeGalleryItemType.write(value.itemtypes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryMessageContent_lift(_ buf: RustBuffer) throws -> GalleryMessageContent {
    return try FfiConverterTypeGalleryMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryMessageContent_lower(_ value: GalleryMessageContent) -> RustBuffer {
    return FfiConverterTypeGalleryMessageContent.lower(value)
}


public struct GalleryUploadParameters: Equatable, Hashable {
    /**
     * Optional non-formatted caption, for clients that support it.
     */
    public var caption: String?
    /**
     * Optional HTML-formatted caption, for clients that support it.
     */
    public var formattedCaption: FormattedBody?
    /**
     * Optional intentional mentions to be sent with the gallery.
     */
    public var mentions: Mentions?
    /**
     * Optional Event ID to reply to.
     */
    public var inReplyTo: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Optional non-formatted caption, for clients that support it.
         */caption: String?, 
        /**
         * Optional HTML-formatted caption, for clients that support it.
         */formattedCaption: FormattedBody?, 
        /**
         * Optional intentional mentions to be sent with the gallery.
         */mentions: Mentions?, 
        /**
         * Optional Event ID to reply to.
         */inReplyTo: String?) {
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.mentions = mentions
        self.inReplyTo = inReplyTo
    }

    

    
}

#if compiler(>=6)
extension GalleryUploadParameters: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGalleryUploadParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GalleryUploadParameters {
        return
            try GalleryUploadParameters(
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                mentions: FfiConverterOptionTypeMentions.read(from: &buf), 
                inReplyTo: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: GalleryUploadParameters, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterOptionTypeMentions.write(value.mentions, into: &buf)
        FfiConverterOptionString.write(value.inReplyTo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryUploadParameters_lift(_ buf: RustBuffer) throws -> GalleryUploadParameters {
    return try FfiConverterTypeGalleryUploadParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryUploadParameters_lower(_ value: GalleryUploadParameters) -> RustBuffer {
    return FfiConverterTypeGalleryUploadParameters.lower(value)
}


public struct HttpPusherData: Equatable, Hashable {
    public var url: String
    public var format: PushFormat?
    public var defaultPayload: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(url: String, format: PushFormat?, defaultPayload: String?) {
        self.url = url
        self.format = format
        self.defaultPayload = defaultPayload
    }

    

    
}

#if compiler(>=6)
extension HttpPusherData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHttpPusherData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HttpPusherData {
        return
            try HttpPusherData(
                url: FfiConverterString.read(from: &buf), 
                format: FfiConverterOptionTypePushFormat.read(from: &buf), 
                defaultPayload: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: HttpPusherData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.url, into: &buf)
        FfiConverterOptionTypePushFormat.write(value.format, into: &buf)
        FfiConverterOptionString.write(value.defaultPayload, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpPusherData_lift(_ buf: RustBuffer) throws -> HttpPusherData {
    return try FfiConverterTypeHttpPusherData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHttpPusherData_lower(_ value: HttpPusherData) -> RustBuffer {
    return FfiConverterTypeHttpPusherData.lower(value)
}


public struct IdentityStatusChange: Equatable, Hashable {
    /**
     * The user ID of the user whose identity status changed
     */
    public var userId: String
    /**
     * The new state of the identity of the user.
     */
    public var changedTo: IdentityState

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user ID of the user whose identity status changed
         */userId: String, 
        /**
         * The new state of the identity of the user.
         */changedTo: IdentityState) {
        self.userId = userId
        self.changedTo = changedTo
    }

    

    
}

#if compiler(>=6)
extension IdentityStatusChange: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIdentityStatusChange: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityStatusChange {
        return
            try IdentityStatusChange(
                userId: FfiConverterString.read(from: &buf), 
                changedTo: FfiConverterTypeIdentityState.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityStatusChange, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterTypeIdentityState.write(value.changedTo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityStatusChange_lift(_ buf: RustBuffer) throws -> IdentityStatusChange {
    return try FfiConverterTypeIdentityStatusChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIdentityStatusChange_lower(_ value: IdentityStatusChange) -> RustBuffer {
    return FfiConverterTypeIdentityStatusChange.lower(value)
}


/**
 * Details about an ignored user.
 *
 * This is currently empty.
 */
public struct IgnoredUser: Equatable, Hashable {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }

    

    
}

#if compiler(>=6)
extension IgnoredUser: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeIgnoredUser: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IgnoredUser {
        return
            IgnoredUser()
    }

    public static func write(_ value: IgnoredUser, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIgnoredUser_lift(_ buf: RustBuffer) throws -> IgnoredUser {
    return try FfiConverterTypeIgnoredUser.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeIgnoredUser_lower(_ value: IgnoredUser) -> RustBuffer {
    return FfiConverterTypeIgnoredUser.lower(value)
}


public struct ImageInfo {
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?
    public var blurhash: String?
    public var isAnimated: Bool?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?, blurhash: String?, isAnimated: Bool?) {
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
        self.blurhash = blurhash
        self.isAnimated = isAnimated
    }

    

    
}

#if compiler(>=6)
extension ImageInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImageInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageInfo {
        return
            try ImageInfo(
                height: FfiConverterOptionUInt64.read(from: &buf), 
                width: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
                thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf), 
                blurhash: FfiConverterOptionString.read(from: &buf), 
                isAnimated: FfiConverterOptionBool.read(from: &buf)
        )
    }

    public static func write(_ value: ImageInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
        FfiConverterOptionString.write(value.blurhash, into: &buf)
        FfiConverterOptionBool.write(value.isAnimated, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageInfo_lift(_ buf: RustBuffer) throws -> ImageInfo {
    return try FfiConverterTypeImageInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageInfo_lower(_ value: ImageInfo) -> RustBuffer {
    return FfiConverterTypeImageInfo.lower(value)
}


public struct ImageMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: ImageInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: ImageInfo?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
    }

    

    
}

#if compiler(>=6)
extension ImageMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeImageMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ImageMessageContent {
        return
            try ImageMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeImageInfo.read(from: &buf)
        )
    }

    public static func write(_ value: ImageMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeImageInfo.write(value.info, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageMessageContent_lift(_ buf: RustBuffer) throws -> ImageMessageContent {
    return try FfiConverterTypeImageMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeImageMessageContent_lower(_ value: ImageMessageContent) -> RustBuffer {
    return FfiConverterTypeImageMessageContent.lower(value)
}


/**
 * An FFI representation of a request to join a room.
 */
public struct KnockRequest {
    /**
     * The event id of the event that contains the `knock` membership change.
     */
    public var eventId: String
    /**
     * The user id of the user who's requesting to join the room.
     */
    public var userId: String
    /**
     * The room id of the room whose access was requested.
     */
    public var roomId: String
    /**
     * The optional display name of the user who's requesting to join the room.
     */
    public var displayName: String?
    /**
     * The optional avatar url of the user who's requesting to join the room.
     */
    public var avatarUrl: String?
    /**
     * An optional reason why the user wants join the room.
     */
    public var reason: String?
    /**
     * The timestamp when this request was created.
     */
    public var timestamp: UInt64?
    /**
     * Whether the knock request has been marked as `seen` so it can be
     * filtered by the client.
     */
    public var isSeen: Bool
    /**
     * A set of actions to perform for this knock request.
     */
    public var actions: KnockRequestActions

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The event id of the event that contains the `knock` membership change.
         */eventId: String, 
        /**
         * The user id of the user who's requesting to join the room.
         */userId: String, 
        /**
         * The room id of the room whose access was requested.
         */roomId: String, 
        /**
         * The optional display name of the user who's requesting to join the room.
         */displayName: String?, 
        /**
         * The optional avatar url of the user who's requesting to join the room.
         */avatarUrl: String?, 
        /**
         * An optional reason why the user wants join the room.
         */reason: String?, 
        /**
         * The timestamp when this request was created.
         */timestamp: UInt64?, 
        /**
         * Whether the knock request has been marked as `seen` so it can be
         * filtered by the client.
         */isSeen: Bool, 
        /**
         * A set of actions to perform for this knock request.
         */actions: KnockRequestActions) {
        self.eventId = eventId
        self.userId = userId
        self.roomId = roomId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.reason = reason
        self.timestamp = timestamp
        self.isSeen = isSeen
        self.actions = actions
    }

    

    
}

#if compiler(>=6)
extension KnockRequest: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKnockRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KnockRequest {
        return
            try KnockRequest(
                eventId: FfiConverterString.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf), 
                roomId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                reason: FfiConverterOptionString.read(from: &buf), 
                timestamp: FfiConverterOptionUInt64.read(from: &buf), 
                isSeen: FfiConverterBool.read(from: &buf), 
                actions: FfiConverterTypeKnockRequestActions.read(from: &buf)
        )
    }

    public static func write(_ value: KnockRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.eventId, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
        FfiConverterOptionUInt64.write(value.timestamp, into: &buf)
        FfiConverterBool.write(value.isSeen, into: &buf)
        FfiConverterTypeKnockRequestActions.write(value.actions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKnockRequest_lift(_ buf: RustBuffer) throws -> KnockRequest {
    return try FfiConverterTypeKnockRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKnockRequest_lower(_ value: KnockRequest) -> RustBuffer {
    return FfiConverterTypeKnockRequest.lower(value)
}


public struct LastLocation: Equatable, Hashable {
    /**
     * The most recent location content of the user.
     */
    public var location: LocationContent
    /**
     * A timestamp in milliseconds since Unix Epoch on that day in local
     * time.
     */
    public var ts: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The most recent location content of the user.
         */location: LocationContent, 
        /**
         * A timestamp in milliseconds since Unix Epoch on that day in local
         * time.
         */ts: UInt64) {
        self.location = location
        self.ts = ts
    }

    

    
}

#if compiler(>=6)
extension LastLocation: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLastLocation: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LastLocation {
        return
            try LastLocation(
                location: FfiConverterTypeLocationContent.read(from: &buf), 
                ts: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: LastLocation, into buf: inout [UInt8]) {
        FfiConverterTypeLocationContent.write(value.location, into: &buf)
        FfiConverterUInt64.write(value.ts, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLastLocation_lift(_ buf: RustBuffer) throws -> LastLocation {
    return try FfiConverterTypeLastLocation.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLastLocation_lower(_ value: LastLocation) -> RustBuffer {
    return FfiConverterTypeLastLocation.lower(value)
}


/**
 * Space leaving specific room that groups normal [`SpaceRoom`] details with
 * information about the leaving user's role.
 */
public struct LeaveSpaceRoom: Equatable, Hashable {
    /**
     * The underlying [`SpaceRoom`]
     */
    public var spaceRoom: SpaceRoom
    /**
     * Whether the user is the last admin in the room. This helps clients
     * better inform the user about the consequences of leaving the room.
     */
    public var isLastAdmin: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The underlying [`SpaceRoom`]
         */spaceRoom: SpaceRoom, 
        /**
         * Whether the user is the last admin in the room. This helps clients
         * better inform the user about the consequences of leaving the room.
         */isLastAdmin: Bool) {
        self.spaceRoom = spaceRoom
        self.isLastAdmin = isLastAdmin
    }

    

    
}

#if compiler(>=6)
extension LeaveSpaceRoom: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLeaveSpaceRoom: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LeaveSpaceRoom {
        return
            try LeaveSpaceRoom(
                spaceRoom: FfiConverterTypeSpaceRoom.read(from: &buf), 
                isLastAdmin: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: LeaveSpaceRoom, into buf: inout [UInt8]) {
        FfiConverterTypeSpaceRoom.write(value.spaceRoom, into: &buf)
        FfiConverterBool.write(value.isLastAdmin, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeaveSpaceRoom_lift(_ buf: RustBuffer) throws -> LeaveSpaceRoom {
    return try FfiConverterTypeLeaveSpaceRoom.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLeaveSpaceRoom_lower(_ value: LeaveSpaceRoom) -> RustBuffer {
    return FfiConverterTypeLeaveSpaceRoom.lower(value)
}


/**
 * Details of a users live location share.
 */
public struct LiveLocationShare: Equatable, Hashable {
    /**
     * The user's last known location.
     */
    public var lastLocation: LastLocation
    /**
     * The live status of the live location share.
     */
    public var isLive: Bool
    /**
     * The user ID of the person sharing their live location.
     */
    public var userId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user's last known location.
         */lastLocation: LastLocation, 
        /**
         * The live status of the live location share.
         */isLive: Bool, 
        /**
         * The user ID of the person sharing their live location.
         */userId: String) {
        self.lastLocation = lastLocation
        self.isLive = isLive
        self.userId = userId
    }

    

    
}

#if compiler(>=6)
extension LiveLocationShare: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLiveLocationShare: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LiveLocationShare {
        return
            try LiveLocationShare(
                lastLocation: FfiConverterTypeLastLocation.read(from: &buf), 
                isLive: FfiConverterBool.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: LiveLocationShare, into buf: inout [UInt8]) {
        FfiConverterTypeLastLocation.write(value.lastLocation, into: &buf)
        FfiConverterBool.write(value.isLive, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveLocationShare_lift(_ buf: RustBuffer) throws -> LiveLocationShare {
    return try FfiConverterTypeLiveLocationShare.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLiveLocationShare_lower(_ value: LiveLocationShare) -> RustBuffer {
    return FfiConverterTypeLiveLocationShare.lower(value)
}


public struct LocationContent: Equatable, Hashable {
    public var body: String
    public var geoUri: String
    public var description: String?
    public var zoomLevel: UInt8?
    public var asset: AssetType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, geoUri: String, description: String?, zoomLevel: UInt8?, asset: AssetType?) {
        self.body = body
        self.geoUri = geoUri
        self.description = description
        self.zoomLevel = zoomLevel
        self.asset = asset
    }

    

    
}

#if compiler(>=6)
extension LocationContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLocationContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocationContent {
        return
            try LocationContent(
                body: FfiConverterString.read(from: &buf), 
                geoUri: FfiConverterString.read(from: &buf), 
                description: FfiConverterOptionString.read(from: &buf), 
                zoomLevel: FfiConverterOptionUInt8.read(from: &buf), 
                asset: FfiConverterOptionTypeAssetType.read(from: &buf)
        )
    }

    public static func write(_ value: LocationContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterString.write(value.geoUri, into: &buf)
        FfiConverterOptionString.write(value.description, into: &buf)
        FfiConverterOptionUInt8.write(value.zoomLevel, into: &buf)
        FfiConverterOptionTypeAssetType.write(value.asset, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocationContent_lift(_ buf: RustBuffer) throws -> LocationContent {
    return try FfiConverterTypeLocationContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLocationContent_lower(_ value: LocationContent) -> RustBuffer {
    return FfiConverterTypeLocationContent.lower(value)
}


/**
 * A Matrix entity that can be a room, room alias, user, or event, and a list
 * of via servers.
 */
public struct MatrixEntity: Equatable, Hashable {
    public var id: MatrixId
    public var via: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: MatrixId, via: [String]) {
        self.id = id
        self.via = via
    }

    

    
}

#if compiler(>=6)
extension MatrixEntity: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMatrixEntity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixEntity {
        return
            try MatrixEntity(
                id: FfiConverterTypeMatrixId.read(from: &buf), 
                via: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: MatrixEntity, into buf: inout [UInt8]) {
        FfiConverterTypeMatrixId.write(value.id, into: &buf)
        FfiConverterSequenceString.write(value.via, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixEntity_lift(_ buf: RustBuffer) throws -> MatrixEntity {
    return try FfiConverterTypeMatrixEntity.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixEntity_lower(_ value: MatrixEntity) -> RustBuffer {
    return FfiConverterTypeMatrixEntity.lower(value)
}


/**
 * The content of an `m.media_preview_config` event.
 *
 * Is also the content of the unstable
 * `io.element.msc4278.media_preview_config`.
 */
public struct MediaPreviewConfig: Equatable, Hashable {
    /**
     * The media previews setting for the user.
     */
    public var mediaPreviews: MediaPreviews?
    /**
     * The invite avatars setting for the user.
     */
    public var inviteAvatars: InviteAvatars?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The media previews setting for the user.
         */mediaPreviews: MediaPreviews?, 
        /**
         * The invite avatars setting for the user.
         */inviteAvatars: InviteAvatars?) {
        self.mediaPreviews = mediaPreviews
        self.inviteAvatars = inviteAvatars
    }

    

    
}

#if compiler(>=6)
extension MediaPreviewConfig: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMediaPreviewConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaPreviewConfig {
        return
            try MediaPreviewConfig(
                mediaPreviews: FfiConverterOptionTypeMediaPreviews.read(from: &buf), 
                inviteAvatars: FfiConverterOptionTypeInviteAvatars.read(from: &buf)
        )
    }

    public static func write(_ value: MediaPreviewConfig, into buf: inout [UInt8]) {
        FfiConverterOptionTypeMediaPreviews.write(value.mediaPreviews, into: &buf)
        FfiConverterOptionTypeInviteAvatars.write(value.inviteAvatars, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaPreviewConfig_lift(_ buf: RustBuffer) throws -> MediaPreviewConfig {
    return try FfiConverterTypeMediaPreviewConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaPreviewConfig_lower(_ value: MediaPreviewConfig) -> RustBuffer {
    return FfiConverterTypeMediaPreviewConfig.lower(value)
}


/**
 * This type represents the progress of a media (consisting of a file and
 * possibly a thumbnail) being uploaded.
 */
public struct MediaUploadProgress: Equatable, Hashable {
    /**
     * The index of the media within the transaction. A file and its
     * thumbnail share the same index. Will always be 0 for non-gallery
     * media uploads.
     */
    public var index: UInt64
    /**
     * The current combined upload progress for both the file and,
     * if it exists, its thumbnail.
     */
    public var progress: AbstractProgress

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The index of the media within the transaction. A file and its
         * thumbnail share the same index. Will always be 0 for non-gallery
         * media uploads.
         */index: UInt64, 
        /**
         * The current combined upload progress for both the file and,
         * if it exists, its thumbnail.
         */progress: AbstractProgress) {
        self.index = index
        self.progress = progress
    }

    

    
}

#if compiler(>=6)
extension MediaUploadProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMediaUploadProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaUploadProgress {
        return
            try MediaUploadProgress(
                index: FfiConverterUInt64.read(from: &buf), 
                progress: FfiConverterTypeAbstractProgress.read(from: &buf)
        )
    }

    public static func write(_ value: MediaUploadProgress, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.index, into: &buf)
        FfiConverterTypeAbstractProgress.write(value.progress, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaUploadProgress_lift(_ buf: RustBuffer) throws -> MediaUploadProgress {
    return try FfiConverterTypeMediaUploadProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaUploadProgress_lower(_ value: MediaUploadProgress) -> RustBuffer {
    return FfiConverterTypeMediaUploadProgress.lower(value)
}


public struct Mentions: Equatable, Hashable {
    public var userIds: [String]
    public var room: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userIds: [String], room: Bool) {
        self.userIds = userIds
        self.room = room
    }

    

    
}

#if compiler(>=6)
extension Mentions: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMentions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Mentions {
        return
            try Mentions(
                userIds: FfiConverterSequenceString.read(from: &buf), 
                room: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Mentions, into buf: inout [UInt8]) {
        FfiConverterSequenceString.write(value.userIds, into: &buf)
        FfiConverterBool.write(value.room, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMentions_lift(_ buf: RustBuffer) throws -> Mentions {
    return try FfiConverterTypeMentions.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMentions_lower(_ value: Mentions) -> RustBuffer {
    return FfiConverterTypeMentions.lower(value)
}


public struct MessageContent {
    public var msgType: MessageType
    public var body: String
    public var isEdited: Bool
    public var mentions: Mentions?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(msgType: MessageType, body: String, isEdited: Bool, mentions: Mentions?) {
        self.msgType = msgType
        self.body = body
        self.isEdited = isEdited
        self.mentions = mentions
    }

    

    
}

#if compiler(>=6)
extension MessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageContent {
        return
            try MessageContent(
                msgType: FfiConverterTypeMessageType.read(from: &buf), 
                body: FfiConverterString.read(from: &buf), 
                isEdited: FfiConverterBool.read(from: &buf), 
                mentions: FfiConverterOptionTypeMentions.read(from: &buf)
        )
    }

    public static func write(_ value: MessageContent, into buf: inout [UInt8]) {
        FfiConverterTypeMessageType.write(value.msgType, into: &buf)
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterBool.write(value.isEdited, into: &buf)
        FfiConverterOptionTypeMentions.write(value.mentions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageContent_lift(_ buf: RustBuffer) throws -> MessageContent {
    return try FfiConverterTypeMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageContent_lower(_ value: MessageContent) -> RustBuffer {
    return FfiConverterTypeMessageContent.lower(value)
}


/**
 * A special kind of [`super::TimelineItemContent`] that groups together
 * different room message types with their respective reactions and thread
 * information.
 */
public struct MsgLikeContent {
    public var kind: MsgLikeKind
    public var reactions: [Reaction]
    /**
     * The event this message is replying to, if any.
     */
    public var inReplyTo: InReplyToDetails?
    /**
     * Event ID of the thread root, if this is a message in a thread.
     */
    public var threadRoot: String?
    /**
     * Details about the thread this message is the root of.
     */
    public var threadSummary: ThreadSummary?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(kind: MsgLikeKind, reactions: [Reaction], 
        /**
         * The event this message is replying to, if any.
         */inReplyTo: InReplyToDetails?, 
        /**
         * Event ID of the thread root, if this is a message in a thread.
         */threadRoot: String?, 
        /**
         * Details about the thread this message is the root of.
         */threadSummary: ThreadSummary?) {
        self.kind = kind
        self.reactions = reactions
        self.inReplyTo = inReplyTo
        self.threadRoot = threadRoot
        self.threadSummary = threadSummary
    }

    

    
}

#if compiler(>=6)
extension MsgLikeContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMsgLikeContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MsgLikeContent {
        return
            try MsgLikeContent(
                kind: FfiConverterTypeMsgLikeKind.read(from: &buf), 
                reactions: FfiConverterSequenceTypeReaction.read(from: &buf), 
                inReplyTo: FfiConverterOptionTypeInReplyToDetails.read(from: &buf), 
                threadRoot: FfiConverterOptionString.read(from: &buf), 
                threadSummary: FfiConverterOptionTypeThreadSummary.read(from: &buf)
        )
    }

    public static func write(_ value: MsgLikeContent, into buf: inout [UInt8]) {
        FfiConverterTypeMsgLikeKind.write(value.kind, into: &buf)
        FfiConverterSequenceTypeReaction.write(value.reactions, into: &buf)
        FfiConverterOptionTypeInReplyToDetails.write(value.inReplyTo, into: &buf)
        FfiConverterOptionString.write(value.threadRoot, into: &buf)
        FfiConverterOptionTypeThreadSummary.write(value.threadSummary, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMsgLikeContent_lift(_ buf: RustBuffer) throws -> MsgLikeContent {
    return try FfiConverterTypeMsgLikeContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMsgLikeContent_lower(_ value: MsgLikeContent) -> RustBuffer {
    return FfiConverterTypeMsgLikeContent.lower(value)
}


public struct NoticeMessageContent: Equatable, Hashable {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }

    

    
}

#if compiler(>=6)
extension NoticeMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNoticeMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NoticeMessageContent {
        return
            try NoticeMessageContent(
                body: FfiConverterString.read(from: &buf), 
                formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: NoticeMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoticeMessageContent_lift(_ buf: RustBuffer) throws -> NoticeMessageContent {
    return try FfiConverterTypeNoticeMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNoticeMessageContent_lower(_ value: NoticeMessageContent) -> RustBuffer {
    return FfiConverterTypeNoticeMessageContent.lower(value)
}


public struct NotificationItem {
    public var event: NotificationEvent
    public var senderInfo: NotificationSenderInfo
    public var roomInfo: NotificationRoomInfo
    /**
     * Is the notification supposed to be at the "noisy" level?
     * Can be `None` if we couldn't determine this, because we lacked
     * information to create a push context.
     */
    public var isNoisy: Bool?
    public var hasMention: Bool?
    public var threadId: String?
    /**
     * The push actions for this notification (notify, sound, highlight, etc.).
     */
    public var actions: [Action]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(event: NotificationEvent, senderInfo: NotificationSenderInfo, roomInfo: NotificationRoomInfo, 
        /**
         * Is the notification supposed to be at the "noisy" level?
         * Can be `None` if we couldn't determine this, because we lacked
         * information to create a push context.
         */isNoisy: Bool?, hasMention: Bool?, threadId: String?, 
        /**
         * The push actions for this notification (notify, sound, highlight, etc.).
         */actions: [Action]?) {
        self.event = event
        self.senderInfo = senderInfo
        self.roomInfo = roomInfo
        self.isNoisy = isNoisy
        self.hasMention = hasMention
        self.threadId = threadId
        self.actions = actions
    }

    

    
}

#if compiler(>=6)
extension NotificationItem: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationItem: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationItem {
        return
            try NotificationItem(
                event: FfiConverterTypeNotificationEvent.read(from: &buf), 
                senderInfo: FfiConverterTypeNotificationSenderInfo.read(from: &buf), 
                roomInfo: FfiConverterTypeNotificationRoomInfo.read(from: &buf), 
                isNoisy: FfiConverterOptionBool.read(from: &buf), 
                hasMention: FfiConverterOptionBool.read(from: &buf), 
                threadId: FfiConverterOptionString.read(from: &buf), 
                actions: FfiConverterOptionSequenceTypeAction.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationItem, into buf: inout [UInt8]) {
        FfiConverterTypeNotificationEvent.write(value.event, into: &buf)
        FfiConverterTypeNotificationSenderInfo.write(value.senderInfo, into: &buf)
        FfiConverterTypeNotificationRoomInfo.write(value.roomInfo, into: &buf)
        FfiConverterOptionBool.write(value.isNoisy, into: &buf)
        FfiConverterOptionBool.write(value.hasMention, into: &buf)
        FfiConverterOptionString.write(value.threadId, into: &buf)
        FfiConverterOptionSequenceTypeAction.write(value.actions, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationItem_lift(_ buf: RustBuffer) throws -> NotificationItem {
    return try FfiConverterTypeNotificationItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationItem_lower(_ value: NotificationItem) -> RustBuffer {
    return FfiConverterTypeNotificationItem.lower(value)
}


/**
 * A request for notification items grouped by their room.
 */
public struct NotificationItemsRequest: Equatable, Hashable {
    public var roomId: String
    public var eventIds: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roomId: String, eventIds: [String]) {
        self.roomId = roomId
        self.eventIds = eventIds
    }

    

    
}

#if compiler(>=6)
extension NotificationItemsRequest: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationItemsRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationItemsRequest {
        return
            try NotificationItemsRequest(
                roomId: FfiConverterString.read(from: &buf), 
                eventIds: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationItemsRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterSequenceString.write(value.eventIds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationItemsRequest_lift(_ buf: RustBuffer) throws -> NotificationItemsRequest {
    return try FfiConverterTypeNotificationItemsRequest.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationItemsRequest_lower(_ value: NotificationItemsRequest) -> RustBuffer {
    return FfiConverterTypeNotificationItemsRequest.lower(value)
}


public struct NotificationPowerLevels: Equatable, Hashable {
    public var room: Int32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(room: Int32) {
        self.room = room
    }

    

    
}

#if compiler(>=6)
extension NotificationPowerLevels: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationPowerLevels: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationPowerLevels {
        return
            try NotificationPowerLevels(
                room: FfiConverterInt32.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationPowerLevels, into buf: inout [UInt8]) {
        FfiConverterInt32.write(value.room, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationPowerLevels_lift(_ buf: RustBuffer) throws -> NotificationPowerLevels {
    return try FfiConverterTypeNotificationPowerLevels.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationPowerLevels_lower(_ value: NotificationPowerLevels) -> RustBuffer {
    return FfiConverterTypeNotificationPowerLevels.lower(value)
}


public struct NotificationRoomInfo: Equatable, Hashable {
    public var displayName: String
    public var avatarUrl: String?
    public var canonicalAlias: String?
    public var topic: String?
    public var joinRule: JoinRule?
    public var joinedMembersCount: UInt64
    public var isEncrypted: Bool?
    public var isDirect: Bool
    public var isSpace: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String, avatarUrl: String?, canonicalAlias: String?, topic: String?, joinRule: JoinRule?, joinedMembersCount: UInt64, isEncrypted: Bool?, isDirect: Bool, isSpace: Bool) {
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.canonicalAlias = canonicalAlias
        self.topic = topic
        self.joinRule = joinRule
        self.joinedMembersCount = joinedMembersCount
        self.isEncrypted = isEncrypted
        self.isDirect = isDirect
        self.isSpace = isSpace
    }

    

    
}

#if compiler(>=6)
extension NotificationRoomInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationRoomInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationRoomInfo {
        return
            try NotificationRoomInfo(
                displayName: FfiConverterString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                joinRule: FfiConverterOptionTypeJoinRule.read(from: &buf), 
                joinedMembersCount: FfiConverterUInt64.read(from: &buf), 
                isEncrypted: FfiConverterOptionBool.read(from: &buf), 
                isDirect: FfiConverterBool.read(from: &buf), 
                isSpace: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationRoomInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionTypeJoinRule.write(value.joinRule, into: &buf)
        FfiConverterUInt64.write(value.joinedMembersCount, into: &buf)
        FfiConverterOptionBool.write(value.isEncrypted, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
        FfiConverterBool.write(value.isSpace, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationRoomInfo_lift(_ buf: RustBuffer) throws -> NotificationRoomInfo {
    return try FfiConverterTypeNotificationRoomInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationRoomInfo_lower(_ value: NotificationRoomInfo) -> RustBuffer {
    return FfiConverterTypeNotificationRoomInfo.lower(value)
}


public struct NotificationSenderInfo: Equatable, Hashable {
    public var displayName: String?
    public var avatarUrl: String?
    public var isNameAmbiguous: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(displayName: String?, avatarUrl: String?, isNameAmbiguous: Bool) {
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.isNameAmbiguous = isNameAmbiguous
    }

    

    
}

#if compiler(>=6)
extension NotificationSenderInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationSenderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSenderInfo {
        return
            try NotificationSenderInfo(
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                isNameAmbiguous: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: NotificationSenderInfo, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterBool.write(value.isNameAmbiguous, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationSenderInfo_lift(_ buf: RustBuffer) throws -> NotificationSenderInfo {
    return try FfiConverterTypeNotificationSenderInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationSenderInfo_lower(_ value: NotificationSenderInfo) -> RustBuffer {
    return FfiConverterTypeNotificationSenderInfo.lower(value)
}


/**
 * The configuration to use when authenticating with OIDC.
 */
public struct OidcConfiguration: Equatable, Hashable {
    /**
     * The name of the client that will be shown during OIDC authentication.
     */
    public var clientName: String?
    /**
     * The redirect URI that will be used when OIDC authentication is
     * successful.
     */
    public var redirectUri: String
    /**
     * A URI that contains information about the client.
     */
    public var clientUri: String
    /**
     * A URI that contains the client's logo.
     */
    public var logoUri: String?
    /**
     * A URI that contains the client's terms of service.
     */
    public var tosUri: String?
    /**
     * A URI that contains the client's privacy policy.
     */
    public var policyUri: String?
    /**
     * Pre-configured registrations for use with homeservers that don't support
     * dynamic client registration.
     *
     * The keys of the map should be the URLs of the homeservers, but keys
     * using `issuer` URLs are also supported.
     */
    public var staticRegistrations: [String: String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The name of the client that will be shown during OIDC authentication.
         */clientName: String?, 
        /**
         * The redirect URI that will be used when OIDC authentication is
         * successful.
         */redirectUri: String, 
        /**
         * A URI that contains information about the client.
         */clientUri: String, 
        /**
         * A URI that contains the client's logo.
         */logoUri: String?, 
        /**
         * A URI that contains the client's terms of service.
         */tosUri: String?, 
        /**
         * A URI that contains the client's privacy policy.
         */policyUri: String?, 
        /**
         * Pre-configured registrations for use with homeservers that don't support
         * dynamic client registration.
         *
         * The keys of the map should be the URLs of the homeservers, but keys
         * using `issuer` URLs are also supported.
         */staticRegistrations: [String: String]) {
        self.clientName = clientName
        self.redirectUri = redirectUri
        self.clientUri = clientUri
        self.logoUri = logoUri
        self.tosUri = tosUri
        self.policyUri = policyUri
        self.staticRegistrations = staticRegistrations
    }

    

    
}

#if compiler(>=6)
extension OidcConfiguration: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOidcConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcConfiguration {
        return
            try OidcConfiguration(
                clientName: FfiConverterOptionString.read(from: &buf), 
                redirectUri: FfiConverterString.read(from: &buf), 
                clientUri: FfiConverterString.read(from: &buf), 
                logoUri: FfiConverterOptionString.read(from: &buf), 
                tosUri: FfiConverterOptionString.read(from: &buf), 
                policyUri: FfiConverterOptionString.read(from: &buf), 
                staticRegistrations: FfiConverterDictionaryStringString.read(from: &buf)
        )
    }

    public static func write(_ value: OidcConfiguration, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.clientName, into: &buf)
        FfiConverterString.write(value.redirectUri, into: &buf)
        FfiConverterString.write(value.clientUri, into: &buf)
        FfiConverterOptionString.write(value.logoUri, into: &buf)
        FfiConverterOptionString.write(value.tosUri, into: &buf)
        FfiConverterOptionString.write(value.policyUri, into: &buf)
        FfiConverterDictionaryStringString.write(value.staticRegistrations, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcConfiguration_lift(_ buf: RustBuffer) throws -> OidcConfiguration {
    return try FfiConverterTypeOidcConfiguration.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcConfiguration_lower(_ value: OidcConfiguration) -> RustBuffer {
    return FfiConverterTypeOidcConfiguration.lower(value)
}


public struct OidcCrossSigningResetInfo: Equatable, Hashable {
    /**
     * The URL where the user can approve the reset of the cross-signing keys.
     */
    public var approvalUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The URL where the user can approve the reset of the cross-signing keys.
         */approvalUrl: String) {
        self.approvalUrl = approvalUrl
    }

    

    
}

#if compiler(>=6)
extension OidcCrossSigningResetInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOidcCrossSigningResetInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcCrossSigningResetInfo {
        return
            try OidcCrossSigningResetInfo(
                approvalUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: OidcCrossSigningResetInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.approvalUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcCrossSigningResetInfo_lift(_ buf: RustBuffer) throws -> OidcCrossSigningResetInfo {
    return try FfiConverterTypeOidcCrossSigningResetInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcCrossSigningResetInfo_lower(_ value: OidcCrossSigningResetInfo) -> RustBuffer {
    return FfiConverterTypeOidcCrossSigningResetInfo.lower(value)
}


/**
 * A passphrase from which a key is to be derived.
 */
public struct PassPhrase: Equatable, Hashable {
    /**
     * The algorithm to use to generate the key from the passphrase.
     *
     * Must be `m.pbkdf2`.
     */
    public var algorithm: KeyDerivationAlgorithm
    /**
     * The salt used in PBKDF2.
     */
    public var salt: String
    /**
     * The number of iterations to use in PBKDF2.
     */
    public var iterations: UInt64
    /**
     * The number of bits to generate for the key.
     *
     * Defaults to 256
     */
    public var bits: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The algorithm to use to generate the key from the passphrase.
         *
         * Must be `m.pbkdf2`.
         */algorithm: KeyDerivationAlgorithm, 
        /**
         * The salt used in PBKDF2.
         */salt: String, 
        /**
         * The number of iterations to use in PBKDF2.
         */iterations: UInt64, 
        /**
         * The number of bits to generate for the key.
         *
         * Defaults to 256
         */bits: UInt64) {
        self.algorithm = algorithm
        self.salt = salt
        self.iterations = iterations
        self.bits = bits
    }

    

    
}

#if compiler(>=6)
extension PassPhrase: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePassPhrase: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PassPhrase {
        return
            try PassPhrase(
                algorithm: FfiConverterTypeKeyDerivationAlgorithm.read(from: &buf), 
                salt: FfiConverterString.read(from: &buf), 
                iterations: FfiConverterUInt64.read(from: &buf), 
                bits: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: PassPhrase, into buf: inout [UInt8]) {
        FfiConverterTypeKeyDerivationAlgorithm.write(value.algorithm, into: &buf)
        FfiConverterString.write(value.salt, into: &buf)
        FfiConverterUInt64.write(value.iterations, into: &buf)
        FfiConverterUInt64.write(value.bits, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePassPhrase_lift(_ buf: RustBuffer) throws -> PassPhrase {
    return try FfiConverterTypePassPhrase.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePassPhrase_lower(_ value: PassPhrase) -> RustBuffer {
    return FfiConverterTypePassPhrase.lower(value)
}


/**
 * Like [`SimplePushRule`], but with an additional `pattern`` field.
 */
public struct PatternedPushRule: Equatable, Hashable {
    /**
     * Actions to determine if and how a notification is delivered for events
     * matching this rule.
     */
    public var actions: [Action]
    /**
     * Whether this is a default rule, or has been set explicitly.
     */
    public var `default`: Bool
    /**
     * Whether the push rule is enabled or not.
     */
    public var enabled: Bool
    /**
     * The ID of this rule.
     */
    public var ruleId: String
    /**
     * The glob-style pattern to match against.
     */
    public var pattern: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Actions to determine if and how a notification is delivered for events
         * matching this rule.
         */actions: [Action], 
        /**
         * Whether this is a default rule, or has been set explicitly.
         */`default`: Bool, 
        /**
         * Whether the push rule is enabled or not.
         */enabled: Bool, 
        /**
         * The ID of this rule.
         */ruleId: String, 
        /**
         * The glob-style pattern to match against.
         */pattern: String) {
        self.actions = actions
        self.`default` = `default`
        self.enabled = enabled
        self.ruleId = ruleId
        self.pattern = pattern
    }

    

    
}

#if compiler(>=6)
extension PatternedPushRule: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePatternedPushRule: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PatternedPushRule {
        return
            try PatternedPushRule(
                actions: FfiConverterSequenceTypeAction.read(from: &buf), 
                default: FfiConverterBool.read(from: &buf), 
                enabled: FfiConverterBool.read(from: &buf), 
                ruleId: FfiConverterString.read(from: &buf), 
                pattern: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PatternedPushRule, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAction.write(value.actions, into: &buf)
        FfiConverterBool.write(value.`default`, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterString.write(value.ruleId, into: &buf)
        FfiConverterString.write(value.pattern, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePatternedPushRule_lift(_ buf: RustBuffer) throws -> PatternedPushRule {
    return try FfiConverterTypePatternedPushRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePatternedPushRule_lower(_ value: PatternedPushRule) -> RustBuffer {
    return FfiConverterTypePatternedPushRule.lower(value)
}


public struct PollAnswer: Equatable, Hashable {
    public var id: String
    public var text: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, text: String) {
        self.id = id
        self.text = text
    }

    

    
}

#if compiler(>=6)
extension PollAnswer: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePollAnswer: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollAnswer {
        return
            try PollAnswer(
                id: FfiConverterString.read(from: &buf), 
                text: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PollAnswer, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterString.write(value.text, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollAnswer_lift(_ buf: RustBuffer) throws -> PollAnswer {
    return try FfiConverterTypePollAnswer.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollAnswer_lower(_ value: PollAnswer) -> RustBuffer {
    return FfiConverterTypePollAnswer.lower(value)
}


public struct PollData: Equatable, Hashable {
    public var question: String
    public var answers: [String]
    public var maxSelections: UInt8
    public var pollKind: PollKind

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(question: String, answers: [String], maxSelections: UInt8, pollKind: PollKind) {
        self.question = question
        self.answers = answers
        self.maxSelections = maxSelections
        self.pollKind = pollKind
    }

    

    
}

#if compiler(>=6)
extension PollData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePollData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollData {
        return
            try PollData(
                question: FfiConverterString.read(from: &buf), 
                answers: FfiConverterSequenceString.read(from: &buf), 
                maxSelections: FfiConverterUInt8.read(from: &buf), 
                pollKind: FfiConverterTypePollKind.read(from: &buf)
        )
    }

    public static func write(_ value: PollData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.question, into: &buf)
        FfiConverterSequenceString.write(value.answers, into: &buf)
        FfiConverterUInt8.write(value.maxSelections, into: &buf)
        FfiConverterTypePollKind.write(value.pollKind, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollData_lift(_ buf: RustBuffer) throws -> PollData {
    return try FfiConverterTypePollData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollData_lower(_ value: PollData) -> RustBuffer {
    return FfiConverterTypePollData.lower(value)
}


public struct PowerLevels: Equatable, Hashable {
    public var usersDefault: Int32?
    public var eventsDefault: Int32?
    public var stateDefault: Int32?
    public var ban: Int32?
    public var kick: Int32?
    public var redact: Int32?
    public var invite: Int32?
    public var notifications: NotificationPowerLevels?
    public var users: [String: Int32]
    public var events: [String: Int32]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(usersDefault: Int32?, eventsDefault: Int32?, stateDefault: Int32?, ban: Int32?, kick: Int32?, redact: Int32?, invite: Int32?, notifications: NotificationPowerLevels?, users: [String: Int32], events: [String: Int32]) {
        self.usersDefault = usersDefault
        self.eventsDefault = eventsDefault
        self.stateDefault = stateDefault
        self.ban = ban
        self.kick = kick
        self.redact = redact
        self.invite = invite
        self.notifications = notifications
        self.users = users
        self.events = events
    }

    

    
}

#if compiler(>=6)
extension PowerLevels: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePowerLevels: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PowerLevels {
        return
            try PowerLevels(
                usersDefault: FfiConverterOptionInt32.read(from: &buf), 
                eventsDefault: FfiConverterOptionInt32.read(from: &buf), 
                stateDefault: FfiConverterOptionInt32.read(from: &buf), 
                ban: FfiConverterOptionInt32.read(from: &buf), 
                kick: FfiConverterOptionInt32.read(from: &buf), 
                redact: FfiConverterOptionInt32.read(from: &buf), 
                invite: FfiConverterOptionInt32.read(from: &buf), 
                notifications: FfiConverterOptionTypeNotificationPowerLevels.read(from: &buf), 
                users: FfiConverterDictionaryStringInt32.read(from: &buf), 
                events: FfiConverterDictionaryStringInt32.read(from: &buf)
        )
    }

    public static func write(_ value: PowerLevels, into buf: inout [UInt8]) {
        FfiConverterOptionInt32.write(value.usersDefault, into: &buf)
        FfiConverterOptionInt32.write(value.eventsDefault, into: &buf)
        FfiConverterOptionInt32.write(value.stateDefault, into: &buf)
        FfiConverterOptionInt32.write(value.ban, into: &buf)
        FfiConverterOptionInt32.write(value.kick, into: &buf)
        FfiConverterOptionInt32.write(value.redact, into: &buf)
        FfiConverterOptionInt32.write(value.invite, into: &buf)
        FfiConverterOptionTypeNotificationPowerLevels.write(value.notifications, into: &buf)
        FfiConverterDictionaryStringInt32.write(value.users, into: &buf)
        FfiConverterDictionaryStringInt32.write(value.events, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePowerLevels_lift(_ buf: RustBuffer) throws -> PowerLevels {
    return try FfiConverterTypePowerLevels.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePowerLevels_lower(_ value: PowerLevels) -> RustBuffer {
    return FfiConverterTypePowerLevels.lower(value)
}


/**
 * When a room A is tombstoned, it is replaced by a room B. The room A is the
 * predecessor of B, and B is the successor of A. This type holds information
 * about the predecessor room. See [`Room::predecessor_room`].
 *
 * To know the predecessor of a room, the [`m.room.create`] state event must
 * have been received.
 *
 * [`m.room.create`]: https://spec.matrix.org/v1.14/client-server-api/#mroomcreate
 */
public struct PredecessorRoom: Equatable, Hashable {
    /**
     * The ID of the replacement room.
     */
    public var roomId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the replacement room.
         */roomId: String) {
        self.roomId = roomId
    }

    

    
}

#if compiler(>=6)
extension PredecessorRoom: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePredecessorRoom: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PredecessorRoom {
        return
            try PredecessorRoom(
                roomId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PredecessorRoom, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePredecessorRoom_lift(_ buf: RustBuffer) throws -> PredecessorRoom {
    return try FfiConverterTypePredecessorRoom.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePredecessorRoom_lower(_ value: PredecessorRoom) -> RustBuffer {
    return FfiConverterTypePredecessorRoom.lower(value)
}


public struct PusherIdentifiers: Equatable, Hashable {
    public var pushkey: String
    public var appId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(pushkey: String, appId: String) {
        self.pushkey = pushkey
        self.appId = appId
    }

    

    
}

#if compiler(>=6)
extension PusherIdentifiers: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePusherIdentifiers: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherIdentifiers {
        return
            try PusherIdentifiers(
                pushkey: FfiConverterString.read(from: &buf), 
                appId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: PusherIdentifiers, into buf: inout [UInt8]) {
        FfiConverterString.write(value.pushkey, into: &buf)
        FfiConverterString.write(value.appId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePusherIdentifiers_lift(_ buf: RustBuffer) throws -> PusherIdentifiers {
    return try FfiConverterTypePusherIdentifiers.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePusherIdentifiers_lower(_ value: PusherIdentifiers) -> RustBuffer {
    return FfiConverterTypePusherIdentifiers.lower(value)
}


public struct Reaction: Equatable, Hashable {
    public var key: String
    public var senders: [ReactionSenderData]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(key: String, senders: [ReactionSenderData]) {
        self.key = key
        self.senders = senders
    }

    

    
}

#if compiler(>=6)
extension Reaction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReaction: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Reaction {
        return
            try Reaction(
                key: FfiConverterString.read(from: &buf), 
                senders: FfiConverterSequenceTypeReactionSenderData.read(from: &buf)
        )
    }

    public static func write(_ value: Reaction, into buf: inout [UInt8]) {
        FfiConverterString.write(value.key, into: &buf)
        FfiConverterSequenceTypeReactionSenderData.write(value.senders, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReaction_lift(_ buf: RustBuffer) throws -> Reaction {
    return try FfiConverterTypeReaction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReaction_lower(_ value: Reaction) -> RustBuffer {
    return FfiConverterTypeReaction.lower(value)
}


public struct ReactionSenderData: Equatable, Hashable {
    public var senderId: String
    public var timestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(senderId: String, timestamp: Timestamp) {
        self.senderId = senderId
        self.timestamp = timestamp
    }

    

    
}

#if compiler(>=6)
extension ReactionSenderData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReactionSenderData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReactionSenderData {
        return
            try ReactionSenderData(
                senderId: FfiConverterString.read(from: &buf), 
                timestamp: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: ReactionSenderData, into buf: inout [UInt8]) {
        FfiConverterString.write(value.senderId, into: &buf)
        FfiConverterTypeTimestamp.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReactionSenderData_lift(_ buf: RustBuffer) throws -> ReactionSenderData {
    return try FfiConverterTypeReactionSenderData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReactionSenderData_lower(_ value: ReactionSenderData) -> RustBuffer {
    return FfiConverterTypeReactionSenderData.lower(value)
}


public struct Receipt: Equatable, Hashable {
    public var timestamp: Timestamp?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(timestamp: Timestamp?) {
        self.timestamp = timestamp
    }

    

    
}

#if compiler(>=6)
extension Receipt: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceipt: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Receipt {
        return
            try Receipt(
                timestamp: FfiConverterOptionTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: Receipt, into buf: inout [UInt8]) {
        FfiConverterOptionTypeTimestamp.write(value.timestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceipt_lift(_ buf: RustBuffer) throws -> Receipt {
    return try FfiConverterTypeReceipt.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceipt_lower(_ value: Receipt) -> RustBuffer {
    return FfiConverterTypeReceipt.lower(value)
}


/**
 * Represents an emoji recently used for reactions.
 */
public struct RecentEmoji: Equatable, Hashable {
    /**
     * The actual emoji text representation.
     */
    public var emoji: String
    /**
     * The number of times this emoji has been used for reactions.
     */
    public var count: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The actual emoji text representation.
         */emoji: String, 
        /**
         * The number of times this emoji has been used for reactions.
         */count: UInt64) {
        self.emoji = emoji
        self.count = count
    }

    

    
}

#if compiler(>=6)
extension RecentEmoji: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecentEmoji: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecentEmoji {
        return
            try RecentEmoji(
                emoji: FfiConverterString.read(from: &buf), 
                count: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RecentEmoji, into buf: inout [UInt8]) {
        FfiConverterString.write(value.emoji, into: &buf)
        FfiConverterUInt64.write(value.count, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecentEmoji_lift(_ buf: RustBuffer) throws -> RecentEmoji {
    return try FfiConverterTypeRecentEmoji.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecentEmoji_lower(_ value: RecentEmoji) -> RustBuffer {
    return FfiConverterTypeRecentEmoji.lower(value)
}


/**
 * The config to use for HTTP requests by default in this client.
 */
public struct RequestConfig: Equatable, Hashable {
    /**
     * Max number of retries.
     */
    public var retryLimit: UInt64?
    /**
     * Timeout for a request in milliseconds.
     */
    public var timeout: UInt64?
    /**
     * Max number of concurrent requests. No value means no limits.
     */
    public var maxConcurrentRequests: UInt64?
    /**
     * Base delay between retries.
     */
    public var maxRetryTime: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Max number of retries.
         */retryLimit: UInt64?, 
        /**
         * Timeout for a request in milliseconds.
         */timeout: UInt64?, 
        /**
         * Max number of concurrent requests. No value means no limits.
         */maxConcurrentRequests: UInt64?, 
        /**
         * Base delay between retries.
         */maxRetryTime: UInt64?) {
        self.retryLimit = retryLimit
        self.timeout = timeout
        self.maxConcurrentRequests = maxConcurrentRequests
        self.maxRetryTime = maxRetryTime
    }

    

    
}

#if compiler(>=6)
extension RequestConfig: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRequestConfig: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RequestConfig {
        return
            try RequestConfig(
                retryLimit: FfiConverterOptionUInt64.read(from: &buf), 
                timeout: FfiConverterOptionUInt64.read(from: &buf), 
                maxConcurrentRequests: FfiConverterOptionUInt64.read(from: &buf), 
                maxRetryTime: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RequestConfig, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.retryLimit, into: &buf)
        FfiConverterOptionUInt64.write(value.timeout, into: &buf)
        FfiConverterOptionUInt64.write(value.maxConcurrentRequests, into: &buf)
        FfiConverterOptionUInt64.write(value.maxRetryTime, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestConfig_lift(_ buf: RustBuffer) throws -> RequestConfig {
    return try FfiConverterTypeRequestConfig.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRequestConfig_lower(_ value: RequestConfig) -> RustBuffer {
    return FfiConverterTypeRequestConfig.lower(value)
}


/**
 * Information about a room, that was resolved from a room alias.
 */
public struct ResolvedRoomAlias: Equatable, Hashable {
    /**
     * The room ID that the alias resolved to.
     */
    public var roomId: String
    /**
     * A list of servers that can be used to find the room by its room ID.
     */
    public var servers: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The room ID that the alias resolved to.
         */roomId: String, 
        /**
         * A list of servers that can be used to find the room by its room ID.
         */servers: [String]) {
        self.roomId = roomId
        self.servers = servers
    }

    

    
}

#if compiler(>=6)
extension ResolvedRoomAlias: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeResolvedRoomAlias: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ResolvedRoomAlias {
        return
            try ResolvedRoomAlias(
                roomId: FfiConverterString.read(from: &buf), 
                servers: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: ResolvedRoomAlias, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterSequenceString.write(value.servers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResolvedRoomAlias_lift(_ buf: RustBuffer) throws -> ResolvedRoomAlias {
    return try FfiConverterTypeResolvedRoomAlias.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeResolvedRoomAlias_lower(_ value: ResolvedRoomAlias) -> RustBuffer {
    return FfiConverterTypeResolvedRoomAlias.lower(value)
}


public struct RoomDescription: Equatable, Hashable {
    public var roomId: String
    public var name: String?
    public var topic: String?
    public var alias: String?
    public var avatarUrl: String?
    public var joinRule: PublicRoomJoinRule?
    public var isWorldReadable: Bool
    public var joinedMembers: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(roomId: String, name: String?, topic: String?, alias: String?, avatarUrl: String?, joinRule: PublicRoomJoinRule?, isWorldReadable: Bool, joinedMembers: UInt64) {
        self.roomId = roomId
        self.name = name
        self.topic = topic
        self.alias = alias
        self.avatarUrl = avatarUrl
        self.joinRule = joinRule
        self.isWorldReadable = isWorldReadable
        self.joinedMembers = joinedMembers
    }

    

    
}

#if compiler(>=6)
extension RoomDescription: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomDescription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDescription {
        return
            try RoomDescription(
                roomId: FfiConverterString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                alias: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                joinRule: FfiConverterOptionTypePublicRoomJoinRule.read(from: &buf), 
                isWorldReadable: FfiConverterBool.read(from: &buf), 
                joinedMembers: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomDescription, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.alias, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterOptionTypePublicRoomJoinRule.write(value.joinRule, into: &buf)
        FfiConverterBool.write(value.isWorldReadable, into: &buf)
        FfiConverterUInt64.write(value.joinedMembers, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDescription_lift(_ buf: RustBuffer) throws -> RoomDescription {
    return try FfiConverterTypeRoomDescription.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDescription_lower(_ value: RoomDescription) -> RustBuffer {
    return FfiConverterTypeRoomDescription.lower(value)
}


/**
 * Information about a member considered to be a room hero.
 */
public struct RoomHero: Equatable, Hashable {
    /**
     * The user ID of the hero.
     */
    public var userId: String
    /**
     * The display name of the hero.
     */
    public var displayName: String?
    /**
     * The avatar URL of the hero.
     */
    public var avatarUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user ID of the hero.
         */userId: String, 
        /**
         * The display name of the hero.
         */displayName: String?, 
        /**
         * The avatar URL of the hero.
         */avatarUrl: String?) {
        self.userId = userId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
    }

    

    
}

#if compiler(>=6)
extension RoomHero: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomHero: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomHero {
        return
            try RoomHero(
                userId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RoomHero, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomHero_lift(_ buf: RustBuffer) throws -> RoomHero {
    return try FfiConverterTypeRoomHero.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomHero_lower(_ value: RoomHero) -> RustBuffer {
    return FfiConverterTypeRoomHero.lower(value)
}


public struct RoomInfo {
    public var id: String
    public var encryptionState: EncryptionState
    public var creators: [String]?
    /**
     * The room's name from the room state event if received from sync, or one
     * that's been computed otherwise.
     */
    public var displayName: String?
    /**
     * Room name as defined by the room state event only.
     */
    public var rawName: String?
    public var topic: String?
    public var avatarUrl: String?
    public var isDirect: Bool
    /**
     * Whether the room is public or not, based on the join rules.
     *
     * Can be `None` if the join rules state event is not available for this
     * room.
     */
    public var isPublic: Bool?
    public var isSpace: Bool
    /**
     * If present, it means the room has been archived/upgraded.
     */
    public var successorRoom: SuccessorRoom?
    public var isFavourite: Bool
    public var canonicalAlias: String?
    public var alternativeAliases: [String]
    public var membership: Membership
    /**
     * Member who invited the current user to a room that's in the invited
     * state.
     *
     * Can be missing if the room membership invite event is missing from the
     * store.
     */
    public var inviter: RoomMember?
    public var heroes: [RoomHero]
    public var activeMembersCount: UInt64
    public var invitedMembersCount: UInt64
    public var joinedMembersCount: UInt64
    public var highlightCount: UInt64
    public var notificationCount: UInt64
    public var cachedUserDefinedNotificationMode: RoomNotificationMode?
    public var hasRoomCall: Bool
    public var activeRoomCallParticipants: [String]
    /**
     * Whether this room has been explicitly marked as unread
     */
    public var isMarkedUnread: Bool
    /**
     * "Interesting" messages received in that room, independently of the
     * notification settings.
     */
    public var numUnreadMessages: UInt64
    /**
     * Events that will notify the user, according to their
     * notification settings.
     */
    public var numUnreadNotifications: UInt64
    /**
     * Events causing mentions/highlights for the user, according to their
     * notification settings.
     */
    public var numUnreadMentions: UInt64
    /**
     * The currently pinned event ids.
     */
    public var pinnedEventIds: [String]
    /**
     * The join rule for this room, if known.
     */
    public var joinRule: JoinRule?
    /**
     * The history visibility for this room, if known.
     */
    public var historyVisibility: RoomHistoryVisibility
    /**
     * This room's current power levels.
     *
     * Can be missing if the room power levels event is missing from the store.
     */
    public var powerLevels: RoomPowerLevels?
    /**
     * This room's version.
     */
    public var roomVersion: String?
    /**
     * Whether creators are privileged over every other user (have infinite
     * power level).
     */
    public var privilegedCreatorsRole: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String, encryptionState: EncryptionState, creators: [String]?, 
        /**
         * The room's name from the room state event if received from sync, or one
         * that's been computed otherwise.
         */displayName: String?, 
        /**
         * Room name as defined by the room state event only.
         */rawName: String?, topic: String?, avatarUrl: String?, isDirect: Bool, 
        /**
         * Whether the room is public or not, based on the join rules.
         *
         * Can be `None` if the join rules state event is not available for this
         * room.
         */isPublic: Bool?, isSpace: Bool, 
        /**
         * If present, it means the room has been archived/upgraded.
         */successorRoom: SuccessorRoom?, isFavourite: Bool, canonicalAlias: String?, alternativeAliases: [String], membership: Membership, 
        /**
         * Member who invited the current user to a room that's in the invited
         * state.
         *
         * Can be missing if the room membership invite event is missing from the
         * store.
         */inviter: RoomMember?, heroes: [RoomHero], activeMembersCount: UInt64, invitedMembersCount: UInt64, joinedMembersCount: UInt64, highlightCount: UInt64, notificationCount: UInt64, cachedUserDefinedNotificationMode: RoomNotificationMode?, hasRoomCall: Bool, activeRoomCallParticipants: [String], 
        /**
         * Whether this room has been explicitly marked as unread
         */isMarkedUnread: Bool, 
        /**
         * "Interesting" messages received in that room, independently of the
         * notification settings.
         */numUnreadMessages: UInt64, 
        /**
         * Events that will notify the user, according to their
         * notification settings.
         */numUnreadNotifications: UInt64, 
        /**
         * Events causing mentions/highlights for the user, according to their
         * notification settings.
         */numUnreadMentions: UInt64, 
        /**
         * The currently pinned event ids.
         */pinnedEventIds: [String], 
        /**
         * The join rule for this room, if known.
         */joinRule: JoinRule?, 
        /**
         * The history visibility for this room, if known.
         */historyVisibility: RoomHistoryVisibility, 
        /**
         * This room's current power levels.
         *
         * Can be missing if the room power levels event is missing from the store.
         */powerLevels: RoomPowerLevels?, 
        /**
         * This room's version.
         */roomVersion: String?, 
        /**
         * Whether creators are privileged over every other user (have infinite
         * power level).
         */privilegedCreatorsRole: Bool) {
        self.id = id
        self.encryptionState = encryptionState
        self.creators = creators
        self.displayName = displayName
        self.rawName = rawName
        self.topic = topic
        self.avatarUrl = avatarUrl
        self.isDirect = isDirect
        self.isPublic = isPublic
        self.isSpace = isSpace
        self.successorRoom = successorRoom
        self.isFavourite = isFavourite
        self.canonicalAlias = canonicalAlias
        self.alternativeAliases = alternativeAliases
        self.membership = membership
        self.inviter = inviter
        self.heroes = heroes
        self.activeMembersCount = activeMembersCount
        self.invitedMembersCount = invitedMembersCount
        self.joinedMembersCount = joinedMembersCount
        self.highlightCount = highlightCount
        self.notificationCount = notificationCount
        self.cachedUserDefinedNotificationMode = cachedUserDefinedNotificationMode
        self.hasRoomCall = hasRoomCall
        self.activeRoomCallParticipants = activeRoomCallParticipants
        self.isMarkedUnread = isMarkedUnread
        self.numUnreadMessages = numUnreadMessages
        self.numUnreadNotifications = numUnreadNotifications
        self.numUnreadMentions = numUnreadMentions
        self.pinnedEventIds = pinnedEventIds
        self.joinRule = joinRule
        self.historyVisibility = historyVisibility
        self.powerLevels = powerLevels
        self.roomVersion = roomVersion
        self.privilegedCreatorsRole = privilegedCreatorsRole
    }

    

    
}

#if compiler(>=6)
extension RoomInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomInfo {
        return
            try RoomInfo(
                id: FfiConverterString.read(from: &buf), 
                encryptionState: FfiConverterTypeEncryptionState.read(from: &buf), 
                creators: FfiConverterOptionSequenceString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                rawName: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                isDirect: FfiConverterBool.read(from: &buf), 
                isPublic: FfiConverterOptionBool.read(from: &buf), 
                isSpace: FfiConverterBool.read(from: &buf), 
                successorRoom: FfiConverterOptionTypeSuccessorRoom.read(from: &buf), 
                isFavourite: FfiConverterBool.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf), 
                alternativeAliases: FfiConverterSequenceString.read(from: &buf), 
                membership: FfiConverterTypeMembership.read(from: &buf), 
                inviter: FfiConverterOptionTypeRoomMember.read(from: &buf), 
                heroes: FfiConverterSequenceTypeRoomHero.read(from: &buf), 
                activeMembersCount: FfiConverterUInt64.read(from: &buf), 
                invitedMembersCount: FfiConverterUInt64.read(from: &buf), 
                joinedMembersCount: FfiConverterUInt64.read(from: &buf), 
                highlightCount: FfiConverterUInt64.read(from: &buf), 
                notificationCount: FfiConverterUInt64.read(from: &buf), 
                cachedUserDefinedNotificationMode: FfiConverterOptionTypeRoomNotificationMode.read(from: &buf), 
                hasRoomCall: FfiConverterBool.read(from: &buf), 
                activeRoomCallParticipants: FfiConverterSequenceString.read(from: &buf), 
                isMarkedUnread: FfiConverterBool.read(from: &buf), 
                numUnreadMessages: FfiConverterUInt64.read(from: &buf), 
                numUnreadNotifications: FfiConverterUInt64.read(from: &buf), 
                numUnreadMentions: FfiConverterUInt64.read(from: &buf), 
                pinnedEventIds: FfiConverterSequenceString.read(from: &buf), 
                joinRule: FfiConverterOptionTypeJoinRule.read(from: &buf), 
                historyVisibility: FfiConverterTypeRoomHistoryVisibility.read(from: &buf), 
                powerLevels: FfiConverterOptionTypeRoomPowerLevels.read(from: &buf), 
                roomVersion: FfiConverterOptionString.read(from: &buf), 
                privilegedCreatorsRole: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RoomInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
        FfiConverterTypeEncryptionState.write(value.encryptionState, into: &buf)
        FfiConverterOptionSequenceString.write(value.creators, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.rawName, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterBool.write(value.isDirect, into: &buf)
        FfiConverterOptionBool.write(value.isPublic, into: &buf)
        FfiConverterBool.write(value.isSpace, into: &buf)
        FfiConverterOptionTypeSuccessorRoom.write(value.successorRoom, into: &buf)
        FfiConverterBool.write(value.isFavourite, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterSequenceString.write(value.alternativeAliases, into: &buf)
        FfiConverterTypeMembership.write(value.membership, into: &buf)
        FfiConverterOptionTypeRoomMember.write(value.inviter, into: &buf)
        FfiConverterSequenceTypeRoomHero.write(value.heroes, into: &buf)
        FfiConverterUInt64.write(value.activeMembersCount, into: &buf)
        FfiConverterUInt64.write(value.invitedMembersCount, into: &buf)
        FfiConverterUInt64.write(value.joinedMembersCount, into: &buf)
        FfiConverterUInt64.write(value.highlightCount, into: &buf)
        FfiConverterUInt64.write(value.notificationCount, into: &buf)
        FfiConverterOptionTypeRoomNotificationMode.write(value.cachedUserDefinedNotificationMode, into: &buf)
        FfiConverterBool.write(value.hasRoomCall, into: &buf)
        FfiConverterSequenceString.write(value.activeRoomCallParticipants, into: &buf)
        FfiConverterBool.write(value.isMarkedUnread, into: &buf)
        FfiConverterUInt64.write(value.numUnreadMessages, into: &buf)
        FfiConverterUInt64.write(value.numUnreadNotifications, into: &buf)
        FfiConverterUInt64.write(value.numUnreadMentions, into: &buf)
        FfiConverterSequenceString.write(value.pinnedEventIds, into: &buf)
        FfiConverterOptionTypeJoinRule.write(value.joinRule, into: &buf)
        FfiConverterTypeRoomHistoryVisibility.write(value.historyVisibility, into: &buf)
        FfiConverterOptionTypeRoomPowerLevels.write(value.powerLevels, into: &buf)
        FfiConverterOptionString.write(value.roomVersion, into: &buf)
        FfiConverterBool.write(value.privilegedCreatorsRole, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomInfo_lift(_ buf: RustBuffer) throws -> RoomInfo {
    return try FfiConverterTypeRoomInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomInfo_lower(_ value: RoomInfo) -> RustBuffer {
    return FfiConverterTypeRoomInfo.lower(value)
}


public struct RoomListLoadingStateResult {
    public var state: RoomListLoadingState
    public var stateStream: TaskHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(state: RoomListLoadingState, stateStream: TaskHandle) {
        self.state = state
        self.stateStream = stateStream
    }

    

    
}

#if compiler(>=6)
extension RoomListLoadingStateResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListLoadingStateResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListLoadingStateResult {
        return
            try RoomListLoadingStateResult(
                state: FfiConverterTypeRoomListLoadingState.read(from: &buf), 
                stateStream: FfiConverterTypeTaskHandle.read(from: &buf)
        )
    }

    public static func write(_ value: RoomListLoadingStateResult, into buf: inout [UInt8]) {
        FfiConverterTypeRoomListLoadingState.write(value.state, into: &buf)
        FfiConverterTypeTaskHandle.write(value.stateStream, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListLoadingStateResult_lift(_ buf: RustBuffer) throws -> RoomListLoadingStateResult {
    return try FfiConverterTypeRoomListLoadingStateResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListLoadingStateResult_lower(_ value: RoomListLoadingStateResult) -> RustBuffer {
    return FfiConverterTypeRoomListLoadingStateResult.lower(value)
}


public struct RoomMember: Equatable, Hashable {
    public var userId: String
    public var displayName: String?
    public var avatarUrl: String?
    public var membership: MembershipState
    public var isNameAmbiguous: Bool
    public var powerLevel: PowerLevel
    public var isIgnored: Bool
    public var suggestedRoleForPowerLevel: RoomMemberRole
    public var membershipChangeReason: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, displayName: String?, avatarUrl: String?, membership: MembershipState, isNameAmbiguous: Bool, powerLevel: PowerLevel, isIgnored: Bool, suggestedRoleForPowerLevel: RoomMemberRole, membershipChangeReason: String?) {
        self.userId = userId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
        self.membership = membership
        self.isNameAmbiguous = isNameAmbiguous
        self.powerLevel = powerLevel
        self.isIgnored = isIgnored
        self.suggestedRoleForPowerLevel = suggestedRoleForPowerLevel
        self.membershipChangeReason = membershipChangeReason
    }

    

    
}

#if compiler(>=6)
extension RoomMember: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomMember: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMember {
        return
            try RoomMember(
                userId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                membership: FfiConverterTypeMembershipState.read(from: &buf), 
                isNameAmbiguous: FfiConverterBool.read(from: &buf), 
                powerLevel: FfiConverterTypePowerLevel.read(from: &buf), 
                isIgnored: FfiConverterBool.read(from: &buf), 
                suggestedRoleForPowerLevel: FfiConverterTypeRoomMemberRole.read(from: &buf), 
                membershipChangeReason: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: RoomMember, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterTypeMembershipState.write(value.membership, into: &buf)
        FfiConverterBool.write(value.isNameAmbiguous, into: &buf)
        FfiConverterTypePowerLevel.write(value.powerLevel, into: &buf)
        FfiConverterBool.write(value.isIgnored, into: &buf)
        FfiConverterTypeRoomMemberRole.write(value.suggestedRoleForPowerLevel, into: &buf)
        FfiConverterOptionString.write(value.membershipChangeReason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMember_lift(_ buf: RustBuffer) throws -> RoomMember {
    return try FfiConverterTypeRoomMember.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMember_lower(_ value: RoomMember) -> RustBuffer {
    return FfiConverterTypeRoomMember.lower(value)
}


/**
 * Contains the current user's room member info and the optional room member
 * info of the sender of the `m.room.member` event that this info represents.
 */
public struct RoomMemberWithSenderInfo: Equatable, Hashable {
    /**
     * The room member.
     */
    public var roomMember: RoomMember
    /**
     * The info of the sender of the event `room_member` is based on, if
     * available.
     */
    public var senderInfo: RoomMember?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The room member.
         */roomMember: RoomMember, 
        /**
         * The info of the sender of the event `room_member` is based on, if
         * available.
         */senderInfo: RoomMember?) {
        self.roomMember = roomMember
        self.senderInfo = senderInfo
    }

    

    
}

#if compiler(>=6)
extension RoomMemberWithSenderInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomMemberWithSenderInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMemberWithSenderInfo {
        return
            try RoomMemberWithSenderInfo(
                roomMember: FfiConverterTypeRoomMember.read(from: &buf), 
                senderInfo: FfiConverterOptionTypeRoomMember.read(from: &buf)
        )
    }

    public static func write(_ value: RoomMemberWithSenderInfo, into buf: inout [UInt8]) {
        FfiConverterTypeRoomMember.write(value.roomMember, into: &buf)
        FfiConverterOptionTypeRoomMember.write(value.senderInfo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMemberWithSenderInfo_lift(_ buf: RustBuffer) throws -> RoomMemberWithSenderInfo {
    return try FfiConverterTypeRoomMemberWithSenderInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMemberWithSenderInfo_lower(_ value: RoomMemberWithSenderInfo) -> RustBuffer {
    return FfiConverterTypeRoomMemberWithSenderInfo.lower(value)
}


/**
 * `RoomNotificationSettings` represents the current settings for a `Room`
 */
public struct RoomNotificationSettings: Equatable, Hashable {
    /**
     * The room notification mode
     */
    public var mode: RoomNotificationMode
    /**
     * Whether the mode is the default one
     */
    public var isDefault: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The room notification mode
         */mode: RoomNotificationMode, 
        /**
         * Whether the mode is the default one
         */isDefault: Bool) {
        self.mode = mode
        self.isDefault = isDefault
    }

    

    
}

#if compiler(>=6)
extension RoomNotificationSettings: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomNotificationSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomNotificationSettings {
        return
            try RoomNotificationSettings(
                mode: FfiConverterTypeRoomNotificationMode.read(from: &buf), 
                isDefault: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: RoomNotificationSettings, into buf: inout [UInt8]) {
        FfiConverterTypeRoomNotificationMode.write(value.mode, into: &buf)
        FfiConverterBool.write(value.isDefault, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomNotificationSettings_lift(_ buf: RustBuffer) throws -> RoomNotificationSettings {
    return try FfiConverterTypeRoomNotificationSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomNotificationSettings_lower(_ value: RoomNotificationSettings) -> RustBuffer {
    return FfiConverterTypeRoomNotificationSettings.lower(value)
}


/**
 * This intermediary struct is used to expose the power levels values through
 * FFI and work around it not exposing public exported object fields.
 */
public struct RoomPowerLevelsValues: Equatable, Hashable {
    /**
     * The level required to ban a user.
     */
    public var ban: Int64
    /**
     * The level required to invite a user.
     */
    public var invite: Int64
    /**
     * The level required to kick a user.
     */
    public var kick: Int64
    /**
     * The level required to redact an event.
     */
    public var redact: Int64
    /**
     * The default level required to send message events.
     */
    public var eventsDefault: Int64
    /**
     * The default level required to send state events.
     */
    public var stateDefault: Int64
    /**
     * The default power level for every user in the room.
     */
    public var usersDefault: Int64
    /**
     * The level required to change the room's name.
     */
    public var roomName: Int64
    /**
     * The level required to change the room's avatar.
     */
    public var roomAvatar: Int64
    /**
     * The level required to change the room's topic.
     */
    public var roomTopic: Int64
    /**
     * The level required to change the space's children.
     */
    public var spaceChild: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The level required to ban a user.
         */ban: Int64, 
        /**
         * The level required to invite a user.
         */invite: Int64, 
        /**
         * The level required to kick a user.
         */kick: Int64, 
        /**
         * The level required to redact an event.
         */redact: Int64, 
        /**
         * The default level required to send message events.
         */eventsDefault: Int64, 
        /**
         * The default level required to send state events.
         */stateDefault: Int64, 
        /**
         * The default power level for every user in the room.
         */usersDefault: Int64, 
        /**
         * The level required to change the room's name.
         */roomName: Int64, 
        /**
         * The level required to change the room's avatar.
         */roomAvatar: Int64, 
        /**
         * The level required to change the room's topic.
         */roomTopic: Int64, 
        /**
         * The level required to change the space's children.
         */spaceChild: Int64) {
        self.ban = ban
        self.invite = invite
        self.kick = kick
        self.redact = redact
        self.eventsDefault = eventsDefault
        self.stateDefault = stateDefault
        self.usersDefault = usersDefault
        self.roomName = roomName
        self.roomAvatar = roomAvatar
        self.roomTopic = roomTopic
        self.spaceChild = spaceChild
    }

    

    
}

#if compiler(>=6)
extension RoomPowerLevelsValues: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomPowerLevelsValues: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPowerLevelsValues {
        return
            try RoomPowerLevelsValues(
                ban: FfiConverterInt64.read(from: &buf), 
                invite: FfiConverterInt64.read(from: &buf), 
                kick: FfiConverterInt64.read(from: &buf), 
                redact: FfiConverterInt64.read(from: &buf), 
                eventsDefault: FfiConverterInt64.read(from: &buf), 
                stateDefault: FfiConverterInt64.read(from: &buf), 
                usersDefault: FfiConverterInt64.read(from: &buf), 
                roomName: FfiConverterInt64.read(from: &buf), 
                roomAvatar: FfiConverterInt64.read(from: &buf), 
                roomTopic: FfiConverterInt64.read(from: &buf), 
                spaceChild: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: RoomPowerLevelsValues, into buf: inout [UInt8]) {
        FfiConverterInt64.write(value.ban, into: &buf)
        FfiConverterInt64.write(value.invite, into: &buf)
        FfiConverterInt64.write(value.kick, into: &buf)
        FfiConverterInt64.write(value.redact, into: &buf)
        FfiConverterInt64.write(value.eventsDefault, into: &buf)
        FfiConverterInt64.write(value.stateDefault, into: &buf)
        FfiConverterInt64.write(value.usersDefault, into: &buf)
        FfiConverterInt64.write(value.roomName, into: &buf)
        FfiConverterInt64.write(value.roomAvatar, into: &buf)
        FfiConverterInt64.write(value.roomTopic, into: &buf)
        FfiConverterInt64.write(value.spaceChild, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPowerLevelsValues_lift(_ buf: RustBuffer) throws -> RoomPowerLevelsValues {
    return try FfiConverterTypeRoomPowerLevelsValues.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPowerLevelsValues_lower(_ value: RoomPowerLevelsValues) -> RustBuffer {
    return FfiConverterTypeRoomPowerLevelsValues.lower(value)
}


/**
 * The preview of a room, be it invited/joined/left, or not.
 */
public struct RoomPreviewInfo: Equatable, Hashable {
    /**
     * The room id for this room.
     */
    public var roomId: String
    /**
     * The canonical alias for the room.
     */
    public var canonicalAlias: String?
    /**
     * The room's name, if set.
     */
    public var name: String?
    /**
     * The room's topic, if set.
     */
    public var topic: String?
    /**
     * The MXC URI to the room's avatar, if set.
     */
    public var avatarUrl: String?
    /**
     * The number of joined members.
     */
    public var numJoinedMembers: UInt64
    /**
     * The number of active members, if known (joined + invited).
     */
    public var numActiveMembers: UInt64?
    /**
     * The room type (space, custom) or nothing, if it's a regular room.
     */
    public var roomType: RoomType
    /**
     * Is the history world-readable for this room?
     */
    public var isHistoryWorldReadable: Bool?
    /**
     * The membership state for the current user, if known.
     */
    public var membership: Membership?
    /**
     * The join rule for this room (private, public, knock, etc.).
     */
    public var joinRule: JoinRule?
    /**
     * Whether the room is direct or not, if known.
     */
    public var isDirect: Bool?
    /**
     * Room heroes.
     */
    public var heroes: [RoomHero]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The room id for this room.
         */roomId: String, 
        /**
         * The canonical alias for the room.
         */canonicalAlias: String?, 
        /**
         * The room's name, if set.
         */name: String?, 
        /**
         * The room's topic, if set.
         */topic: String?, 
        /**
         * The MXC URI to the room's avatar, if set.
         */avatarUrl: String?, 
        /**
         * The number of joined members.
         */numJoinedMembers: UInt64, 
        /**
         * The number of active members, if known (joined + invited).
         */numActiveMembers: UInt64?, 
        /**
         * The room type (space, custom) or nothing, if it's a regular room.
         */roomType: RoomType, 
        /**
         * Is the history world-readable for this room?
         */isHistoryWorldReadable: Bool?, 
        /**
         * The membership state for the current user, if known.
         */membership: Membership?, 
        /**
         * The join rule for this room (private, public, knock, etc.).
         */joinRule: JoinRule?, 
        /**
         * Whether the room is direct or not, if known.
         */isDirect: Bool?, 
        /**
         * Room heroes.
         */heroes: [RoomHero]?) {
        self.roomId = roomId
        self.canonicalAlias = canonicalAlias
        self.name = name
        self.topic = topic
        self.avatarUrl = avatarUrl
        self.numJoinedMembers = numJoinedMembers
        self.numActiveMembers = numActiveMembers
        self.roomType = roomType
        self.isHistoryWorldReadable = isHistoryWorldReadable
        self.membership = membership
        self.joinRule = joinRule
        self.isDirect = isDirect
        self.heroes = heroes
    }

    

    
}

#if compiler(>=6)
extension RoomPreviewInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomPreviewInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreviewInfo {
        return
            try RoomPreviewInfo(
                roomId: FfiConverterString.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf), 
                name: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                numJoinedMembers: FfiConverterUInt64.read(from: &buf), 
                numActiveMembers: FfiConverterOptionUInt64.read(from: &buf), 
                roomType: FfiConverterTypeRoomType.read(from: &buf), 
                isHistoryWorldReadable: FfiConverterOptionBool.read(from: &buf), 
                membership: FfiConverterOptionTypeMembership.read(from: &buf), 
                joinRule: FfiConverterOptionTypeJoinRule.read(from: &buf), 
                isDirect: FfiConverterOptionBool.read(from: &buf), 
                heroes: FfiConverterOptionSequenceTypeRoomHero.read(from: &buf)
        )
    }

    public static func write(_ value: RoomPreviewInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterUInt64.write(value.numJoinedMembers, into: &buf)
        FfiConverterOptionUInt64.write(value.numActiveMembers, into: &buf)
        FfiConverterTypeRoomType.write(value.roomType, into: &buf)
        FfiConverterOptionBool.write(value.isHistoryWorldReadable, into: &buf)
        FfiConverterOptionTypeMembership.write(value.membership, into: &buf)
        FfiConverterOptionTypeJoinRule.write(value.joinRule, into: &buf)
        FfiConverterOptionBool.write(value.isDirect, into: &buf)
        FfiConverterOptionSequenceTypeRoomHero.write(value.heroes, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPreviewInfo_lift(_ buf: RustBuffer) throws -> RoomPreviewInfo {
    return try FfiConverterTypeRoomPreviewInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPreviewInfo_lower(_ value: RoomPreviewInfo) -> RustBuffer {
    return FfiConverterTypeRoomPreviewInfo.lower(value)
}


/**
 * A push ruleset scopes a set of rules according to some criteria.
 */
public struct Ruleset: Equatable, Hashable {
    /**
     * These rules configure behavior for (unencrypted) messages that match
     * certain patterns.
     */
    public var content: [PatternedPushRule]
    /**
     * These user-configured rules are given the highest priority.
     *
     * This field is named `override_` instead of `override` because the latter
     * is a reserved keyword in Rust.
     */
    public var override: [ConditionalPushRule]
    /**
     * These rules change the behavior of all messages for a given room.
     */
    public var room: [SimplePushRule]
    /**
     * These rules configure notification behavior for messages from a specific
     * Matrix user ID.
     */
    public var sender: [SimplePushRule]
    /**
     * These rules are identical to override rules, but have a lower priority
     * than `content`, `room` and `sender` rules.
     */
    public var underride: [ConditionalPushRule]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * These rules configure behavior for (unencrypted) messages that match
         * certain patterns.
         */content: [PatternedPushRule], 
        /**
         * These user-configured rules are given the highest priority.
         *
         * This field is named `override_` instead of `override` because the latter
         * is a reserved keyword in Rust.
         */override: [ConditionalPushRule], 
        /**
         * These rules change the behavior of all messages for a given room.
         */room: [SimplePushRule], 
        /**
         * These rules configure notification behavior for messages from a specific
         * Matrix user ID.
         */sender: [SimplePushRule], 
        /**
         * These rules are identical to override rules, but have a lower priority
         * than `content`, `room` and `sender` rules.
         */underride: [ConditionalPushRule]) {
        self.content = content
        self.override = override
        self.room = room
        self.sender = sender
        self.underride = underride
    }

    

    
}

#if compiler(>=6)
extension Ruleset: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRuleset: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Ruleset {
        return
            try Ruleset(
                content: FfiConverterSequenceTypePatternedPushRule.read(from: &buf), 
                override: FfiConverterSequenceTypeConditionalPushRule.read(from: &buf), 
                room: FfiConverterSequenceTypeSimplePushRule.read(from: &buf), 
                sender: FfiConverterSequenceTypeSimplePushRule.read(from: &buf), 
                underride: FfiConverterSequenceTypeConditionalPushRule.read(from: &buf)
        )
    }

    public static func write(_ value: Ruleset, into buf: inout [UInt8]) {
        FfiConverterSequenceTypePatternedPushRule.write(value.content, into: &buf)
        FfiConverterSequenceTypeConditionalPushRule.write(value.override, into: &buf)
        FfiConverterSequenceTypeSimplePushRule.write(value.room, into: &buf)
        FfiConverterSequenceTypeSimplePushRule.write(value.sender, into: &buf)
        FfiConverterSequenceTypeConditionalPushRule.write(value.underride, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRuleset_lift(_ buf: RustBuffer) throws -> Ruleset {
    return try FfiConverterTypeRuleset.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRuleset_lower(_ value: Ruleset) -> RustBuffer {
    return FfiConverterTypeRuleset.lower(value)
}


public struct SearchUsersResults: Equatable, Hashable {
    public var results: [UserProfile]
    public var limited: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(results: [UserProfile], limited: Bool) {
        self.results = results
        self.limited = limited
    }

    

    
}

#if compiler(>=6)
extension SearchUsersResults: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSearchUsersResults: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SearchUsersResults {
        return
            try SearchUsersResults(
                results: FfiConverterSequenceTypeUserProfile.read(from: &buf), 
                limited: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: SearchUsersResults, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeUserProfile.write(value.results, into: &buf)
        FfiConverterBool.write(value.limited, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchUsersResults_lift(_ buf: RustBuffer) throws -> SearchUsersResults {
    return try FfiConverterTypeSearchUsersResults.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSearchUsersResults_lower(_ value: SearchUsersResults) -> RustBuffer {
    return FfiConverterTypeSearchUsersResults.lower(value)
}


/**
 * The key properties for the `m.secret_storage.v1.aes-hmac-sha2`` algorithm.
 */
public struct SecretStorageV1AesHmacSha2Properties: Equatable, Hashable {
    /**
     * The 16-byte initialization vector, encoded as base64.
     */
    public var iv: String?
    /**
     * The MAC, encoded as base64.
     */
    public var mac: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The 16-byte initialization vector, encoded as base64.
         */iv: String?, 
        /**
         * The MAC, encoded as base64.
         */mac: String?) {
        self.iv = iv
        self.mac = mac
    }

    

    
}

#if compiler(>=6)
extension SecretStorageV1AesHmacSha2Properties: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecretStorageV1AesHmacSha2Properties: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretStorageV1AesHmacSha2Properties {
        return
            try SecretStorageV1AesHmacSha2Properties(
                iv: FfiConverterOptionString.read(from: &buf), 
                mac: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SecretStorageV1AesHmacSha2Properties, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.iv, into: &buf)
        FfiConverterOptionString.write(value.mac, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretStorageV1AesHmacSha2Properties_lift(_ buf: RustBuffer) throws -> SecretStorageV1AesHmacSha2Properties {
    return try FfiConverterTypeSecretStorageV1AesHmacSha2Properties.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretStorageV1AesHmacSha2Properties_lower(_ value: SecretStorageV1AesHmacSha2Properties) -> RustBuffer {
    return FfiConverterTypeSecretStorageV1AesHmacSha2Properties.lower(value)
}


public struct Session: Equatable, Hashable {
    /**
     * The access token used for this session.
     */
    public var accessToken: String
    /**
     * The token used for [refreshing the access token], if any.
     *
     * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
     */
    public var refreshToken: String?
    /**
     * The user the access token was issued for.
     */
    public var userId: String
    /**
     * The ID of the client device.
     */
    public var deviceId: String
    /**
     * The URL for the homeserver used for this session.
     */
    public var homeserverUrl: String
    /**
     * Additional data for this session if OpenID Connect was used for
     * authentication.
     */
    public var oidcData: String?
    /**
     * The sliding sync version used for this session.
     */
    public var slidingSyncVersion: SlidingSyncVersion

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The access token used for this session.
         */accessToken: String, 
        /**
         * The token used for [refreshing the access token], if any.
         *
         * [refreshing the access token]: https://spec.matrix.org/v1.3/client-server-api/#refreshing-access-tokens
         */refreshToken: String?, 
        /**
         * The user the access token was issued for.
         */userId: String, 
        /**
         * The ID of the client device.
         */deviceId: String, 
        /**
         * The URL for the homeserver used for this session.
         */homeserverUrl: String, 
        /**
         * Additional data for this session if OpenID Connect was used for
         * authentication.
         */oidcData: String?, 
        /**
         * The sliding sync version used for this session.
         */slidingSyncVersion: SlidingSyncVersion) {
        self.accessToken = accessToken
        self.refreshToken = refreshToken
        self.userId = userId
        self.deviceId = deviceId
        self.homeserverUrl = homeserverUrl
        self.oidcData = oidcData
        self.slidingSyncVersion = slidingSyncVersion
    }

    

    
}

#if compiler(>=6)
extension Session: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSession: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Session {
        return
            try Session(
                accessToken: FfiConverterString.read(from: &buf), 
                refreshToken: FfiConverterOptionString.read(from: &buf), 
                userId: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                homeserverUrl: FfiConverterString.read(from: &buf), 
                oidcData: FfiConverterOptionString.read(from: &buf), 
                slidingSyncVersion: FfiConverterTypeSlidingSyncVersion.read(from: &buf)
        )
    }

    public static func write(_ value: Session, into buf: inout [UInt8]) {
        FfiConverterString.write(value.accessToken, into: &buf)
        FfiConverterOptionString.write(value.refreshToken, into: &buf)
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterString.write(value.homeserverUrl, into: &buf)
        FfiConverterOptionString.write(value.oidcData, into: &buf)
        FfiConverterTypeSlidingSyncVersion.write(value.slidingSyncVersion, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lift(_ buf: RustBuffer) throws -> Session {
    return try FfiConverterTypeSession.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSession_lower(_ value: Session) -> RustBuffer {
    return FfiConverterTypeSession.lower(value)
}


/**
 * Details about the incoming verification request
 */
public struct SessionVerificationRequestDetails: Equatable, Hashable {
    public var senderProfile: UserProfile
    public var flowId: String
    public var deviceId: String
    public var deviceDisplayName: String?
    /**
     * First time this device was seen in milliseconds since epoch.
     */
    public var firstSeenTimestamp: Timestamp

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(senderProfile: UserProfile, flowId: String, deviceId: String, deviceDisplayName: String?, 
        /**
         * First time this device was seen in milliseconds since epoch.
         */firstSeenTimestamp: Timestamp) {
        self.senderProfile = senderProfile
        self.flowId = flowId
        self.deviceId = deviceId
        self.deviceDisplayName = deviceDisplayName
        self.firstSeenTimestamp = firstSeenTimestamp
    }

    

    
}

#if compiler(>=6)
extension SessionVerificationRequestDetails: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionVerificationRequestDetails: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationRequestDetails {
        return
            try SessionVerificationRequestDetails(
                senderProfile: FfiConverterTypeUserProfile.read(from: &buf), 
                flowId: FfiConverterString.read(from: &buf), 
                deviceId: FfiConverterString.read(from: &buf), 
                deviceDisplayName: FfiConverterOptionString.read(from: &buf), 
                firstSeenTimestamp: FfiConverterTypeTimestamp.read(from: &buf)
        )
    }

    public static func write(_ value: SessionVerificationRequestDetails, into buf: inout [UInt8]) {
        FfiConverterTypeUserProfile.write(value.senderProfile, into: &buf)
        FfiConverterString.write(value.flowId, into: &buf)
        FfiConverterString.write(value.deviceId, into: &buf)
        FfiConverterOptionString.write(value.deviceDisplayName, into: &buf)
        FfiConverterTypeTimestamp.write(value.firstSeenTimestamp, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationRequestDetails_lift(_ buf: RustBuffer) throws -> SessionVerificationRequestDetails {
    return try FfiConverterTypeSessionVerificationRequestDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationRequestDetails_lower(_ value: SessionVerificationRequestDetails) -> RustBuffer {
    return FfiConverterTypeSessionVerificationRequestDetails.lower(value)
}


/**
 * A push rule is a single rule that states under what conditions an event
 * should be passed onto a push gateway and how the notification should be
 * presented.
 */
public struct SimplePushRule: Equatable, Hashable {
    /**
     * Actions to determine if and how a notification is delivered for events
     * matching this rule.
     */
    public var actions: [Action]
    /**
     * Whether this is a default rule, or has been set explicitly.
     */
    public var `default`: Bool
    /**
     * Whether the push rule is enabled or not.
     */
    public var enabled: Bool
    /**
     * The ID of this rule.
     *
     * This is generally the Matrix ID of the entity that it applies to.
     */
    public var ruleId: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Actions to determine if and how a notification is delivered for events
         * matching this rule.
         */actions: [Action], 
        /**
         * Whether this is a default rule, or has been set explicitly.
         */`default`: Bool, 
        /**
         * Whether the push rule is enabled or not.
         */enabled: Bool, 
        /**
         * The ID of this rule.
         *
         * This is generally the Matrix ID of the entity that it applies to.
         */ruleId: String) {
        self.actions = actions
        self.`default` = `default`
        self.enabled = enabled
        self.ruleId = ruleId
    }

    

    
}

#if compiler(>=6)
extension SimplePushRule: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSimplePushRule: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SimplePushRule {
        return
            try SimplePushRule(
                actions: FfiConverterSequenceTypeAction.read(from: &buf), 
                default: FfiConverterBool.read(from: &buf), 
                enabled: FfiConverterBool.read(from: &buf), 
                ruleId: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: SimplePushRule, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeAction.write(value.actions, into: &buf)
        FfiConverterBool.write(value.`default`, into: &buf)
        FfiConverterBool.write(value.enabled, into: &buf)
        FfiConverterString.write(value.ruleId, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimplePushRule_lift(_ buf: RustBuffer) throws -> SimplePushRule {
    return try FfiConverterTypeSimplePushRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSimplePushRule_lower(_ value: SimplePushRule) -> RustBuffer {
    return FfiConverterTypeSimplePushRule.lower(value)
}


/**
 * Structure representing a room in a space and aggregated information
 * relevant to the UI layer.
 */
public struct SpaceRoom: Equatable, Hashable {
    /**
     * The ID of the room.
     */
    public var roomId: String
    /**
     * The canonical alias of the room, if any.
     */
    public var canonicalAlias: String?
    /**
     * The room's name from the room state event if received from sync, or one
     * that's been computed otherwise.
     */
    public var displayName: String
    /**
     * Room name as defined by the room state event only.
     */
    public var rawName: String?
    /**
     * The topic of the room, if any.
     */
    public var topic: String?
    /**
     * The URL for the room's avatar, if one is set.
     */
    public var avatarUrl: String?
    /**
     * The type of room from `m.room.create`, if any.
     */
    public var roomType: RoomType
    /**
     * The number of members joined to the room.
     */
    public var numJoinedMembers: UInt64
    /**
     * The join rule of the room.
     */
    public var joinRule: JoinRule?
    /**
     * Whether the room may be viewed by users without joining.
     */
    public var worldReadable: Bool?
    /**
     * Whether guest users may join the room and participate in it.
     */
    public var guestCanJoin: Bool
    /**
     * Whether this room is a direct room.
     *
     * Only set if the room is known to the client otherwise we
     * assume DMs shouldn't be exposed publicly in spaces.
     */
    public var isDirect: Bool?
    /**
     * The number of children room this has, if a space.
     */
    public var childrenCount: UInt64
    /**
     * Whether this room is joined, left etc.
     */
    public var state: Membership?
    /**
     * A list of room members considered to be heroes.
     */
    public var heroes: [RoomHero]?
    /**
     * The via parameters of the room.
     */
    public var via: [String]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the room.
         */roomId: String, 
        /**
         * The canonical alias of the room, if any.
         */canonicalAlias: String?, 
        /**
         * The room's name from the room state event if received from sync, or one
         * that's been computed otherwise.
         */displayName: String, 
        /**
         * Room name as defined by the room state event only.
         */rawName: String?, 
        /**
         * The topic of the room, if any.
         */topic: String?, 
        /**
         * The URL for the room's avatar, if one is set.
         */avatarUrl: String?, 
        /**
         * The type of room from `m.room.create`, if any.
         */roomType: RoomType, 
        /**
         * The number of members joined to the room.
         */numJoinedMembers: UInt64, 
        /**
         * The join rule of the room.
         */joinRule: JoinRule?, 
        /**
         * Whether the room may be viewed by users without joining.
         */worldReadable: Bool?, 
        /**
         * Whether guest users may join the room and participate in it.
         */guestCanJoin: Bool, 
        /**
         * Whether this room is a direct room.
         *
         * Only set if the room is known to the client otherwise we
         * assume DMs shouldn't be exposed publicly in spaces.
         */isDirect: Bool?, 
        /**
         * The number of children room this has, if a space.
         */childrenCount: UInt64, 
        /**
         * Whether this room is joined, left etc.
         */state: Membership?, 
        /**
         * A list of room members considered to be heroes.
         */heroes: [RoomHero]?, 
        /**
         * The via parameters of the room.
         */via: [String]) {
        self.roomId = roomId
        self.canonicalAlias = canonicalAlias
        self.displayName = displayName
        self.rawName = rawName
        self.topic = topic
        self.avatarUrl = avatarUrl
        self.roomType = roomType
        self.numJoinedMembers = numJoinedMembers
        self.joinRule = joinRule
        self.worldReadable = worldReadable
        self.guestCanJoin = guestCanJoin
        self.isDirect = isDirect
        self.childrenCount = childrenCount
        self.state = state
        self.heroes = heroes
        self.via = via
    }

    

    
}

#if compiler(>=6)
extension SpaceRoom: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpaceRoom: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpaceRoom {
        return
            try SpaceRoom(
                roomId: FfiConverterString.read(from: &buf), 
                canonicalAlias: FfiConverterOptionString.read(from: &buf), 
                displayName: FfiConverterString.read(from: &buf), 
                rawName: FfiConverterOptionString.read(from: &buf), 
                topic: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf), 
                roomType: FfiConverterTypeRoomType.read(from: &buf), 
                numJoinedMembers: FfiConverterUInt64.read(from: &buf), 
                joinRule: FfiConverterOptionTypeJoinRule.read(from: &buf), 
                worldReadable: FfiConverterOptionBool.read(from: &buf), 
                guestCanJoin: FfiConverterBool.read(from: &buf), 
                isDirect: FfiConverterOptionBool.read(from: &buf), 
                childrenCount: FfiConverterUInt64.read(from: &buf), 
                state: FfiConverterOptionTypeMembership.read(from: &buf), 
                heroes: FfiConverterOptionSequenceTypeRoomHero.read(from: &buf), 
                via: FfiConverterSequenceString.read(from: &buf)
        )
    }

    public static func write(_ value: SpaceRoom, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.canonicalAlias, into: &buf)
        FfiConverterString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.rawName, into: &buf)
        FfiConverterOptionString.write(value.topic, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
        FfiConverterTypeRoomType.write(value.roomType, into: &buf)
        FfiConverterUInt64.write(value.numJoinedMembers, into: &buf)
        FfiConverterOptionTypeJoinRule.write(value.joinRule, into: &buf)
        FfiConverterOptionBool.write(value.worldReadable, into: &buf)
        FfiConverterBool.write(value.guestCanJoin, into: &buf)
        FfiConverterOptionBool.write(value.isDirect, into: &buf)
        FfiConverterUInt64.write(value.childrenCount, into: &buf)
        FfiConverterOptionTypeMembership.write(value.state, into: &buf)
        FfiConverterOptionSequenceTypeRoomHero.write(value.heroes, into: &buf)
        FfiConverterSequenceString.write(value.via, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceRoom_lift(_ buf: RustBuffer) throws -> SpaceRoom {
    return try FfiConverterTypeSpaceRoom.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceRoom_lower(_ value: SpaceRoom) -> RustBuffer {
    return FfiConverterTypeSpaceRoom.lower(value)
}


/**
 * Contains the disk size of the different stores, if known. It won't be
 * available for in-memory stores.
 */
public struct StoreSizes: Equatable, Hashable {
    /**
     * The size of the CryptoStore.
     */
    public var cryptoStore: UInt64?
    /**
     * The size of the StateStore.
     */
    public var stateStore: UInt64?
    /**
     * The size of the EventCacheStore.
     */
    public var eventCacheStore: UInt64?
    /**
     * The size of the MediaStore.
     */
    public var mediaStore: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The size of the CryptoStore.
         */cryptoStore: UInt64?, 
        /**
         * The size of the StateStore.
         */stateStore: UInt64?, 
        /**
         * The size of the EventCacheStore.
         */eventCacheStore: UInt64?, 
        /**
         * The size of the MediaStore.
         */mediaStore: UInt64?) {
        self.cryptoStore = cryptoStore
        self.stateStore = stateStore
        self.eventCacheStore = eventCacheStore
        self.mediaStore = mediaStore
    }

    

    
}

#if compiler(>=6)
extension StoreSizes: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStoreSizes: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StoreSizes {
        return
            try StoreSizes(
                cryptoStore: FfiConverterOptionUInt64.read(from: &buf), 
                stateStore: FfiConverterOptionUInt64.read(from: &buf), 
                eventCacheStore: FfiConverterOptionUInt64.read(from: &buf), 
                mediaStore: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: StoreSizes, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.cryptoStore, into: &buf)
        FfiConverterOptionUInt64.write(value.stateStore, into: &buf)
        FfiConverterOptionUInt64.write(value.eventCacheStore, into: &buf)
        FfiConverterOptionUInt64.write(value.mediaStore, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStoreSizes_lift(_ buf: RustBuffer) throws -> StoreSizes {
    return try FfiConverterTypeStoreSizes.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStoreSizes_lower(_ value: StoreSizes) -> RustBuffer {
    return FfiConverterTypeStoreSizes.lower(value)
}


/**
 * When a room A is tombstoned, it is replaced by a room B. The room A is the
 * predecessor of B, and B is the successor of A. This type holds information
 * about the successor room. See [`Room::successor_room`].
 *
 * A room is tombstoned if it has received a [`m.room.tombstone`] state event.
 *
 * [`m.room.tombstone`]: https://spec.matrix.org/v1.14/client-server-api/#mroomtombstone
 */
public struct SuccessorRoom: Equatable, Hashable {
    /**
     * The ID of the replacement room.
     */
    public var roomId: String
    /**
     * The message explaining why the room has been tombstoned.
     */
    public var reason: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The ID of the replacement room.
         */roomId: String, 
        /**
         * The message explaining why the room has been tombstoned.
         */reason: String?) {
        self.roomId = roomId
        self.reason = reason
    }

    

    
}

#if compiler(>=6)
extension SuccessorRoom: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSuccessorRoom: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SuccessorRoom {
        return
            try SuccessorRoom(
                roomId: FfiConverterString.read(from: &buf), 
                reason: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SuccessorRoom, into buf: inout [UInt8]) {
        FfiConverterString.write(value.roomId, into: &buf)
        FfiConverterOptionString.write(value.reason, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessorRoom_lift(_ buf: RustBuffer) throws -> SuccessorRoom {
    return try FfiConverterTypeSuccessorRoom.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSuccessorRoom_lower(_ value: SuccessorRoom) -> RustBuffer {
    return FfiConverterTypeSuccessorRoom.lower(value)
}


/**
 * Information about a tag.
 */
public struct TagInfo: Equatable, Hashable {
    /**
     * Value to use for lexicographically ordering rooms with this tag.
     */
    public var order: Double?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Value to use for lexicographically ordering rooms with this tag.
         */order: Double?) {
        self.order = order
    }

    

    
}

#if compiler(>=6)
extension TagInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTagInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagInfo {
        return
            try TagInfo(
                order: FfiConverterOptionDouble.read(from: &buf)
        )
    }

    public static func write(_ value: TagInfo, into buf: inout [UInt8]) {
        FfiConverterOptionDouble.write(value.order, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagInfo_lift(_ buf: RustBuffer) throws -> TagInfo {
    return try FfiConverterTypeTagInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagInfo_lower(_ value: TagInfo) -> RustBuffer {
    return FfiConverterTypeTagInfo.lower(value)
}


public struct TextMessageContent: Equatable, Hashable {
    public var body: String
    public var formatted: FormattedBody?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(body: String, formatted: FormattedBody?) {
        self.body = body
        self.formatted = formatted
    }

    

    
}

#if compiler(>=6)
extension TextMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTextMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TextMessageContent {
        return
            try TextMessageContent(
                body: FfiConverterString.read(from: &buf), 
                formatted: FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
    }

    public static func write(_ value: TextMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.body, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formatted, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextMessageContent_lift(_ buf: RustBuffer) throws -> TextMessageContent {
    return try FfiConverterTypeTextMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTextMessageContent_lower(_ value: TextMessageContent) -> RustBuffer {
    return FfiConverterTypeTextMessageContent.lower(value)
}


/**
 * A thread subscription (MSC4306).
 */
public struct ThreadSubscription: Equatable, Hashable {
    /**
     * Whether the thread subscription happened automatically (e.g. after a
     * mention) or if it was manually requested by the user.
     */
    public var automatic: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Whether the thread subscription happened automatically (e.g. after a
         * mention) or if it was manually requested by the user.
         */automatic: Bool) {
        self.automatic = automatic
    }

    

    
}

#if compiler(>=6)
extension ThreadSubscription: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeThreadSubscription: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThreadSubscription {
        return
            try ThreadSubscription(
                automatic: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: ThreadSubscription, into buf: inout [UInt8]) {
        FfiConverterBool.write(value.automatic, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThreadSubscription_lift(_ buf: RustBuffer) throws -> ThreadSubscription {
    return try FfiConverterTypeThreadSubscription.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThreadSubscription_lower(_ value: ThreadSubscription) -> RustBuffer {
    return FfiConverterTypeThreadSubscription.lower(value)
}


public struct ThumbnailInfo: Equatable, Hashable {
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?) {
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
    }

    

    
}

#if compiler(>=6)
extension ThumbnailInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeThumbnailInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ThumbnailInfo {
        return
            try ThumbnailInfo(
                height: FfiConverterOptionUInt64.read(from: &buf), 
                width: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: ThumbnailInfo, into buf: inout [UInt8]) {
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThumbnailInfo_lift(_ buf: RustBuffer) throws -> ThumbnailInfo {
    return try FfiConverterTypeThumbnailInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeThumbnailInfo_lower(_ value: ThumbnailInfo) -> RustBuffer {
    return FfiConverterTypeThumbnailInfo.lower(value)
}


/**
 * Various options used to configure the timeline's behavior.
 */
public struct TimelineConfiguration {
    /**
     * What should the timeline focus on?
     */
    public var focus: TimelineFocus
    /**
     * How should we filter out events from the timeline?
     */
    public var filter: TimelineFilter
    /**
     * An optional String that will be prepended to
     * all the timeline item's internal IDs, making it possible to
     * distinguish different timeline instances from each other.
     */
    public var internalIdPrefix: String?
    /**
     * How often to insert date dividers
     */
    public var dateDividerMode: DateDividerMode
    /**
     * Should the read receipts and read markers be tracked for the timeline
     * items in this instance and on which event types?
     *
     * As this has a non negligible performance impact, make sure to enable it
     * only when you need it.
     */
    public var trackReadReceipts: TimelineReadReceiptTracking
    /**
     * Whether this timeline instance should report UTDs through the client's
     * delegate.
     */
    public var reportUtds: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * What should the timeline focus on?
         */focus: TimelineFocus, 
        /**
         * How should we filter out events from the timeline?
         */filter: TimelineFilter, 
        /**
         * An optional String that will be prepended to
         * all the timeline item's internal IDs, making it possible to
         * distinguish different timeline instances from each other.
         */internalIdPrefix: String?, 
        /**
         * How often to insert date dividers
         */dateDividerMode: DateDividerMode, 
        /**
         * Should the read receipts and read markers be tracked for the timeline
         * items in this instance and on which event types?
         *
         * As this has a non negligible performance impact, make sure to enable it
         * only when you need it.
         */trackReadReceipts: TimelineReadReceiptTracking, 
        /**
         * Whether this timeline instance should report UTDs through the client's
         * delegate.
         */reportUtds: Bool) {
        self.focus = focus
        self.filter = filter
        self.internalIdPrefix = internalIdPrefix
        self.dateDividerMode = dateDividerMode
        self.trackReadReceipts = trackReadReceipts
        self.reportUtds = reportUtds
    }

    

    
}

#if compiler(>=6)
extension TimelineConfiguration: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineConfiguration {
        return
            try TimelineConfiguration(
                focus: FfiConverterTypeTimelineFocus.read(from: &buf), 
                filter: FfiConverterTypeTimelineFilter.read(from: &buf), 
                internalIdPrefix: FfiConverterOptionString.read(from: &buf), 
                dateDividerMode: FfiConverterTypeDateDividerMode.read(from: &buf), 
                trackReadReceipts: FfiConverterTypeTimelineReadReceiptTracking.read(from: &buf), 
                reportUtds: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: TimelineConfiguration, into buf: inout [UInt8]) {
        FfiConverterTypeTimelineFocus.write(value.focus, into: &buf)
        FfiConverterTypeTimelineFilter.write(value.filter, into: &buf)
        FfiConverterOptionString.write(value.internalIdPrefix, into: &buf)
        FfiConverterTypeDateDividerMode.write(value.dateDividerMode, into: &buf)
        FfiConverterTypeTimelineReadReceiptTracking.write(value.trackReadReceipts, into: &buf)
        FfiConverterBool.write(value.reportUtds, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineConfiguration_lift(_ buf: RustBuffer) throws -> TimelineConfiguration {
    return try FfiConverterTypeTimelineConfiguration.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineConfiguration_lower(_ value: TimelineConfiguration) -> RustBuffer {
    return FfiConverterTypeTimelineConfiguration.lower(value)
}


public struct TimelineUniqueId: Equatable, Hashable {
    public var id: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String) {
        self.id = id
    }

    

    
}

#if compiler(>=6)
extension TimelineUniqueId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineUniqueId: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineUniqueId {
        return
            try TimelineUniqueId(
                id: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: TimelineUniqueId, into buf: inout [UInt8]) {
        FfiConverterString.write(value.id, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineUniqueId_lift(_ buf: RustBuffer) throws -> TimelineUniqueId {
    return try FfiConverterTypeTimelineUniqueId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineUniqueId_lower(_ value: TimelineUniqueId) -> RustBuffer {
    return FfiConverterTypeTimelineUniqueId.lower(value)
}


public struct TracingConfiguration: Equatable, Hashable {
    /**
     * The desired log level.
     */
    public var logLevel: LogLevel
    /**
     * All the log packs, that will be set to `TRACE` when they're enabled.
     */
    public var traceLogPacks: [TraceLogPacks]
    /**
     * Additional targets that the FFI client would like to use.
     *
     * This can include, for instance, the target names for created
     * [`crate::tracing::Span`]. These targets will use the global log level by
     * default.
     */
    public var extraTargets: [String]
    /**
     * Whether to log to stdout, or in the logcat on Android.
     */
    public var writeToStdoutOrSystem: Bool
    /**
     * If set, configures rotated log files where to write additional logs.
     */
    public var writeToFiles: TracingFileConfiguration?
    /**
     * If set, the Sentry DSN to use for error reporting.
     */
    public var sentryDsn: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The desired log level.
         */logLevel: LogLevel, 
        /**
         * All the log packs, that will be set to `TRACE` when they're enabled.
         */traceLogPacks: [TraceLogPacks], 
        /**
         * Additional targets that the FFI client would like to use.
         *
         * This can include, for instance, the target names for created
         * [`crate::tracing::Span`]. These targets will use the global log level by
         * default.
         */extraTargets: [String], 
        /**
         * Whether to log to stdout, or in the logcat on Android.
         */writeToStdoutOrSystem: Bool, 
        /**
         * If set, configures rotated log files where to write additional logs.
         */writeToFiles: TracingFileConfiguration?, 
        /**
         * If set, the Sentry DSN to use for error reporting.
         */sentryDsn: String?) {
        self.logLevel = logLevel
        self.traceLogPacks = traceLogPacks
        self.extraTargets = extraTargets
        self.writeToStdoutOrSystem = writeToStdoutOrSystem
        self.writeToFiles = writeToFiles
        self.sentryDsn = sentryDsn
    }

    

    
}

#if compiler(>=6)
extension TracingConfiguration: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTracingConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TracingConfiguration {
        return
            try TracingConfiguration(
                logLevel: FfiConverterTypeLogLevel.read(from: &buf), 
                traceLogPacks: FfiConverterSequenceTypeTraceLogPacks.read(from: &buf), 
                extraTargets: FfiConverterSequenceString.read(from: &buf), 
                writeToStdoutOrSystem: FfiConverterBool.read(from: &buf), 
                writeToFiles: FfiConverterOptionTypeTracingFileConfiguration.read(from: &buf), 
                sentryDsn: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: TracingConfiguration, into buf: inout [UInt8]) {
        FfiConverterTypeLogLevel.write(value.logLevel, into: &buf)
        FfiConverterSequenceTypeTraceLogPacks.write(value.traceLogPacks, into: &buf)
        FfiConverterSequenceString.write(value.extraTargets, into: &buf)
        FfiConverterBool.write(value.writeToStdoutOrSystem, into: &buf)
        FfiConverterOptionTypeTracingFileConfiguration.write(value.writeToFiles, into: &buf)
        FfiConverterOptionString.write(value.sentryDsn, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTracingConfiguration_lift(_ buf: RustBuffer) throws -> TracingConfiguration {
    return try FfiConverterTypeTracingConfiguration.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTracingConfiguration_lower(_ value: TracingConfiguration) -> RustBuffer {
    return FfiConverterTypeTracingConfiguration.lower(value)
}


/**
 * Configuration to save logs to (rotated) log-files.
 */
public struct TracingFileConfiguration: Equatable, Hashable {
    /**
     * Base location for all the log files.
     */
    public var path: String
    /**
     * Prefix for the log files' names.
     */
    public var filePrefix: String
    /**
     * Optional suffix for the log file's names.
     */
    public var fileSuffix: String?
    /**
     * Maximum number of rotated files.
     *
     * If not set, there's no max limit, i.e. the number of log files is
     * unlimited.
     */
    public var maxFiles: UInt64?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Base location for all the log files.
         */path: String, 
        /**
         * Prefix for the log files' names.
         */filePrefix: String, 
        /**
         * Optional suffix for the log file's names.
         */fileSuffix: String?, 
        /**
         * Maximum number of rotated files.
         *
         * If not set, there's no max limit, i.e. the number of log files is
         * unlimited.
         */maxFiles: UInt64?) {
        self.path = path
        self.filePrefix = filePrefix
        self.fileSuffix = fileSuffix
        self.maxFiles = maxFiles
    }

    

    
}

#if compiler(>=6)
extension TracingFileConfiguration: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTracingFileConfiguration: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TracingFileConfiguration {
        return
            try TracingFileConfiguration(
                path: FfiConverterString.read(from: &buf), 
                filePrefix: FfiConverterString.read(from: &buf), 
                fileSuffix: FfiConverterOptionString.read(from: &buf), 
                maxFiles: FfiConverterOptionUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TracingFileConfiguration, into buf: inout [UInt8]) {
        FfiConverterString.write(value.path, into: &buf)
        FfiConverterString.write(value.filePrefix, into: &buf)
        FfiConverterOptionString.write(value.fileSuffix, into: &buf)
        FfiConverterOptionUInt64.write(value.maxFiles, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTracingFileConfiguration_lift(_ buf: RustBuffer) throws -> TracingFileConfiguration {
    return try FfiConverterTypeTracingFileConfiguration.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTracingFileConfiguration_lower(_ value: TracingFileConfiguration) -> RustBuffer {
    return FfiConverterTypeTracingFileConfiguration.lower(value)
}


public struct TransmissionProgress: Equatable, Hashable {
    public var current: UInt64
    public var total: UInt64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(current: UInt64, total: UInt64) {
        self.current = current
        self.total = total
    }

    

    
}

#if compiler(>=6)
extension TransmissionProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTransmissionProgress: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TransmissionProgress {
        return
            try TransmissionProgress(
                current: FfiConverterUInt64.read(from: &buf), 
                total: FfiConverterUInt64.read(from: &buf)
        )
    }

    public static func write(_ value: TransmissionProgress, into buf: inout [UInt8]) {
        FfiConverterUInt64.write(value.current, into: &buf)
        FfiConverterUInt64.write(value.total, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransmissionProgress_lift(_ buf: RustBuffer) throws -> TransmissionProgress {
    return try FfiConverterTypeTransmissionProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTransmissionProgress_lower(_ value: TransmissionProgress) -> RustBuffer {
    return FfiConverterTypeTransmissionProgress.lower(value)
}


public struct UnableToDecryptInfo: Equatable, Hashable {
    /**
     * The identifier of the event that couldn't get decrypted.
     */
    public var eventId: String
    /**
     * If the event could be decrypted late (that is, the event was encrypted
     * at first, but could be decrypted later on), then this indicates the
     * time it took to decrypt the event. If it is not set, this is
     * considered a definite UTD.
     *
     * If set, this is in milliseconds.
     */
    public var timeToDecryptMs: UInt64?
    /**
     * What we know about what caused this UTD. E.g. was this event sent when
     * we were not a member of this room?
     */
    public var cause: UtdCause
    /**
     * The difference between the event creation time (`origin_server_ts`) and
     * the time our device was created. If negative, this event was sent
     * *before* our device was created.
     */
    public var eventLocalAgeMillis: Int64
    /**
     * Whether the user had verified their own identity at the point they
     * received the UTD event.
     */
    public var userTrustsOwnIdentity: Bool
    /**
     * The homeserver of the user that sent the undecryptable event.
     */
    public var senderHomeserver: String
    /**
     * Our local user's own homeserver, or `None` if the client is not logged
     * in.
     */
    public var ownHomeserver: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The identifier of the event that couldn't get decrypted.
         */eventId: String, 
        /**
         * If the event could be decrypted late (that is, the event was encrypted
         * at first, but could be decrypted later on), then this indicates the
         * time it took to decrypt the event. If it is not set, this is
         * considered a definite UTD.
         *
         * If set, this is in milliseconds.
         */timeToDecryptMs: UInt64?, 
        /**
         * What we know about what caused this UTD. E.g. was this event sent when
         * we were not a member of this room?
         */cause: UtdCause, 
        /**
         * The difference between the event creation time (`origin_server_ts`) and
         * the time our device was created. If negative, this event was sent
         * *before* our device was created.
         */eventLocalAgeMillis: Int64, 
        /**
         * Whether the user had verified their own identity at the point they
         * received the UTD event.
         */userTrustsOwnIdentity: Bool, 
        /**
         * The homeserver of the user that sent the undecryptable event.
         */senderHomeserver: String, 
        /**
         * Our local user's own homeserver, or `None` if the client is not logged
         * in.
         */ownHomeserver: String?) {
        self.eventId = eventId
        self.timeToDecryptMs = timeToDecryptMs
        self.cause = cause
        self.eventLocalAgeMillis = eventLocalAgeMillis
        self.userTrustsOwnIdentity = userTrustsOwnIdentity
        self.senderHomeserver = senderHomeserver
        self.ownHomeserver = ownHomeserver
    }

    

    
}

#if compiler(>=6)
extension UnableToDecryptInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnableToDecryptInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnableToDecryptInfo {
        return
            try UnableToDecryptInfo(
                eventId: FfiConverterString.read(from: &buf), 
                timeToDecryptMs: FfiConverterOptionUInt64.read(from: &buf), 
                cause: FfiConverterTypeUtdCause.read(from: &buf), 
                eventLocalAgeMillis: FfiConverterInt64.read(from: &buf), 
                userTrustsOwnIdentity: FfiConverterBool.read(from: &buf), 
                senderHomeserver: FfiConverterString.read(from: &buf), 
                ownHomeserver: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UnableToDecryptInfo, into buf: inout [UInt8]) {
        FfiConverterString.write(value.eventId, into: &buf)
        FfiConverterOptionUInt64.write(value.timeToDecryptMs, into: &buf)
        FfiConverterTypeUtdCause.write(value.cause, into: &buf)
        FfiConverterInt64.write(value.eventLocalAgeMillis, into: &buf)
        FfiConverterBool.write(value.userTrustsOwnIdentity, into: &buf)
        FfiConverterString.write(value.senderHomeserver, into: &buf)
        FfiConverterOptionString.write(value.ownHomeserver, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnableToDecryptInfo_lift(_ buf: RustBuffer) throws -> UnableToDecryptInfo {
    return try FfiConverterTypeUnableToDecryptInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnableToDecryptInfo_lower(_ value: UnableToDecryptInfo) -> RustBuffer {
    return FfiConverterTypeUnableToDecryptInfo.lower(value)
}


public struct UnstableAudioDetailsContent: Equatable, Hashable {
    public var duration: TimeInterval
    public var waveform: [UInt16]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval, waveform: [UInt16]) {
        self.duration = duration
        self.waveform = waveform
    }

    

    
}

#if compiler(>=6)
extension UnstableAudioDetailsContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnstableAudioDetailsContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstableAudioDetailsContent {
        return
            try UnstableAudioDetailsContent(
                duration: FfiConverterDuration.read(from: &buf), 
                waveform: FfiConverterSequenceUInt16.read(from: &buf)
        )
    }

    public static func write(_ value: UnstableAudioDetailsContent, into buf: inout [UInt8]) {
        FfiConverterDuration.write(value.duration, into: &buf)
        FfiConverterSequenceUInt16.write(value.waveform, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnstableAudioDetailsContent_lift(_ buf: RustBuffer) throws -> UnstableAudioDetailsContent {
    return try FfiConverterTypeUnstableAudioDetailsContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnstableAudioDetailsContent_lower(_ value: UnstableAudioDetailsContent) -> RustBuffer {
    return FfiConverterTypeUnstableAudioDetailsContent.lower(value)
}


public struct UnstableVoiceContent: Equatable, Hashable {

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init() {
    }

    

    
}

#if compiler(>=6)
extension UnstableVoiceContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUnstableVoiceContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UnstableVoiceContent {
        return
            UnstableVoiceContent()
    }

    public static func write(_ value: UnstableVoiceContent, into buf: inout [UInt8]) {
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnstableVoiceContent_lift(_ buf: RustBuffer) throws -> UnstableVoiceContent {
    return try FfiConverterTypeUnstableVoiceContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUnstableVoiceContent_lower(_ value: UnstableVoiceContent) -> RustBuffer {
    return FfiConverterTypeUnstableVoiceContent.lower(value)
}


public struct UploadParameters: Equatable, Hashable {
    /**
     * Source from which to upload data
     */
    public var source: UploadSource
    /**
     * Optional non-formatted caption, for clients that support it.
     */
    public var caption: String?
    /**
     * Optional HTML-formatted caption, for clients that support it.
     */
    public var formattedCaption: FormattedBody?
    /**
     * Optional intentional mentions to be sent with the media.
     */
    public var mentions: Mentions?
    /**
     * Optional Event ID to reply to.
     */
    public var inReplyTo: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Source from which to upload data
         */source: UploadSource, 
        /**
         * Optional non-formatted caption, for clients that support it.
         */caption: String?, 
        /**
         * Optional HTML-formatted caption, for clients that support it.
         */formattedCaption: FormattedBody?, 
        /**
         * Optional intentional mentions to be sent with the media.
         */mentions: Mentions?, 
        /**
         * Optional Event ID to reply to.
         */inReplyTo: String?) {
        self.source = source
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.mentions = mentions
        self.inReplyTo = inReplyTo
    }

    

    
}

#if compiler(>=6)
extension UploadParameters: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadParameters: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadParameters {
        return
            try UploadParameters(
                source: FfiConverterTypeUploadSource.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                mentions: FfiConverterOptionTypeMentions.read(from: &buf), 
                inReplyTo: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UploadParameters, into buf: inout [UInt8]) {
        FfiConverterTypeUploadSource.write(value.source, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterOptionTypeMentions.write(value.mentions, into: &buf)
        FfiConverterOptionString.write(value.inReplyTo, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadParameters_lift(_ buf: RustBuffer) throws -> UploadParameters {
    return try FfiConverterTypeUploadParameters.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadParameters_lower(_ value: UploadParameters) -> RustBuffer {
    return FfiConverterTypeUploadParameters.lower(value)
}


/**
 * An update for a particular user's power level within the room.
 */
public struct UserPowerLevelUpdate: Equatable, Hashable {
    /**
     * The user ID of the user to update.
     */
    public var userId: String
    /**
     * The power level to assign to the user.
     */
    public var powerLevel: Int64

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user ID of the user to update.
         */userId: String, 
        /**
         * The power level to assign to the user.
         */powerLevel: Int64) {
        self.userId = userId
        self.powerLevel = powerLevel
    }

    

    
}

#if compiler(>=6)
extension UserPowerLevelUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserPowerLevelUpdate: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserPowerLevelUpdate {
        return
            try UserPowerLevelUpdate(
                userId: FfiConverterString.read(from: &buf), 
                powerLevel: FfiConverterInt64.read(from: &buf)
        )
    }

    public static func write(_ value: UserPowerLevelUpdate, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterInt64.write(value.powerLevel, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserPowerLevelUpdate_lift(_ buf: RustBuffer) throws -> UserPowerLevelUpdate {
    return try FfiConverterTypeUserPowerLevelUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserPowerLevelUpdate_lower(_ value: UserPowerLevelUpdate) -> RustBuffer {
    return FfiConverterTypeUserPowerLevelUpdate.lower(value)
}


public struct UserProfile: Equatable, Hashable {
    public var userId: String
    public var displayName: String?
    public var avatarUrl: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(userId: String, displayName: String?, avatarUrl: String?) {
        self.userId = userId
        self.displayName = displayName
        self.avatarUrl = avatarUrl
    }

    

    
}

#if compiler(>=6)
extension UserProfile: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserProfile: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserProfile {
        return
            try UserProfile(
                userId: FfiConverterString.read(from: &buf), 
                displayName: FfiConverterOptionString.read(from: &buf), 
                avatarUrl: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: UserProfile, into buf: inout [UInt8]) {
        FfiConverterString.write(value.userId, into: &buf)
        FfiConverterOptionString.write(value.displayName, into: &buf)
        FfiConverterOptionString.write(value.avatarUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserProfile_lift(_ buf: RustBuffer) throws -> UserProfile {
    return try FfiConverterTypeUserProfile.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserProfile_lower(_ value: UserProfile) -> RustBuffer {
    return FfiConverterTypeUserProfile.lower(value)
}


/**
 * A user-defined tag name.
 */
public struct UserTagName: Equatable, Hashable {
    public var name: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String) {
        self.name = name
    }

    

    
}

#if compiler(>=6)
extension UserTagName: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUserTagName: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UserTagName {
        return
            try UserTagName(
                name: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: UserTagName, into buf: inout [UInt8]) {
        FfiConverterString.write(value.name, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserTagName_lift(_ buf: RustBuffer) throws -> UserTagName {
    return try FfiConverterTypeUserTagName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUserTagName_lower(_ value: UserTagName) -> RustBuffer {
    return FfiConverterTypeUserTagName.lower(value)
}


public struct VideoInfo {
    public var duration: TimeInterval?
    public var height: UInt64?
    public var width: UInt64?
    public var mimetype: String?
    public var size: UInt64?
    public var thumbnailInfo: ThumbnailInfo?
    public var thumbnailSource: MediaSource?
    public var blurhash: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(duration: TimeInterval?, height: UInt64?, width: UInt64?, mimetype: String?, size: UInt64?, thumbnailInfo: ThumbnailInfo?, thumbnailSource: MediaSource?, blurhash: String?) {
        self.duration = duration
        self.height = height
        self.width = width
        self.mimetype = mimetype
        self.size = size
        self.thumbnailInfo = thumbnailInfo
        self.thumbnailSource = thumbnailSource
        self.blurhash = blurhash
    }

    

    
}

#if compiler(>=6)
extension VideoInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoInfo: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoInfo {
        return
            try VideoInfo(
                duration: FfiConverterOptionDuration.read(from: &buf), 
                height: FfiConverterOptionUInt64.read(from: &buf), 
                width: FfiConverterOptionUInt64.read(from: &buf), 
                mimetype: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionUInt64.read(from: &buf), 
                thumbnailInfo: FfiConverterOptionTypeThumbnailInfo.read(from: &buf), 
                thumbnailSource: FfiConverterOptionTypeMediaSource.read(from: &buf), 
                blurhash: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: VideoInfo, into buf: inout [UInt8]) {
        FfiConverterOptionDuration.write(value.duration, into: &buf)
        FfiConverterOptionUInt64.write(value.height, into: &buf)
        FfiConverterOptionUInt64.write(value.width, into: &buf)
        FfiConverterOptionString.write(value.mimetype, into: &buf)
        FfiConverterOptionUInt64.write(value.size, into: &buf)
        FfiConverterOptionTypeThumbnailInfo.write(value.thumbnailInfo, into: &buf)
        FfiConverterOptionTypeMediaSource.write(value.thumbnailSource, into: &buf)
        FfiConverterOptionString.write(value.blurhash, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoInfo_lift(_ buf: RustBuffer) throws -> VideoInfo {
    return try FfiConverterTypeVideoInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoInfo_lower(_ value: VideoInfo) -> RustBuffer {
    return FfiConverterTypeVideoInfo.lower(value)
}


public struct VideoMessageContent {
    /**
     * The computed filename, for use in a client.
     */
    public var filename: String
    public var caption: String?
    public var formattedCaption: FormattedBody?
    public var source: MediaSource
    public var info: VideoInfo?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The computed filename, for use in a client.
         */filename: String, caption: String?, formattedCaption: FormattedBody?, source: MediaSource, info: VideoInfo?) {
        self.filename = filename
        self.caption = caption
        self.formattedCaption = formattedCaption
        self.source = source
        self.info = info
    }

    

    
}

#if compiler(>=6)
extension VideoMessageContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVideoMessageContent: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VideoMessageContent {
        return
            try VideoMessageContent(
                filename: FfiConverterString.read(from: &buf), 
                caption: FfiConverterOptionString.read(from: &buf), 
                formattedCaption: FfiConverterOptionTypeFormattedBody.read(from: &buf), 
                source: FfiConverterTypeMediaSource.read(from: &buf), 
                info: FfiConverterOptionTypeVideoInfo.read(from: &buf)
        )
    }

    public static func write(_ value: VideoMessageContent, into buf: inout [UInt8]) {
        FfiConverterString.write(value.filename, into: &buf)
        FfiConverterOptionString.write(value.caption, into: &buf)
        FfiConverterOptionTypeFormattedBody.write(value.formattedCaption, into: &buf)
        FfiConverterTypeMediaSource.write(value.source, into: &buf)
        FfiConverterOptionTypeVideoInfo.write(value.info, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoMessageContent_lift(_ buf: RustBuffer) throws -> VideoMessageContent {
    return try FfiConverterTypeVideoMessageContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVideoMessageContent_lower(_ value: VideoMessageContent) -> RustBuffer {
    return FfiConverterTypeVideoMessageContent.lower(value)
}


/**
 * Capabilities that a widget can request from a client.
 */
public struct WidgetCapabilities: Equatable, Hashable {
    /**
     * Types of the messages that a widget wants to be able to fetch.
     */
    public var read: [WidgetEventFilter]
    /**
     * Types of the messages that a widget wants to be able to send.
     */
    public var send: [WidgetEventFilter]
    /**
     * If this capability is requested by the widget, it can not operate
     * separately from the Matrix client.
     *
     * This means clients should not offer to open the widget in a separate
     * browser/tab/webview that is not connected to the postmessage widget-api.
     */
    public var requiresClient: Bool
    /**
     * This allows the widget to ask the client to update delayed events.
     */
    public var updateDelayedEvent: Bool
    /**
     * This allows the widget to send events with a delay.
     */
    public var sendDelayedEvent: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Types of the messages that a widget wants to be able to fetch.
         */read: [WidgetEventFilter], 
        /**
         * Types of the messages that a widget wants to be able to send.
         */send: [WidgetEventFilter], 
        /**
         * If this capability is requested by the widget, it can not operate
         * separately from the Matrix client.
         *
         * This means clients should not offer to open the widget in a separate
         * browser/tab/webview that is not connected to the postmessage widget-api.
         */requiresClient: Bool, 
        /**
         * This allows the widget to ask the client to update delayed events.
         */updateDelayedEvent: Bool, 
        /**
         * This allows the widget to send events with a delay.
         */sendDelayedEvent: Bool) {
        self.read = read
        self.send = send
        self.requiresClient = requiresClient
        self.updateDelayedEvent = updateDelayedEvent
        self.sendDelayedEvent = sendDelayedEvent
    }

    

    
}

#if compiler(>=6)
extension WidgetCapabilities: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWidgetCapabilities: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetCapabilities {
        return
            try WidgetCapabilities(
                read: FfiConverterSequenceTypeWidgetEventFilter.read(from: &buf), 
                send: FfiConverterSequenceTypeWidgetEventFilter.read(from: &buf), 
                requiresClient: FfiConverterBool.read(from: &buf), 
                updateDelayedEvent: FfiConverterBool.read(from: &buf), 
                sendDelayedEvent: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetCapabilities, into buf: inout [UInt8]) {
        FfiConverterSequenceTypeWidgetEventFilter.write(value.read, into: &buf)
        FfiConverterSequenceTypeWidgetEventFilter.write(value.send, into: &buf)
        FfiConverterBool.write(value.requiresClient, into: &buf)
        FfiConverterBool.write(value.updateDelayedEvent, into: &buf)
        FfiConverterBool.write(value.sendDelayedEvent, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetCapabilities_lift(_ buf: RustBuffer) throws -> WidgetCapabilities {
    return try FfiConverterTypeWidgetCapabilities.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetCapabilities_lower(_ value: WidgetCapabilities) -> RustBuffer {
    return FfiConverterTypeWidgetCapabilities.lower(value)
}


public struct WidgetDriverAndHandle {
    public var driver: WidgetDriver
    public var handle: WidgetDriverHandle

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(driver: WidgetDriver, handle: WidgetDriverHandle) {
        self.driver = driver
        self.handle = handle
    }

    

    
}

#if compiler(>=6)
extension WidgetDriverAndHandle: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWidgetDriverAndHandle: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetDriverAndHandle {
        return
            try WidgetDriverAndHandle(
                driver: FfiConverterTypeWidgetDriver.read(from: &buf), 
                handle: FfiConverterTypeWidgetDriverHandle.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetDriverAndHandle, into buf: inout [UInt8]) {
        FfiConverterTypeWidgetDriver.write(value.driver, into: &buf)
        FfiConverterTypeWidgetDriverHandle.write(value.handle, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetDriverAndHandle_lift(_ buf: RustBuffer) throws -> WidgetDriverAndHandle {
    return try FfiConverterTypeWidgetDriverAndHandle.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetDriverAndHandle_lower(_ value: WidgetDriverAndHandle) -> RustBuffer {
    return FfiConverterTypeWidgetDriverAndHandle.lower(value)
}


/**
 * Information about a widget.
 */
public struct WidgetSettings: Equatable, Hashable {
    /**
     * Widget's unique identifier.
     */
    public var widgetId: String
    /**
     * Whether or not the widget should be initialized on load message
     * (`ContentLoad` message), or upon creation/attaching of the widget to
     * the SDK's state machine that drives the API.
     */
    public var initAfterContentLoad: Bool
    /**
     * This contains the url from the widget state event.
     * In this url placeholders can be used to pass information from the client
     * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
     * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
     *
     * # Examples
     *
     * e.g `http://widget.domain?username=$userId`
     * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
     */
    public var rawUrl: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Widget's unique identifier.
         */widgetId: String, 
        /**
         * Whether or not the widget should be initialized on load message
         * (`ContentLoad` message), or upon creation/attaching of the widget to
         * the SDK's state machine that drives the API.
         */initAfterContentLoad: Bool, 
        /**
         * This contains the url from the widget state event.
         * In this url placeholders can be used to pass information from the client
         * to the widget. Possible values are: `$widgetId`, `$parentUrl`,
         * `$userId`, `$lang`, `$fontScale`, `$analyticsID`.
         *
         * # Examples
         *
         * e.g `http://widget.domain?username=$userId`
         * will become: `http://widget.domain?username=@user_matrix_id:server.domain`.
         */rawUrl: String) {
        self.widgetId = widgetId
        self.initAfterContentLoad = initAfterContentLoad
        self.rawUrl = rawUrl
    }

    

    
}

#if compiler(>=6)
extension WidgetSettings: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWidgetSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetSettings {
        return
            try WidgetSettings(
                widgetId: FfiConverterString.read(from: &buf), 
                initAfterContentLoad: FfiConverterBool.read(from: &buf), 
                rawUrl: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: WidgetSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.widgetId, into: &buf)
        FfiConverterBool.write(value.initAfterContentLoad, into: &buf)
        FfiConverterString.write(value.rawUrl, into: &buf)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetSettings_lift(_ buf: RustBuffer) throws -> WidgetSettings {
    return try FfiConverterTypeWidgetSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetSettings_lower(_ value: WidgetSettings) -> RustBuffer {
    return FfiConverterTypeWidgetSettings.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Global account data events.
 */

public enum AccountDataEvent: Equatable, Hashable {
    
    /**
     * m.direct
     */
    case direct(
        /**
         * The mapping of user ID to a list of room IDs of the â€˜directâ€™ rooms
         * for that user ID.
         */map: [String: [String]]
    )
    /**
     * m.identity_server
     */
    case identityServer(
        /**
         * The base URL for the identity server for client-server connections.
         */baseUrl: String?
    )
    /**
     * m.ignored_user_list
     */
    case ignoredUserList(
        /**
         * The map of users to ignore. This is a mapping of user ID to empty
         * object.
         */ignoredUsers: [String: IgnoredUser]
    )
    /**
     * m.push_rules
     */
    case pushRules(
        /**
         * The global ruleset.
         */global: Ruleset
    )
    /**
     * m.secret_storage.default_key
     */
    case secretStorageDefaultKey(
        /**
         * The ID of the default key.
         */keyId: String
    )
    /**
     * m.secret_storage.key.*
     */
    case secretStorageKey(
        /**
         * The ID of the key.
         */keyId: String, 
        /**
         * The name of the key.
         */name: String?, 
        /**
         * The encryption algorithm used for this key.
         *
         * Currently, only `m.secret_storage.v1.aes-hmac-sha2` is supported.
         */algorithm: SecretStorageEncryptionAlgorithm, 
        /**
         * The passphrase from which to generate the key.
         */passphrase: PassPhrase?
    )





}

#if compiler(>=6)
extension AccountDataEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountDataEvent: FfiConverterRustBuffer {
    typealias SwiftType = AccountDataEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDataEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .direct(map: try FfiConverterDictionaryStringSequenceString.read(from: &buf)
        )
        
        case 2: return .identityServer(baseUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 3: return .ignoredUserList(ignoredUsers: try FfiConverterDictionaryStringTypeIgnoredUser.read(from: &buf)
        )
        
        case 4: return .pushRules(global: try FfiConverterTypeRuleset.read(from: &buf)
        )
        
        case 5: return .secretStorageDefaultKey(keyId: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .secretStorageKey(keyId: try FfiConverterString.read(from: &buf), name: try FfiConverterOptionString.read(from: &buf), algorithm: try FfiConverterTypeSecretStorageEncryptionAlgorithm.read(from: &buf), passphrase: try FfiConverterOptionTypePassPhrase.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountDataEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .direct(map):
            writeInt(&buf, Int32(1))
            FfiConverterDictionaryStringSequenceString.write(map, into: &buf)
            
        
        case let .identityServer(baseUrl):
            writeInt(&buf, Int32(2))
            FfiConverterOptionString.write(baseUrl, into: &buf)
            
        
        case let .ignoredUserList(ignoredUsers):
            writeInt(&buf, Int32(3))
            FfiConverterDictionaryStringTypeIgnoredUser.write(ignoredUsers, into: &buf)
            
        
        case let .pushRules(global):
            writeInt(&buf, Int32(4))
            FfiConverterTypeRuleset.write(global, into: &buf)
            
        
        case let .secretStorageDefaultKey(keyId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(keyId, into: &buf)
            
        
        case let .secretStorageKey(keyId,name,algorithm,passphrase):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(keyId, into: &buf)
            FfiConverterOptionString.write(name, into: &buf)
            FfiConverterTypeSecretStorageEncryptionAlgorithm.write(algorithm, into: &buf)
            FfiConverterOptionTypePassPhrase.write(passphrase, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountDataEvent_lift(_ buf: RustBuffer) throws -> AccountDataEvent {
    return try FfiConverterTypeAccountDataEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountDataEvent_lower(_ value: AccountDataEvent) -> RustBuffer {
    return FfiConverterTypeAccountDataEvent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Types of global account data events.
 */

public enum AccountDataEventType: Equatable, Hashable {
    
    /**
     * m.direct
     */
    case direct
    /**
     * m.identity_server
     */
    case identityServer
    /**
     * m.ignored_user_list
     */
    case ignoredUserList
    /**
     * m.push_rules
     */
    case pushRules
    /**
     * m.secret_storage.default_key
     */
    case secretStorageDefaultKey
    /**
     * m.secret_storage.key.*
     */
    case secretStorageKey(keyId: String
    )





}

#if compiler(>=6)
extension AccountDataEventType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountDataEventType: FfiConverterRustBuffer {
    typealias SwiftType = AccountDataEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountDataEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .direct
        
        case 2: return .identityServer
        
        case 3: return .ignoredUserList
        
        case 4: return .pushRules
        
        case 5: return .secretStorageDefaultKey
        
        case 6: return .secretStorageKey(keyId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountDataEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .direct:
            writeInt(&buf, Int32(1))
        
        
        case .identityServer:
            writeInt(&buf, Int32(2))
        
        
        case .ignoredUserList:
            writeInt(&buf, Int32(3))
        
        
        case .pushRules:
            writeInt(&buf, Int32(4))
        
        
        case .secretStorageDefaultKey:
            writeInt(&buf, Int32(5))
        
        
        case let .secretStorageKey(keyId):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(keyId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountDataEventType_lift(_ buf: RustBuffer) throws -> AccountDataEventType {
    return try FfiConverterTypeAccountDataEventType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountDataEventType_lower(_ value: AccountDataEventType) -> RustBuffer {
    return FfiConverterTypeAccountDataEventType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AccountManagementAction: Equatable, Hashable {
    
    case profile
    case sessionsList
    case sessionView(deviceId: String
    )
    case sessionEnd(deviceId: String
    )
    case accountDeactivate
    case crossSigningReset





}

#if compiler(>=6)
extension AccountManagementAction: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAccountManagementAction: FfiConverterRustBuffer {
    typealias SwiftType = AccountManagementAction

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AccountManagementAction {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .profile
        
        case 2: return .sessionsList
        
        case 3: return .sessionView(deviceId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .sessionEnd(deviceId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .accountDeactivate
        
        case 6: return .crossSigningReset
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AccountManagementAction, into buf: inout [UInt8]) {
        switch value {
        
        
        case .profile:
            writeInt(&buf, Int32(1))
        
        
        case .sessionsList:
            writeInt(&buf, Int32(2))
        
        
        case let .sessionView(deviceId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(deviceId, into: &buf)
            
        
        case let .sessionEnd(deviceId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(deviceId, into: &buf)
            
        
        case .accountDeactivate:
            writeInt(&buf, Int32(5))
        
        
        case .crossSigningReset:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountManagementAction_lift(_ buf: RustBuffer) throws -> AccountManagementAction {
    return try FfiConverterTypeAccountManagementAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAccountManagementAction_lower(_ value: AccountManagementAction) -> RustBuffer {
    return FfiConverterTypeAccountManagementAction.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing the push notification actions for a rule.
 */

public enum Action: Equatable, Hashable {
    
    /**
     * Causes matching events to generate a notification.
     */
    case notify
    /**
     * Sets an entry in the 'tweaks' dictionary sent to the push gateway.
     */
    case setTweak(value: Tweak
    )





}

#if compiler(>=6)
extension Action: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAction: FfiConverterRustBuffer {
    typealias SwiftType = Action

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Action {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notify
        
        case 2: return .setTweak(value: try FfiConverterTypeTweak.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Action, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notify:
            writeInt(&buf, Int32(1))
        
        
        case let .setTweak(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTweak.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAction_lift(_ buf: RustBuffer) throws -> Action {
    return try FfiConverterTypeAction.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAction_lower(_ value: Action) -> RustBuffer {
    return FfiConverterTypeAction.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An allow rule which defines a condition that allows joining a room.
 */

public enum AllowRule: Equatable, Hashable {
    
    /**
     * Only a member of the `room_id` Room can join the one this rule is used
     * in.
     */
    case roomMembership(roomId: String
    )
    /**
     * A custom allow rule implementation, containing its JSON representation
     * as a `String`.
     */
    case custom(json: String
    )





}

#if compiler(>=6)
extension AllowRule: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAllowRule: FfiConverterRustBuffer {
    typealias SwiftType = AllowRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AllowRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .roomMembership(roomId: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .custom(json: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AllowRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .roomMembership(roomId):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(roomId, into: &buf)
            
        
        case let .custom(json):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(json, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAllowRule_lift(_ buf: RustBuffer) throws -> AllowRule {
    return try FfiConverterTypeAllowRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAllowRule_lower(_ value: AllowRule) -> RustBuffer {
    return FfiConverterTypeAllowRule.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AssetType: Equatable, Hashable {
    
    case sender
    case pin





}

#if compiler(>=6)
extension AssetType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAssetType: FfiConverterRustBuffer {
    typealias SwiftType = AssetType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AssetType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sender
        
        case 2: return .pin
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AssetType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .sender:
            writeInt(&buf, Int32(1))
        
        
        case .pin:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetType_lift(_ buf: RustBuffer) throws -> AssetType {
    return try FfiConverterTypeAssetType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAssetType_lower(_ value: AssetType) -> RustBuffer {
    return FfiConverterTypeAssetType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthData: Equatable, Hashable {
    
    /**
     * Password-based authentication (`m.login.password`).
     */
    case password(passwordDetails: AuthDataPasswordDetails
    )





}

#if compiler(>=6)
extension AuthData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeAuthData: FfiConverterRustBuffer {
    typealias SwiftType = AuthData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .password(passwordDetails: try FfiConverterTypeAuthDataPasswordDetails.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .password(passwordDetails):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAuthDataPasswordDetails.write(passwordDetails, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthData_lift(_ buf: RustBuffer) throws -> AuthData {
    return try FfiConverterTypeAuthData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeAuthData_lower(_ value: AuthData) -> RustBuffer {
    return FfiConverterTypeAuthData.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BackupState: Equatable, Hashable {
    
    case unknown
    case creating
    case enabling
    case resuming
    case enabled
    case downloading
    case disabling





}

#if compiler(>=6)
extension BackupState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackupState: FfiConverterRustBuffer {
    typealias SwiftType = BackupState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .creating
        
        case 3: return .enabling
        
        case 4: return .resuming
        
        case 5: return .enabled
        
        case 6: return .downloading
        
        case 7: return .disabling
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BackupState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .creating:
            writeInt(&buf, Int32(2))
        
        
        case .enabling:
            writeInt(&buf, Int32(3))
        
        
        case .resuming:
            writeInt(&buf, Int32(4))
        
        
        case .enabled:
            writeInt(&buf, Int32(5))
        
        
        case .downloading:
            writeInt(&buf, Int32(6))
        
        
        case .disabling:
            writeInt(&buf, Int32(7))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupState_lift(_ buf: RustBuffer) throws -> BackupState {
    return try FfiConverterTypeBackupState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupState_lower(_ value: BackupState) -> RustBuffer {
    return FfiConverterTypeBackupState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BackupUploadState: Equatable, Hashable {
    
    case waiting
    case uploading(backedUpCount: UInt32, totalCount: UInt32
    )
    case error
    case done





}

#if compiler(>=6)
extension BackupUploadState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBackupUploadState: FfiConverterRustBuffer {
    typealias SwiftType = BackupUploadState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BackupUploadState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .waiting
        
        case 2: return .uploading(backedUpCount: try FfiConverterUInt32.read(from: &buf), totalCount: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 3: return .error
        
        case 4: return .done
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BackupUploadState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .waiting:
            writeInt(&buf, Int32(1))
        
        
        case let .uploading(backedUpCount,totalCount):
            writeInt(&buf, Int32(2))
            FfiConverterUInt32.write(backedUpCount, into: &buf)
            FfiConverterUInt32.write(totalCount, into: &buf)
            
        
        case .error:
            writeInt(&buf, Int32(3))
        
        
        case .done:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupUploadState_lift(_ buf: RustBuffer) throws -> BackupUploadState {
    return try FfiConverterTypeBackupUploadState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBackupUploadState_lower(_ value: BackupUploadState) -> RustBuffer {
    return FfiConverterTypeBackupUploadState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum BatchNotificationResult {
    
    /**
     * We have more detailed information about the notification.
     */
    case ok(status: NotificationStatus
    )
    /**
     * An error occurred while trying to fetch the notification.
     */
    case error(
        /**
         * The error message observed while handling a specific notification.
         */message: String
    )





}

#if compiler(>=6)
extension BatchNotificationResult: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeBatchNotificationResult: FfiConverterRustBuffer {
    typealias SwiftType = BatchNotificationResult

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> BatchNotificationResult {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ok(status: try FfiConverterTypeNotificationStatus.read(from: &buf)
        )
        
        case 2: return .error(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: BatchNotificationResult, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .ok(status):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNotificationStatus.write(status, into: &buf)
            
        
        case let .error(message):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchNotificationResult_lift(_ buf: RustBuffer) throws -> BatchNotificationResult {
    return try FfiConverterTypeBatchNotificationResult.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeBatchNotificationResult_lower(_ value: BatchNotificationResult) -> RustBuffer {
    return FfiConverterTypeBatchNotificationResult.lower(value)
}



public enum ClientBuildError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidServerName(message: String)
    
    case ServerUnreachable(message: String)
    
    case WellKnownLookupFailed(message: String)
    
    case WellKnownDeserializationError(message: String)
    
    case SlidingSync(message: String)
    
    case SlidingSyncVersion(message: String)
    
    case Sdk(message: String)
    
    case EventCache(message: String)
    
    case Generic(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ClientBuildError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientBuildError: FfiConverterRustBuffer {
    typealias SwiftType = ClientBuildError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientBuildError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidServerName(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .ServerUnreachable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .WellKnownLookupFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .WellKnownDeserializationError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .SlidingSync(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .SlidingSyncVersion(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .Sdk(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .EventCache(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientBuildError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidServerName(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .ServerUnreachable(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .WellKnownLookupFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .WellKnownDeserializationError(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .SlidingSync(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .SlidingSyncVersion(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .Sdk(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .EventCache(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientBuildError_lift(_ buf: RustBuffer) throws -> ClientBuildError {
    return try FfiConverterTypeClientBuildError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientBuildError_lower(_ value: ClientBuildError) -> RustBuffer {
    return FfiConverterTypeClientBuildError.lower(value)
}


public enum ClientError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Generic(msg: String, details: String?
    )
    case MatrixApi(kind: ErrorKind, code: String, msg: String, details: String?
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ClientError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeClientError: FfiConverterRustBuffer {
    typealias SwiftType = ClientError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            msg: try FfiConverterString.read(from: &buf), 
            details: try FfiConverterOptionString.read(from: &buf)
            )
        case 2: return .MatrixApi(
            kind: try FfiConverterTypeErrorKind.read(from: &buf), 
            code: try FfiConverterString.read(from: &buf), 
            msg: try FfiConverterString.read(from: &buf), 
            details: try FfiConverterOptionString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ClientError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(msg,details):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            FfiConverterOptionString.write(details, into: &buf)
            
        
        case let .MatrixApi(kind,code,msg,details):
            writeInt(&buf, Int32(2))
            FfiConverterTypeErrorKind.write(kind, into: &buf)
            FfiConverterString.write(code, into: &buf)
            FfiConverterString.write(msg, into: &buf)
            FfiConverterOptionString.write(details, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lift(_ buf: RustBuffer) throws -> ClientError {
    return try FfiConverterTypeClientError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeClientError_lower(_ value: ClientError) -> RustBuffer {
    return FfiConverterTypeClientError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ComparisonOperator: Equatable, Hashable {
    
    /**
     * Equals
     */
    case eq
    /**
     * Less than
     */
    case lt
    /**
     * Greater than
     */
    case gt
    /**
     * Greater or equal
     */
    case ge
    /**
     * Less or equal
     */
    case le





}

#if compiler(>=6)
extension ComparisonOperator: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeComparisonOperator: FfiConverterRustBuffer {
    typealias SwiftType = ComparisonOperator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComparisonOperator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eq
        
        case 2: return .lt
        
        case 3: return .gt
        
        case 4: return .ge
        
        case 5: return .le
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ComparisonOperator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .eq:
            writeInt(&buf, Int32(1))
        
        
        case .lt:
            writeInt(&buf, Int32(2))
        
        
        case .gt:
            writeInt(&buf, Int32(3))
        
        
        case .ge:
            writeInt(&buf, Int32(4))
        
        
        case .le:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComparisonOperator_lift(_ buf: RustBuffer) throws -> ComparisonOperator {
    return try FfiConverterTypeComparisonOperator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComparisonOperator_lower(_ value: ComparisonOperator) -> RustBuffer {
    return FfiConverterTypeComparisonOperator.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of draft of the composer.
 */

public enum ComposerDraftType: Equatable, Hashable {
    
    /**
     * The draft is a new message.
     */
    case newMessage
    /**
     * The draft is a reply to an event.
     */
    case reply(
        /**
         * The ID of the event being replied to.
         */eventId: String
    )
    /**
     * The draft is an edit of an event.
     */
    case edit(
        /**
         * The ID of the event being edited.
         */eventId: String
    )





}

#if compiler(>=6)
extension ComposerDraftType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeComposerDraftType: FfiConverterRustBuffer {
    typealias SwiftType = ComposerDraftType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ComposerDraftType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .newMessage
        
        case 2: return .reply(eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .edit(eventId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ComposerDraftType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .newMessage:
            writeInt(&buf, Int32(1))
        
        
        case let .reply(eventId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .edit(eventId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(eventId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComposerDraftType_lift(_ buf: RustBuffer) throws -> ComposerDraftType {
    return try FfiConverterTypeComposerDraftType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeComposerDraftType_lower(_ value: ComposerDraftType) -> RustBuffer {
    return FfiConverterTypeComposerDraftType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CrossSigningResetAuthType: Equatable, Hashable {
    
    /**
     * The homeserver requires user-interactive authentication.
     */
    case uiaa
    case oidc(info: OidcCrossSigningResetInfo
    )





}

#if compiler(>=6)
extension CrossSigningResetAuthType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeCrossSigningResetAuthType: FfiConverterRustBuffer {
    typealias SwiftType = CrossSigningResetAuthType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CrossSigningResetAuthType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .uiaa
        
        case 2: return .oidc(info: try FfiConverterTypeOidcCrossSigningResetInfo.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CrossSigningResetAuthType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .uiaa:
            writeInt(&buf, Int32(1))
        
        
        case let .oidc(info):
            writeInt(&buf, Int32(2))
            FfiConverterTypeOidcCrossSigningResetInfo.write(info, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCrossSigningResetAuthType_lift(_ buf: RustBuffer) throws -> CrossSigningResetAuthType {
    return try FfiConverterTypeCrossSigningResetAuthType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeCrossSigningResetAuthType_lower(_ value: CrossSigningResetAuthType) -> RustBuffer {
    return FfiConverterTypeCrossSigningResetAuthType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Changes how date dividers get inserted, either in between each day or in
 * between each month
 */

public enum DateDividerMode: Equatable, Hashable {
    
    case daily
    case monthly





}

#if compiler(>=6)
extension DateDividerMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDateDividerMode: FfiConverterRustBuffer {
    typealias SwiftType = DateDividerMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateDividerMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .daily
        
        case 2: return .monthly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DateDividerMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .daily:
            writeInt(&buf, Int32(1))
        
        
        case .monthly:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDateDividerMode_lift(_ buf: RustBuffer) throws -> DateDividerMode {
    return try FfiConverterTypeDateDividerMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDateDividerMode_lower(_ value: DateDividerMode) -> RustBuffer {
    return FfiConverterTypeDateDividerMode.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An attachment stored with a composer draft.
 */

public enum DraftAttachment {
    
    case audio(audioInfo: AudioInfo, source: UploadSource
    )
    case file(fileInfo: FileInfo, source: UploadSource
    )
    case image(imageInfo: ImageInfo, source: UploadSource, thumbnailSource: UploadSource?
    )
    case video(videoInfo: VideoInfo, source: UploadSource, thumbnailSource: UploadSource?
    )





}

#if compiler(>=6)
extension DraftAttachment: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeDraftAttachment: FfiConverterRustBuffer {
    typealias SwiftType = DraftAttachment

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DraftAttachment {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .audio(audioInfo: try FfiConverterTypeAudioInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf)
        )
        
        case 2: return .file(fileInfo: try FfiConverterTypeFileInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf)
        )
        
        case 3: return .image(imageInfo: try FfiConverterTypeImageInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf), thumbnailSource: try FfiConverterOptionTypeUploadSource.read(from: &buf)
        )
        
        case 4: return .video(videoInfo: try FfiConverterTypeVideoInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf), thumbnailSource: try FfiConverterOptionTypeUploadSource.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DraftAttachment, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .audio(audioInfo,source):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAudioInfo.write(audioInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            
        
        case let .file(fileInfo,source):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFileInfo.write(fileInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            
        
        case let .image(imageInfo,source,thumbnailSource):
            writeInt(&buf, Int32(3))
            FfiConverterTypeImageInfo.write(imageInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            FfiConverterOptionTypeUploadSource.write(thumbnailSource, into: &buf)
            
        
        case let .video(videoInfo,source,thumbnailSource):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoInfo.write(videoInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            FfiConverterOptionTypeUploadSource.write(thumbnailSource, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDraftAttachment_lift(_ buf: RustBuffer) throws -> DraftAttachment {
    return try FfiConverterTypeDraftAttachment.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeDraftAttachment_lower(_ value: DraftAttachment) -> RustBuffer {
    return FfiConverterTypeDraftAttachment.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EditedContent {
    
    case roomMessage(content: RoomMessageEventContentWithoutRelation
    )
    case mediaCaption(caption: String?, formattedCaption: FormattedBody?, mentions: Mentions?
    )
    case pollStart(pollData: PollData
    )





}

#if compiler(>=6)
extension EditedContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEditedContent: FfiConverterRustBuffer {
    typealias SwiftType = EditedContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EditedContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .roomMessage(content: try FfiConverterTypeRoomMessageEventContentWithoutRelation.read(from: &buf)
        )
        
        case 2: return .mediaCaption(caption: try FfiConverterOptionString.read(from: &buf), formattedCaption: try FfiConverterOptionTypeFormattedBody.read(from: &buf), mentions: try FfiConverterOptionTypeMentions.read(from: &buf)
        )
        
        case 3: return .pollStart(pollData: try FfiConverterTypePollData.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EditedContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .roomMessage(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeRoomMessageEventContentWithoutRelation.write(content, into: &buf)
            
        
        case let .mediaCaption(caption,formattedCaption,mentions):
            writeInt(&buf, Int32(2))
            FfiConverterOptionString.write(caption, into: &buf)
            FfiConverterOptionTypeFormattedBody.write(formattedCaption, into: &buf)
            FfiConverterOptionTypeMentions.write(mentions, into: &buf)
            
        
        case let .pollStart(pollData):
            writeInt(&buf, Int32(3))
            FfiConverterTypePollData.write(pollData, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEditedContent_lift(_ buf: RustBuffer) throws -> EditedContent {
    return try FfiConverterTypeEditedContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEditedContent_lower(_ value: EditedContent) -> RustBuffer {
    return FfiConverterTypeEditedContent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EmbeddedEventDetails {
    
    case unavailable
    case pending
    case ready(content: TimelineItemContent, sender: String, senderProfile: ProfileDetails, timestamp: Timestamp, eventOrTransactionId: EventOrTransactionId
    )
    case error(message: String
    )





}

#if compiler(>=6)
extension EmbeddedEventDetails: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEmbeddedEventDetails: FfiConverterRustBuffer {
    typealias SwiftType = EmbeddedEventDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EmbeddedEventDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unavailable
        
        case 2: return .pending
        
        case 3: return .ready(content: try FfiConverterTypeTimelineItemContent.read(from: &buf), sender: try FfiConverterString.read(from: &buf), senderProfile: try FfiConverterTypeProfileDetails.read(from: &buf), timestamp: try FfiConverterTypeTimestamp.read(from: &buf), eventOrTransactionId: try FfiConverterTypeEventOrTransactionId.read(from: &buf)
        )
        
        case 4: return .error(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EmbeddedEventDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unavailable:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case let .ready(content,sender,senderProfile,timestamp,eventOrTransactionId):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTimelineItemContent.write(content, into: &buf)
            FfiConverterString.write(sender, into: &buf)
            FfiConverterTypeProfileDetails.write(senderProfile, into: &buf)
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            FfiConverterTypeEventOrTransactionId.write(eventOrTransactionId, into: &buf)
            
        
        case let .error(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmbeddedEventDetails_lift(_ buf: RustBuffer) throws -> EmbeddedEventDetails {
    return try FfiConverterTypeEmbeddedEventDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEmbeddedEventDetails_lower(_ value: EmbeddedEventDetails) -> RustBuffer {
    return FfiConverterTypeEmbeddedEventDetails.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EnableRecoveryProgress: Equatable, Hashable {
    
    case starting
    case creatingBackup
    case creatingRecoveryKey
    case backingUp(backedUpCount: UInt32, totalCount: UInt32
    )
    case roomKeyUploadError
    case done(recoveryKey: String
    )





}

#if compiler(>=6)
extension EnableRecoveryProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEnableRecoveryProgress: FfiConverterRustBuffer {
    typealias SwiftType = EnableRecoveryProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EnableRecoveryProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .starting
        
        case 2: return .creatingBackup
        
        case 3: return .creatingRecoveryKey
        
        case 4: return .backingUp(backedUpCount: try FfiConverterUInt32.read(from: &buf), totalCount: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 5: return .roomKeyUploadError
        
        case 6: return .done(recoveryKey: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EnableRecoveryProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case .starting:
            writeInt(&buf, Int32(1))
        
        
        case .creatingBackup:
            writeInt(&buf, Int32(2))
        
        
        case .creatingRecoveryKey:
            writeInt(&buf, Int32(3))
        
        
        case let .backingUp(backedUpCount,totalCount):
            writeInt(&buf, Int32(4))
            FfiConverterUInt32.write(backedUpCount, into: &buf)
            FfiConverterUInt32.write(totalCount, into: &buf)
            
        
        case .roomKeyUploadError:
            writeInt(&buf, Int32(5))
        
        
        case let .done(recoveryKey):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(recoveryKey, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnableRecoveryProgress_lift(_ buf: RustBuffer) throws -> EnableRecoveryProgress {
    return try FfiConverterTypeEnableRecoveryProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEnableRecoveryProgress_lower(_ value: EnableRecoveryProgress) -> RustBuffer {
    return FfiConverterTypeEnableRecoveryProgress.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum EncryptedMessage: Equatable, Hashable {
    
    case olmV1Curve25519AesSha2(
        /**
         * The Curve25519 key of the sender.
         */senderKey: String
    )
    case megolmV1AesSha2(
        /**
         * The ID of the session used to encrypt the message.
         */sessionId: String, 
        /**
         * What we know about what caused this UTD. E.g. was this event sent
         * when we were not a member of this room?
         */cause: UtdCause
    )
    case unknown





}

#if compiler(>=6)
extension EncryptedMessage: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEncryptedMessage: FfiConverterRustBuffer {
    typealias SwiftType = EncryptedMessage

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EncryptedMessage {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .olmV1Curve25519AesSha2(senderKey: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .megolmV1AesSha2(sessionId: try FfiConverterString.read(from: &buf), cause: try FfiConverterTypeUtdCause.read(from: &buf)
        )
        
        case 3: return .unknown
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EncryptedMessage, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .olmV1Curve25519AesSha2(senderKey):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(senderKey, into: &buf)
            
        
        case let .megolmV1AesSha2(sessionId,cause):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(sessionId, into: &buf)
            FfiConverterTypeUtdCause.write(cause, into: &buf)
            
        
        case .unknown:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptedMessage_lift(_ buf: RustBuffer) throws -> EncryptedMessage {
    return try FfiConverterTypeEncryptedMessage.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEncryptedMessage_lower(_ value: EncryptedMessage) -> RustBuffer {
    return FfiConverterTypeEncryptedMessage.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ErrorKind: Equatable, Hashable {
    
    /**
     * `M_BAD_ALIAS`
     *
     * One or more [room aliases] within the `m.room.canonical_alias` event do
     * not point to the room ID for which the state event is to be sent to.
     *
     * [room aliases]: https://spec.matrix.org/latest/client-server-api/#room-aliases
     */
    case badAlias
    /**
     * `M_BAD_JSON`
     *
     * The request contained valid JSON, but it was malformed in some way, e.g.
     * missing required keys, invalid values for keys.
     */
    case badJson
    /**
     * `M_BAD_STATE`
     *
     * The state change requested cannot be performed, such as attempting to
     * unban a user who is not banned.
     */
    case badState
    /**
     * `M_BAD_STATUS`
     *
     * The application service returned a bad status.
     */
    case badStatus(
        /**
         * The HTTP status code of the response.
         */status: UInt16?, 
        /**
         * The body of the response.
         */body: String?
    )
    /**
     * `M_CANNOT_LEAVE_SERVER_NOTICE_ROOM`
     *
     * The user is unable to reject an invite to join the [server notices]
     * room.
     *
     * [server notices]: https://spec.matrix.org/latest/client-server-api/#server-notices
     */
    case cannotLeaveServerNoticeRoom
    /**
     * `M_CANNOT_OVERWRITE_MEDIA`
     *
     * The [`create_content_async`] endpoint was called with a media ID that
     * already has content.
     *
     * [`create_content_async`]: crate::media::create_content_async
     */
    case cannotOverwriteMedia
    /**
     * `M_CAPTCHA_INVALID`
     *
     * The Captcha provided did not match what was expected.
     */
    case captchaInvalid
    /**
     * `M_CAPTCHA_NEEDED`
     *
     * A Captcha is required to complete the request.
     */
    case captchaNeeded
    /**
     * `M_CONNECTION_FAILED`
     *
     * The connection to the application service failed.
     */
    case connectionFailed
    /**
     * `M_CONNECTION_TIMEOUT`
     *
     * The connection to the application service timed out.
     */
    case connectionTimeout
    /**
     * `M_DUPLICATE_ANNOTATION`
     *
     * The request is an attempt to send a [duplicate annotation].
     *
     * [duplicate annotation]: https://spec.matrix.org/latest/client-server-api/#avoiding-duplicate-annotations
     */
    case duplicateAnnotation
    /**
     * `M_EXCLUSIVE`
     *
     * The resource being requested is reserved by an application service, or
     * the application service making the request has not created the
     * resource.
     */
    case exclusive
    /**
     * `M_FORBIDDEN`
     *
     * Forbidden access, e.g. joining a room without permission, failed login.
     */
    case forbidden
    /**
     * `M_GUEST_ACCESS_FORBIDDEN`
     *
     * The room or resource does not permit [guests] to access it.
     *
     * [guests]: https://spec.matrix.org/latest/client-server-api/#guest-access
     */
    case guestAccessForbidden
    /**
     * `M_INCOMPATIBLE_ROOM_VERSION`
     *
     * The client attempted to join a room that has a version the server does
     * not support.
     */
    case incompatibleRoomVersion(
        /**
         * The room's version.
         */roomVersion: String
    )
    /**
     * `M_INVALID_PARAM`
     *
     * A parameter that was specified has the wrong value. For example, the
     * server expected an integer and instead received a string.
     */
    case invalidParam
    /**
     * `M_INVALID_ROOM_STATE`
     *
     * The initial state implied by the parameters to the [`create_room`]
     * request is invalid, e.g. the user's `power_level` is set below that
     * necessary to set the room name.
     *
     * [`create_room`]: crate::room::create_room
     */
    case invalidRoomState
    /**
     * `M_INVALID_USERNAME`
     *
     * The desired user name is not valid.
     */
    case invalidUsername
    /**
     * `M_LIMIT_EXCEEDED`
     *
     * The request has been refused due to [rate limiting]: too many requests
     * have been sent in a short period of time.
     *
     * [rate limiting]: https://spec.matrix.org/latest/client-server-api/#rate-limiting
     */
    case limitExceeded(
        /**
         * How long a client should wait before they can try again.
         */retryAfterMs: UInt64?
    )
    /**
     * `M_MISSING_PARAM`
     *
     * A required parameter was missing from the request.
     */
    case missingParam
    /**
     * `M_MISSING_TOKEN`
     *
     * No [access token] was specified for the request, but one is required.
     *
     * [access token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
     */
    case missingToken
    /**
     * `M_NOT_FOUND`
     *
     * No resource was found for this request.
     */
    case notFound
    /**
     * `M_NOT_JSON`
     *
     * The request did not contain valid JSON.
     */
    case notJson
    /**
     * `M_NOT_YET_UPLOADED`
     *
     * An `mxc:` URI generated with the [`create_mxc_uri`] endpoint was used
     * and the content is not yet available.
     *
     * [`create_mxc_uri`]: crate::media::create_mxc_uri
     */
    case notYetUploaded
    /**
     * `M_RESOURCE_LIMIT_EXCEEDED`
     *
     * The request cannot be completed because the homeserver has reached a
     * resource limit imposed on it. For example, a homeserver held in a
     * shared hosting environment may reach a resource limit if it starts
     * using too much memory or disk space.
     */
    case resourceLimitExceeded(
        /**
         * A URI giving a contact method for the server administrator.
         */adminContact: String
    )
    /**
     * `M_ROOM_IN_USE`
     *
     * The [room alias] specified in the [`create_room`] request is already
     * taken.
     *
     * [`create_room`]: crate::room::create_room
     * [room alias]: https://spec.matrix.org/latest/client-server-api/#room-aliases
     */
    case roomInUse
    /**
     * `M_SERVER_NOT_TRUSTED`
     *
     * The client's request used a third-party server, e.g. identity server,
     * that this server does not trust.
     */
    case serverNotTrusted
    /**
     * `M_THREEPID_AUTH_FAILED`
     *
     * Authentication could not be performed on the [third-party identifier].
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    case threepidAuthFailed
    /**
     * `M_THREEPID_DENIED`
     *
     * The server does not permit this [third-party identifier]. This may
     * happen if the server only permits, for example, email addresses from
     * a particular domain.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    case threepidDenied
    /**
     * `M_THREEPID_IN_USE`
     *
     * The [third-party identifier] is already in use by another user.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    case threepidInUse
    /**
     * `M_THREEPID_MEDIUM_NOT_SUPPORTED`
     *
     * The homeserver does not support adding a [third-party identifier] of the
     * given medium.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    case threepidMediumNotSupported
    /**
     * `M_THREEPID_NOT_FOUND`
     *
     * No account matching the given [third-party identifier] could be found.
     *
     * [third-party identifier]: https://spec.matrix.org/latest/client-server-api/#adding-account-administrative-contact-information
     */
    case threepidNotFound
    /**
     * `M_TOO_LARGE`
     *
     * The request or entity was too large.
     */
    case tooLarge
    /**
     * `M_UNABLE_TO_AUTHORISE_JOIN`
     *
     * The room is [restricted] and none of the conditions can be validated by
     * the homeserver. This can happen if the homeserver does not know
     * about any of the rooms listed as conditions, for example.
     *
     * [restricted]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
     */
    case unableToAuthorizeJoin
    /**
     * `M_UNABLE_TO_GRANT_JOIN`
     *
     * A different server should be attempted for the join. This is typically
     * because the resident server can see that the joining user satisfies
     * one or more conditions, such as in the case of [restricted rooms],
     * but the resident server would be unable to meet the authorization
     * rules.
     *
     * [restricted rooms]: https://spec.matrix.org/latest/client-server-api/#restricted-rooms
     */
    case unableToGrantJoin
    /**
     * `M_UNAUTHORIZED`
     *
     * The request was not correctly authorized. Usually due to login failures.
     */
    case unauthorized
    /**
     * `M_UNKNOWN`
     *
     * An unknown error has occurred.
     */
    case unknown
    /**
     * `M_UNKNOWN_TOKEN`
     *
     * The [access or refresh token] specified was not recognized.
     *
     * [access or refresh token]: https://spec.matrix.org/latest/client-server-api/#client-authentication
     */
    case unknownToken(
        /**
         * If this is `true`, the client is in a "[soft logout]" state, i.e.
         * the server requires re-authentication but the session is not
         * invalidated. The client can acquire a new access token by
         * specifying the device ID it is already using to the login API.
         *
         * [soft logout]: https://spec.matrix.org/latest/client-server-api/#soft-logout
         */softLogout: Bool
    )
    /**
     * `M_UNRECOGNIZED`
     *
     * The server did not understand the request.
     *
     * This is expected to be returned with a 404 HTTP status code if the
     * endpoint is not implemented or a 405 HTTP status code if the
     * endpoint is implemented, but the incorrect HTTP method is used.
     */
    case unrecognized
    /**
     * `M_UNSUPPORTED_ROOM_VERSION`
     *
     * The request to [`create_room`] used a room version that the server does
     * not support.
     *
     * [`create_room`]: crate::room::create_room
     */
    case unsupportedRoomVersion
    /**
     * `M_URL_NOT_SET`
     *
     * The application service doesn't have a URL configured.
     */
    case urlNotSet
    /**
     * `M_USER_DEACTIVATED`
     *
     * The user ID associated with the request has been deactivated.
     */
    case userDeactivated
    /**
     * `M_USER_IN_USE`
     *
     * The desired user ID is already taken.
     */
    case userInUse
    /**
     * `M_USER_LOCKED`
     *
     * The account has been [locked] and cannot be used at this time.
     *
     * [locked]: https://spec.matrix.org/latest/client-server-api/#account-locking
     */
    case userLocked
    /**
     * `M_USER_SUSPENDED`
     *
     * The account has been [suspended] and can only be used for limited
     * actions at this time.
     *
     * [suspended]: https://spec.matrix.org/latest/client-server-api/#account-suspension
     */
    case userSuspended
    /**
     * `M_WEAK_PASSWORD`
     *
     * The password was [rejected] by the server for being too weak.
     *
     * [rejected]: https://spec.matrix.org/latest/client-server-api/#notes-on-password-management
     */
    case weakPassword
    /**
     * `M_WRONG_ROOM_KEYS_VERSION`
     *
     * The version of the [room keys backup] provided in the request does not
     * match the current backup version.
     *
     * [room keys backup]: https://spec.matrix.org/latest/client-server-api/#server-side-key-backups
     */
    case wrongRoomKeysVersion(
        /**
         * The currently active backup version.
         */currentVersion: String?
    )
    /**
     * A custom API error.
     */
    case custom(errcode: String
    )





}

#if compiler(>=6)
extension ErrorKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeErrorKind: FfiConverterRustBuffer {
    typealias SwiftType = ErrorKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ErrorKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .badAlias
        
        case 2: return .badJson
        
        case 3: return .badState
        
        case 4: return .badStatus(status: try FfiConverterOptionUInt16.read(from: &buf), body: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 5: return .cannotLeaveServerNoticeRoom
        
        case 6: return .cannotOverwriteMedia
        
        case 7: return .captchaInvalid
        
        case 8: return .captchaNeeded
        
        case 9: return .connectionFailed
        
        case 10: return .connectionTimeout
        
        case 11: return .duplicateAnnotation
        
        case 12: return .exclusive
        
        case 13: return .forbidden
        
        case 14: return .guestAccessForbidden
        
        case 15: return .incompatibleRoomVersion(roomVersion: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .invalidParam
        
        case 17: return .invalidRoomState
        
        case 18: return .invalidUsername
        
        case 19: return .limitExceeded(retryAfterMs: try FfiConverterOptionUInt64.read(from: &buf)
        )
        
        case 20: return .missingParam
        
        case 21: return .missingToken
        
        case 22: return .notFound
        
        case 23: return .notJson
        
        case 24: return .notYetUploaded
        
        case 25: return .resourceLimitExceeded(adminContact: try FfiConverterString.read(from: &buf)
        )
        
        case 26: return .roomInUse
        
        case 27: return .serverNotTrusted
        
        case 28: return .threepidAuthFailed
        
        case 29: return .threepidDenied
        
        case 30: return .threepidInUse
        
        case 31: return .threepidMediumNotSupported
        
        case 32: return .threepidNotFound
        
        case 33: return .tooLarge
        
        case 34: return .unableToAuthorizeJoin
        
        case 35: return .unableToGrantJoin
        
        case 36: return .unauthorized
        
        case 37: return .unknown
        
        case 38: return .unknownToken(softLogout: try FfiConverterBool.read(from: &buf)
        )
        
        case 39: return .unrecognized
        
        case 40: return .unsupportedRoomVersion
        
        case 41: return .urlNotSet
        
        case 42: return .userDeactivated
        
        case 43: return .userInUse
        
        case 44: return .userLocked
        
        case 45: return .userSuspended
        
        case 46: return .weakPassword
        
        case 47: return .wrongRoomKeysVersion(currentVersion: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 48: return .custom(errcode: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ErrorKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .badAlias:
            writeInt(&buf, Int32(1))
        
        
        case .badJson:
            writeInt(&buf, Int32(2))
        
        
        case .badState:
            writeInt(&buf, Int32(3))
        
        
        case let .badStatus(status,body):
            writeInt(&buf, Int32(4))
            FfiConverterOptionUInt16.write(status, into: &buf)
            FfiConverterOptionString.write(body, into: &buf)
            
        
        case .cannotLeaveServerNoticeRoom:
            writeInt(&buf, Int32(5))
        
        
        case .cannotOverwriteMedia:
            writeInt(&buf, Int32(6))
        
        
        case .captchaInvalid:
            writeInt(&buf, Int32(7))
        
        
        case .captchaNeeded:
            writeInt(&buf, Int32(8))
        
        
        case .connectionFailed:
            writeInt(&buf, Int32(9))
        
        
        case .connectionTimeout:
            writeInt(&buf, Int32(10))
        
        
        case .duplicateAnnotation:
            writeInt(&buf, Int32(11))
        
        
        case .exclusive:
            writeInt(&buf, Int32(12))
        
        
        case .forbidden:
            writeInt(&buf, Int32(13))
        
        
        case .guestAccessForbidden:
            writeInt(&buf, Int32(14))
        
        
        case let .incompatibleRoomVersion(roomVersion):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(roomVersion, into: &buf)
            
        
        case .invalidParam:
            writeInt(&buf, Int32(16))
        
        
        case .invalidRoomState:
            writeInt(&buf, Int32(17))
        
        
        case .invalidUsername:
            writeInt(&buf, Int32(18))
        
        
        case let .limitExceeded(retryAfterMs):
            writeInt(&buf, Int32(19))
            FfiConverterOptionUInt64.write(retryAfterMs, into: &buf)
            
        
        case .missingParam:
            writeInt(&buf, Int32(20))
        
        
        case .missingToken:
            writeInt(&buf, Int32(21))
        
        
        case .notFound:
            writeInt(&buf, Int32(22))
        
        
        case .notJson:
            writeInt(&buf, Int32(23))
        
        
        case .notYetUploaded:
            writeInt(&buf, Int32(24))
        
        
        case let .resourceLimitExceeded(adminContact):
            writeInt(&buf, Int32(25))
            FfiConverterString.write(adminContact, into: &buf)
            
        
        case .roomInUse:
            writeInt(&buf, Int32(26))
        
        
        case .serverNotTrusted:
            writeInt(&buf, Int32(27))
        
        
        case .threepidAuthFailed:
            writeInt(&buf, Int32(28))
        
        
        case .threepidDenied:
            writeInt(&buf, Int32(29))
        
        
        case .threepidInUse:
            writeInt(&buf, Int32(30))
        
        
        case .threepidMediumNotSupported:
            writeInt(&buf, Int32(31))
        
        
        case .threepidNotFound:
            writeInt(&buf, Int32(32))
        
        
        case .tooLarge:
            writeInt(&buf, Int32(33))
        
        
        case .unableToAuthorizeJoin:
            writeInt(&buf, Int32(34))
        
        
        case .unableToGrantJoin:
            writeInt(&buf, Int32(35))
        
        
        case .unauthorized:
            writeInt(&buf, Int32(36))
        
        
        case .unknown:
            writeInt(&buf, Int32(37))
        
        
        case let .unknownToken(softLogout):
            writeInt(&buf, Int32(38))
            FfiConverterBool.write(softLogout, into: &buf)
            
        
        case .unrecognized:
            writeInt(&buf, Int32(39))
        
        
        case .unsupportedRoomVersion:
            writeInt(&buf, Int32(40))
        
        
        case .urlNotSet:
            writeInt(&buf, Int32(41))
        
        
        case .userDeactivated:
            writeInt(&buf, Int32(42))
        
        
        case .userInUse:
            writeInt(&buf, Int32(43))
        
        
        case .userLocked:
            writeInt(&buf, Int32(44))
        
        
        case .userSuspended:
            writeInt(&buf, Int32(45))
        
        
        case .weakPassword:
            writeInt(&buf, Int32(46))
        
        
        case let .wrongRoomKeysVersion(currentVersion):
            writeInt(&buf, Int32(47))
            FfiConverterOptionString.write(currentVersion, into: &buf)
            
        
        case let .custom(errcode):
            writeInt(&buf, Int32(48))
            FfiConverterString.write(errcode, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorKind_lift(_ buf: RustBuffer) throws -> ErrorKind {
    return try FfiConverterTypeErrorKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeErrorKind_lower(_ value: ErrorKind) -> RustBuffer {
    return FfiConverterTypeErrorKind.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Contains the 2 possible identifiers of an event, either it has a remote
 * event id or a local transaction id, never both or none.
 */

public enum EventOrTransactionId: Equatable, Hashable {
    
    case eventId(eventId: String
    )
    case transactionId(transactionId: String
    )





}

#if compiler(>=6)
extension EventOrTransactionId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventOrTransactionId: FfiConverterRustBuffer {
    typealias SwiftType = EventOrTransactionId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventOrTransactionId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventId(eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .transactionId(transactionId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventOrTransactionId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventId(eventId):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .transactionId(transactionId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(transactionId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventOrTransactionId_lift(_ buf: RustBuffer) throws -> EventOrTransactionId {
    return try FfiConverterTypeEventOrTransactionId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventOrTransactionId_lower(_ value: EventOrTransactionId) -> RustBuffer {
    return FfiConverterTypeEventOrTransactionId.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * This type represents the â€œsend stateâ€ of a local event timeline item.
 */

public enum EventSendState: Equatable, Hashable {
    
    /**
     * The local event has not been sent yet.
     */
    case notSentYet(
        /**
         * The progress of the sending operation, if the event involves a media
         * upload.
         */progress: MediaUploadProgress?
    )
    /**
     * The local event has been sent to the server, but unsuccessfully: The
     * sending has failed.
     */
    case sendingFailed(
        /**
         * The error reason, with information for the user.
         */error: QueueWedgeError, 
        /**
         * Whether the error is considered recoverable or not.
         *
         * An error that's recoverable will disable the room's send queue,
         * while an unrecoverable error will be parked, until the user
         * decides to cancel sending it.
         */isRecoverable: Bool
    )
    /**
     * The local event has been sent successfully to the server.
     */
    case sent(eventId: String
    )





}

#if compiler(>=6)
extension EventSendState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> EventSendState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notSentYet(progress: try FfiConverterOptionTypeMediaUploadProgress.read(from: &buf)
        )
        
        case 2: return .sendingFailed(error: try FfiConverterTypeQueueWedgeError.read(from: &buf), isRecoverable: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .sent(eventId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: EventSendState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .notSentYet(progress):
            writeInt(&buf, Int32(1))
            FfiConverterOptionTypeMediaUploadProgress.write(progress, into: &buf)
            
        
        case let .sendingFailed(error,isRecoverable):
            writeInt(&buf, Int32(2))
            FfiConverterTypeQueueWedgeError.write(error, into: &buf)
            FfiConverterBool.write(isRecoverable, into: &buf)
            
        
        case let .sent(eventId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(eventId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventSendState_lift(_ buf: RustBuffer) throws -> EventSendState {
    return try FfiConverterTypeEventSendState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeEventSendState_lower(_ value: EventSendState) -> RustBuffer {
    return FfiConverterTypeEventSendState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FilterTimelineEventType: Equatable, Hashable {
    
    case messageLike(eventType: MessageLikeEventType
    )
    case state(eventType: StateEventType
    )





}

#if compiler(>=6)
extension FilterTimelineEventType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFilterTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = FilterTimelineEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FilterTimelineEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLike(eventType: try FfiConverterTypeMessageLikeEventType.read(from: &buf)
        )
        
        case 2: return .state(eventType: try FfiConverterTypeStateEventType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FilterTimelineEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLike(eventType):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageLikeEventType.write(eventType, into: &buf)
            
        
        case let .state(eventType):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStateEventType.write(eventType, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilterTimelineEventType_lift(_ buf: RustBuffer) throws -> FilterTimelineEventType {
    return try FfiConverterTypeFilterTimelineEventType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFilterTimelineEventType_lower(_ value: FilterTimelineEventType) -> RustBuffer {
    return FfiConverterTypeFilterTimelineEventType.lower(value)
}



public enum FocusEventError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidEventId(eventId: String, err: String
    )
    case EventNotFound(eventId: String
    )
    case Other(msg: String
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension FocusEventError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeFocusEventError: FfiConverterRustBuffer {
    typealias SwiftType = FocusEventError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FocusEventError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidEventId(
            eventId: try FfiConverterString.read(from: &buf), 
            err: try FfiConverterString.read(from: &buf)
            )
        case 2: return .EventNotFound(
            eventId: try FfiConverterString.read(from: &buf)
            )
        case 3: return .Other(
            msg: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FocusEventError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .InvalidEventId(eventId,err):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventId, into: &buf)
            FfiConverterString.write(err, into: &buf)
            
        
        case let .EventNotFound(eventId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .Other(msg):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFocusEventError_lift(_ buf: RustBuffer) throws -> FocusEventError {
    return try FfiConverterTypeFocusEventError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeFocusEventError_lower(_ value: FocusEventError) -> RustBuffer {
    return FfiConverterTypeFocusEventError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GalleryItemInfo {
    
    case audio(audioInfo: AudioInfo, source: UploadSource, caption: String?, formattedCaption: FormattedBody?
    )
    case file(fileInfo: FileInfo, source: UploadSource, caption: String?, formattedCaption: FormattedBody?
    )
    case image(imageInfo: ImageInfo, source: UploadSource, caption: String?, formattedCaption: FormattedBody?, thumbnailSource: UploadSource?
    )
    case video(videoInfo: VideoInfo, source: UploadSource, caption: String?, formattedCaption: FormattedBody?, thumbnailSource: UploadSource?
    )





}

#if compiler(>=6)
extension GalleryItemInfo: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGalleryItemInfo: FfiConverterRustBuffer {
    typealias SwiftType = GalleryItemInfo

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GalleryItemInfo {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .audio(audioInfo: try FfiConverterTypeAudioInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf), caption: try FfiConverterOptionString.read(from: &buf), formattedCaption: try FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
        
        case 2: return .file(fileInfo: try FfiConverterTypeFileInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf), caption: try FfiConverterOptionString.read(from: &buf), formattedCaption: try FfiConverterOptionTypeFormattedBody.read(from: &buf)
        )
        
        case 3: return .image(imageInfo: try FfiConverterTypeImageInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf), caption: try FfiConverterOptionString.read(from: &buf), formattedCaption: try FfiConverterOptionTypeFormattedBody.read(from: &buf), thumbnailSource: try FfiConverterOptionTypeUploadSource.read(from: &buf)
        )
        
        case 4: return .video(videoInfo: try FfiConverterTypeVideoInfo.read(from: &buf), source: try FfiConverterTypeUploadSource.read(from: &buf), caption: try FfiConverterOptionString.read(from: &buf), formattedCaption: try FfiConverterOptionTypeFormattedBody.read(from: &buf), thumbnailSource: try FfiConverterOptionTypeUploadSource.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GalleryItemInfo, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .audio(audioInfo,source,caption,formattedCaption):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAudioInfo.write(audioInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            FfiConverterOptionString.write(caption, into: &buf)
            FfiConverterOptionTypeFormattedBody.write(formattedCaption, into: &buf)
            
        
        case let .file(fileInfo,source,caption,formattedCaption):
            writeInt(&buf, Int32(2))
            FfiConverterTypeFileInfo.write(fileInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            FfiConverterOptionString.write(caption, into: &buf)
            FfiConverterOptionTypeFormattedBody.write(formattedCaption, into: &buf)
            
        
        case let .image(imageInfo,source,caption,formattedCaption,thumbnailSource):
            writeInt(&buf, Int32(3))
            FfiConverterTypeImageInfo.write(imageInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            FfiConverterOptionString.write(caption, into: &buf)
            FfiConverterOptionTypeFormattedBody.write(formattedCaption, into: &buf)
            FfiConverterOptionTypeUploadSource.write(thumbnailSource, into: &buf)
            
        
        case let .video(videoInfo,source,caption,formattedCaption,thumbnailSource):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoInfo.write(videoInfo, into: &buf)
            FfiConverterTypeUploadSource.write(source, into: &buf)
            FfiConverterOptionString.write(caption, into: &buf)
            FfiConverterOptionTypeFormattedBody.write(formattedCaption, into: &buf)
            FfiConverterOptionTypeUploadSource.write(thumbnailSource, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryItemInfo_lift(_ buf: RustBuffer) throws -> GalleryItemInfo {
    return try FfiConverterTypeGalleryItemInfo.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryItemInfo_lower(_ value: GalleryItemInfo) -> RustBuffer {
    return FfiConverterTypeGalleryItemInfo.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum GalleryItemType {
    
    case image(content: ImageMessageContent
    )
    case audio(content: AudioMessageContent
    )
    case video(content: VideoMessageContent
    )
    case file(content: FileMessageContent
    )
    case other(itemtype: String, body: String
    )





}

#if compiler(>=6)
extension GalleryItemType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGalleryItemType: FfiConverterRustBuffer {
    typealias SwiftType = GalleryItemType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GalleryItemType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .image(content: try FfiConverterTypeImageMessageContent.read(from: &buf)
        )
        
        case 2: return .audio(content: try FfiConverterTypeAudioMessageContent.read(from: &buf)
        )
        
        case 3: return .video(content: try FfiConverterTypeVideoMessageContent.read(from: &buf)
        )
        
        case 4: return .file(content: try FfiConverterTypeFileMessageContent.read(from: &buf)
        )
        
        case 5: return .other(itemtype: try FfiConverterString.read(from: &buf), body: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GalleryItemType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .image(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeImageMessageContent.write(content, into: &buf)
            
        
        case let .audio(content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAudioMessageContent.write(content, into: &buf)
            
        
        case let .video(content):
            writeInt(&buf, Int32(3))
            FfiConverterTypeVideoMessageContent.write(content, into: &buf)
            
        
        case let .file(content):
            writeInt(&buf, Int32(4))
            FfiConverterTypeFileMessageContent.write(content, into: &buf)
            
        
        case let .other(itemtype,body):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(itemtype, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryItemType_lift(_ buf: RustBuffer) throws -> GalleryItemType {
    return try FfiConverterTypeGalleryItemType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGalleryItemType_lower(_ value: GalleryItemType) -> RustBuffer {
    return FfiConverterTypeGalleryItemType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum describing the progress of logging in by generating a QR code and
 * having an existing device scan it.
 */

public enum GeneratedQrLoginProgress {
    
    /**
     * The login process is starting.
     */
    case starting
    /**
     * We have established the secure channel and now need to display the
     * QR code so that the existing device can scan it.
     */
    case qrReady(qrCode: QrCodeData
    )
    /**
     * The existing device has scanned the QR code and is displaying the
     * checkcode. We now need to ask the user to enter the checkcode so that
     * we can verify that the channel is indeed secure.
     */
    case qrScanned(checkCodeSender: CheckCodeSender
    )
    /**
     * We are waiting for the login and for the OAuth 2.0 authorization server
     * to give us an access token.
     */
    case waitingForToken(userCode: String
    )
    /**
     * We are syncing secrets.
     */
    case syncingSecrets
    /**
     * The login has successfully finished.
     */
    case done





}

#if compiler(>=6)
extension GeneratedQrLoginProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGeneratedQrLoginProgress: FfiConverterRustBuffer {
    typealias SwiftType = GeneratedQrLoginProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GeneratedQrLoginProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .starting
        
        case 2: return .qrReady(qrCode: try FfiConverterTypeQrCodeData.read(from: &buf)
        )
        
        case 3: return .qrScanned(checkCodeSender: try FfiConverterTypeCheckCodeSender.read(from: &buf)
        )
        
        case 4: return .waitingForToken(userCode: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .syncingSecrets
        
        case 6: return .done
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GeneratedQrLoginProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case .starting:
            writeInt(&buf, Int32(1))
        
        
        case let .qrReady(qrCode):
            writeInt(&buf, Int32(2))
            FfiConverterTypeQrCodeData.write(qrCode, into: &buf)
            
        
        case let .qrScanned(checkCodeSender):
            writeInt(&buf, Int32(3))
            FfiConverterTypeCheckCodeSender.write(checkCodeSender, into: &buf)
            
        
        case let .waitingForToken(userCode):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(userCode, into: &buf)
            
        
        case .syncingSecrets:
            writeInt(&buf, Int32(5))
        
        
        case .done:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratedQrLoginProgress_lift(_ buf: RustBuffer) throws -> GeneratedQrLoginProgress {
    return try FfiConverterTypeGeneratedQrLoginProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGeneratedQrLoginProgress_lower(_ value: GeneratedQrLoginProgress) -> RustBuffer {
    return FfiConverterTypeGeneratedQrLoginProgress.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum describing the progress of granting login by generating a QR code to
 * be scanned on the new device.
 */

public enum GrantGeneratedQrLoginProgress {
    
    /**
     * The login process is starting.
     */
    case starting
    /**
     * We have established the secure channel and now need to display the
     * QR code so that the existing device can scan it.
     */
    case qrReady(qrCode: QrCodeData
    )
    /**
     * The existing device has scanned the QR code and is displaying the
     * checkcode. We now need to ask the user to enter the checkcode so that
     * we can verify that the channel is indeed secure.
     */
    case qrScanned(checkCodeSender: CheckCodeSender
    )
    /**
     * The secure channel has been confirmed using the [`CheckCode`] and this
     * device is waiting for the authorization to complete.
     */
    case waitingForAuth(
        /**
         * A URI to open in a (secure) system browser to verify the new login.
         */verificationUri: String
    )
    /**
     * We are syncing secrets.
     */
    case syncingSecrets
    /**
     * The login has successfully finished.
     */
    case done





}

#if compiler(>=6)
extension GrantGeneratedQrLoginProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGrantGeneratedQrLoginProgress: FfiConverterRustBuffer {
    typealias SwiftType = GrantGeneratedQrLoginProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GrantGeneratedQrLoginProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .starting
        
        case 2: return .qrReady(qrCode: try FfiConverterTypeQrCodeData.read(from: &buf)
        )
        
        case 3: return .qrScanned(checkCodeSender: try FfiConverterTypeCheckCodeSender.read(from: &buf)
        )
        
        case 4: return .waitingForAuth(verificationUri: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .syncingSecrets
        
        case 6: return .done
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GrantGeneratedQrLoginProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case .starting:
            writeInt(&buf, Int32(1))
        
        
        case let .qrReady(qrCode):
            writeInt(&buf, Int32(2))
            FfiConverterTypeQrCodeData.write(qrCode, into: &buf)
            
        
        case let .qrScanned(checkCodeSender):
            writeInt(&buf, Int32(3))
            FfiConverterTypeCheckCodeSender.write(checkCodeSender, into: &buf)
            
        
        case let .waitingForAuth(verificationUri):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(verificationUri, into: &buf)
            
        
        case .syncingSecrets:
            writeInt(&buf, Int32(5))
        
        
        case .done:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrantGeneratedQrLoginProgress_lift(_ buf: RustBuffer) throws -> GrantGeneratedQrLoginProgress {
    return try FfiConverterTypeGrantGeneratedQrLoginProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrantGeneratedQrLoginProgress_lower(_ value: GrantGeneratedQrLoginProgress) -> RustBuffer {
    return FfiConverterTypeGrantGeneratedQrLoginProgress.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum describing the progress of granting login in by scanning a QR code that
 * was generated on a new device.
 */

public enum GrantQrLoginProgress: Equatable, Hashable {
    
    /**
     * The login process is starting.
     */
    case starting
    /**
     * We established a secure channel with the other device.
     */
    case establishingSecureChannel(
        /**
         * The check code that the device should display so the other device
         * can confirm that the channel is secure as well.
         */checkCode: UInt8, 
        /**
         * The string representation of the check code, will be guaranteed to
         * be 2 characters long, preserving the leading zero if the
         * first digit is a zero.
         */checkCodeString: String
    )
    /**
     * The secure channel has been confirmed using the [`CheckCode`] and this
     * device is waiting for the authorization to complete.
     */
    case waitingForAuth(
        /**
         * A URI to open in a (secure) system browser to verify the new login.
         */verificationUri: String
    )
    /**
     * We are syncing secrets.
     */
    case syncingSecrets
    /**
     * The login has successfully finished.
     */
    case done





}

#if compiler(>=6)
extension GrantQrLoginProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeGrantQrLoginProgress: FfiConverterRustBuffer {
    typealias SwiftType = GrantQrLoginProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> GrantQrLoginProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .starting
        
        case 2: return .establishingSecureChannel(checkCode: try FfiConverterUInt8.read(from: &buf), checkCodeString: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .waitingForAuth(verificationUri: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .syncingSecrets
        
        case 5: return .done
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: GrantQrLoginProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case .starting:
            writeInt(&buf, Int32(1))
        
        
        case let .establishingSecureChannel(checkCode,checkCodeString):
            writeInt(&buf, Int32(2))
            FfiConverterUInt8.write(checkCode, into: &buf)
            FfiConverterString.write(checkCodeString, into: &buf)
            
        
        case let .waitingForAuth(verificationUri):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(verificationUri, into: &buf)
            
        
        case .syncingSecrets:
            writeInt(&buf, Int32(4))
        
        
        case .done:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrantQrLoginProgress_lift(_ buf: RustBuffer) throws -> GrantQrLoginProgress {
    return try FfiConverterTypeGrantQrLoginProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeGrantQrLoginProgress_lower(_ value: GrantQrLoginProgress) -> RustBuffer {
    return FfiConverterTypeGrantQrLoginProgress.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum HistoryVisibility: Equatable, Hashable {
    
    /**
     * Previous events are accessible to newly joined members from the point
     * they were invited onwards.
     *
     * Events stop being accessible when the member' state changes to
     * something other than *invite* or *join*.
     */
    case invited
    /**
     * Previous events are accessible to newly joined members from the point
     * they joined the room onwards.
     * Events stop being accessible when the member' state changes to
     * something other than *join*.
     */
    case joined
    /**
     * Previous events are always accessible to newly joined members.
     *
     * All events in the room are accessible, even those sent when the member
     * was not a part of the room.
     */
    case shared
    /**
     * All events while this is the `HistoryVisibility` value may be shared by
     * any participating homeserver with anyone, regardless of whether they
     * have ever joined the room.
     */
    case worldReadable
    /**
     * A custom history visibility, up for interpretation by the consumer.
     */
    case custom(
        /**
         * The string representation for this custom history visibility.
         */repr: String
    )





}

#if compiler(>=6)
extension HistoryVisibility: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = HistoryVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HistoryVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invited
        
        case 2: return .joined
        
        case 3: return .shared
        
        case 4: return .worldReadable
        
        case 5: return .custom(repr: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HistoryVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invited:
            writeInt(&buf, Int32(1))
        
        
        case .joined:
            writeInt(&buf, Int32(2))
        
        
        case .shared:
            writeInt(&buf, Int32(3))
        
        
        case .worldReadable:
            writeInt(&buf, Int32(4))
        
        
        case let .custom(repr):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(repr, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoryVisibility_lift(_ buf: RustBuffer) throws -> HistoryVisibility {
    return try FfiConverterTypeHistoryVisibility.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHistoryVisibility_lower(_ value: HistoryVisibility) -> RustBuffer {
    return FfiConverterTypeHistoryVisibility.lower(value)
}



public enum HumanQrGrantLoginError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    /**
     * The requested device ID is already in use.
     */
    case DeviceIdAlreadyInUse(message: String)
    
    /**
     * The check code was incorrect.
     */
    case InvalidCheckCode(message: String)
    
    /**
     * The other client proposed an unsupported protocol.
     */
    case UnsupportedProtocol(message: String)
    
    /**
     * Secrets backup not set up properly.
     */
    case MissingSecretsBackup(message: String)
    
    /**
     * The rendezvous session was not found and might have expired.
     */
    case NotFound(message: String)
    
    /**
     * The device could not be created.
     */
    case UnableToCreateDevice(message: String)
    
    /**
     * An unknown error has happened.
     */
    case Unknown(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension HumanQrGrantLoginError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHumanQrGrantLoginError: FfiConverterRustBuffer {
    typealias SwiftType = HumanQrGrantLoginError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HumanQrGrantLoginError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .DeviceIdAlreadyInUse(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidCheckCode(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .UnsupportedProtocol(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .MissingSecretsBackup(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .NotFound(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .UnableToCreateDevice(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .Unknown(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HumanQrGrantLoginError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .DeviceIdAlreadyInUse(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidCheckCode(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .UnsupportedProtocol(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .MissingSecretsBackup(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .NotFound(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .UnableToCreateDevice(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .Unknown(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHumanQrGrantLoginError_lift(_ buf: RustBuffer) throws -> HumanQrGrantLoginError {
    return try FfiConverterTypeHumanQrGrantLoginError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHumanQrGrantLoginError_lower(_ value: HumanQrGrantLoginError) -> RustBuffer {
    return FfiConverterTypeHumanQrGrantLoginError.lower(value)
}


public enum HumanQrLoginError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case LinkingNotSupported
    case Cancelled
    case Expired
    case ConnectionInsecure
    case Declined
    case Unknown
    case SlidingSyncNotAvailable
    case OidcMetadataInvalid
    case OtherDeviceNotSignedIn
    case CheckCodeAlreadySent
    case CheckCodeCannotBeSent
    case NotFound

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension HumanQrLoginError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeHumanQrLoginError: FfiConverterRustBuffer {
    typealias SwiftType = HumanQrLoginError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> HumanQrLoginError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .LinkingNotSupported
        case 2: return .Cancelled
        case 3: return .Expired
        case 4: return .ConnectionInsecure
        case 5: return .Declined
        case 6: return .Unknown
        case 7: return .SlidingSyncNotAvailable
        case 8: return .OidcMetadataInvalid
        case 9: return .OtherDeviceNotSignedIn
        case 10: return .CheckCodeAlreadySent
        case 11: return .CheckCodeCannotBeSent
        case 12: return .NotFound

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: HumanQrLoginError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .LinkingNotSupported:
            writeInt(&buf, Int32(1))
        
        
        case .Cancelled:
            writeInt(&buf, Int32(2))
        
        
        case .Expired:
            writeInt(&buf, Int32(3))
        
        
        case .ConnectionInsecure:
            writeInt(&buf, Int32(4))
        
        
        case .Declined:
            writeInt(&buf, Int32(5))
        
        
        case .Unknown:
            writeInt(&buf, Int32(6))
        
        
        case .SlidingSyncNotAvailable:
            writeInt(&buf, Int32(7))
        
        
        case .OidcMetadataInvalid:
            writeInt(&buf, Int32(8))
        
        
        case .OtherDeviceNotSignedIn:
            writeInt(&buf, Int32(9))
        
        
        case .CheckCodeAlreadySent:
            writeInt(&buf, Int32(10))
        
        
        case .CheckCodeCannotBeSent:
            writeInt(&buf, Int32(11))
        
        
        case .NotFound:
            writeInt(&buf, Int32(12))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHumanQrLoginError_lift(_ buf: RustBuffer) throws -> HumanQrLoginError {
    return try FfiConverterTypeHumanQrLoginError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeHumanQrLoginError_lower(_ value: HumanQrLoginError) -> RustBuffer {
    return FfiConverterTypeHumanQrLoginError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The policy that decides if avatars should be shown in invite requests.
 */

public enum InviteAvatars: Equatable, Hashable {
    
    /**
     * Always show avatars in invite requests.
     */
    case on
    /**
     * Never show avatars in invite requests.
     */
    case off





}

#if compiler(>=6)
extension InviteAvatars: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeInviteAvatars: FfiConverterRustBuffer {
    typealias SwiftType = InviteAvatars

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InviteAvatars {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .on
        
        case 2: return .off
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InviteAvatars, into buf: inout [UInt8]) {
        switch value {
        
        
        case .on:
            writeInt(&buf, Int32(1))
        
        
        case .off:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteAvatars_lift(_ buf: RustBuffer) throws -> InviteAvatars {
    return try FfiConverterTypeInviteAvatars.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeInviteAvatars_lower(_ value: InviteAvatars) -> RustBuffer {
    return FfiConverterTypeInviteAvatars.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The rule used for users wishing to join this room.
 */

public enum JoinRule: Equatable, Hashable {
    
    /**
     * Anyone can join the room without any prior action.
     */
    case `public`
    /**
     * A user who wishes to join the room must first receive an invite to the
     * room from someone already inside of the room.
     */
    case invite
    /**
     * Users can join the room if they are invited, or they can request an
     * invite to the room.
     *
     * They can be allowed (invited) or denied (kicked/banned) access.
     */
    case knock
    /**
     * Reserved but not yet implemented by the Matrix specification.
     */
    case `private`
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s.
     */
    case restricted(rules: [AllowRule]
    )
    /**
     * Users can join the room if they are invited, or if they meet any of the
     * conditions described in a set of [`AllowRule`]s, or they can request
     * an invite to the room.
     */
    case knockRestricted(rules: [AllowRule]
    )
    /**
     * A custom join rule, up for interpretation by the consumer.
     */
    case custom(
        /**
         * The string representation for this custom rule.
         */repr: String
    )





}

#if compiler(>=6)
extension JoinRule: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = JoinRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JoinRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .invite
        
        case 3: return .knock
        
        case 4: return .`private`
        
        case 5: return .restricted(rules: try FfiConverterSequenceTypeAllowRule.read(from: &buf)
        )
        
        case 6: return .knockRestricted(rules: try FfiConverterSequenceTypeAllowRule.read(from: &buf)
        )
        
        case 7: return .custom(repr: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JoinRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .invite:
            writeInt(&buf, Int32(2))
        
        
        case .knock:
            writeInt(&buf, Int32(3))
        
        
        case .`private`:
            writeInt(&buf, Int32(4))
        
        
        case let .restricted(rules):
            writeInt(&buf, Int32(5))
            FfiConverterSequenceTypeAllowRule.write(rules, into: &buf)
            
        
        case let .knockRestricted(rules):
            writeInt(&buf, Int32(6))
            FfiConverterSequenceTypeAllowRule.write(rules, into: &buf)
            
        
        case let .custom(repr):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(repr, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJoinRule_lift(_ buf: RustBuffer) throws -> JoinRule {
    return try FfiConverterTypeJoinRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJoinRule_lower(_ value: JoinRule) -> RustBuffer {
    return FfiConverterTypeJoinRule.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum JsonValue: Equatable, Hashable {
    
    /**
     * Represents a `null` value.
     */
    case null
    /**
     * Represents a boolean.
     */
    case bool(value: Bool
    )
    /**
     * Represents an integer.
     */
    case integer(value: Int64
    )
    /**
     * Represents a string.
     */
    case string(value: String
    )





}

#if compiler(>=6)
extension JsonValue: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeJsonValue: FfiConverterRustBuffer {
    typealias SwiftType = JsonValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> JsonValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .null
        
        case 2: return .bool(value: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .integer(value: try FfiConverterInt64.read(from: &buf)
        )
        
        case 4: return .string(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: JsonValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case .null:
            writeInt(&buf, Int32(1))
        
        
        case let .bool(value):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .integer(value):
            writeInt(&buf, Int32(3))
            FfiConverterInt64.write(value, into: &buf)
            
        
        case let .string(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonValue_lift(_ buf: RustBuffer) throws -> JsonValue {
    return try FfiConverterTypeJsonValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeJsonValue_lower(_ value: JsonValue) -> RustBuffer {
    return FfiConverterTypeJsonValue.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A key algorithm to be used to generate a key from a passphrase.
 */

public enum KeyDerivationAlgorithm: Equatable, Hashable {
    
    /**
     * PBKDF2
     */
    case pbkfd2





}

#if compiler(>=6)
extension KeyDerivationAlgorithm: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeKeyDerivationAlgorithm: FfiConverterRustBuffer {
    typealias SwiftType = KeyDerivationAlgorithm

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyDerivationAlgorithm {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .pbkfd2
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: KeyDerivationAlgorithm, into buf: inout [UInt8]) {
        switch value {
        
        
        case .pbkfd2:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationAlgorithm_lift(_ buf: RustBuffer) throws -> KeyDerivationAlgorithm {
    return try FfiConverterTypeKeyDerivationAlgorithm.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeKeyDerivationAlgorithm_lower(_ value: KeyDerivationAlgorithm) -> RustBuffer {
    return FfiConverterTypeKeyDerivationAlgorithm.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Mimic the [`UiLatestEventValue`] type.
 */

public enum LatestEventValue {
    
    case none
    case remote(timestamp: Timestamp, sender: String, isOwn: Bool, profile: ProfileDetails, content: TimelineItemContent
    )
    case local(timestamp: Timestamp, sender: String, profile: ProfileDetails, content: TimelineItemContent, state: LatestEventValueLocalState
    )





}

#if compiler(>=6)
extension LatestEventValue: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLatestEventValue: FfiConverterRustBuffer {
    typealias SwiftType = LatestEventValue

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LatestEventValue {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .remote(timestamp: try FfiConverterTypeTimestamp.read(from: &buf), sender: try FfiConverterString.read(from: &buf), isOwn: try FfiConverterBool.read(from: &buf), profile: try FfiConverterTypeProfileDetails.read(from: &buf), content: try FfiConverterTypeTimelineItemContent.read(from: &buf)
        )
        
        case 3: return .local(timestamp: try FfiConverterTypeTimestamp.read(from: &buf), sender: try FfiConverterString.read(from: &buf), profile: try FfiConverterTypeProfileDetails.read(from: &buf), content: try FfiConverterTypeTimelineItemContent.read(from: &buf), state: try FfiConverterTypeLatestEventValueLocalState.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LatestEventValue, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case let .remote(timestamp,sender,isOwn,profile,content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            FfiConverterString.write(sender, into: &buf)
            FfiConverterBool.write(isOwn, into: &buf)
            FfiConverterTypeProfileDetails.write(profile, into: &buf)
            FfiConverterTypeTimelineItemContent.write(content, into: &buf)
            
        
        case let .local(timestamp,sender,profile,content,state):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTimestamp.write(timestamp, into: &buf)
            FfiConverterString.write(sender, into: &buf)
            FfiConverterTypeProfileDetails.write(profile, into: &buf)
            FfiConverterTypeTimelineItemContent.write(content, into: &buf)
            FfiConverterTypeLatestEventValueLocalState.write(state, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLatestEventValue_lift(_ buf: RustBuffer) throws -> LatestEventValue {
    return try FfiConverterTypeLatestEventValue.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLatestEventValue_lower(_ value: LatestEventValue) -> RustBuffer {
    return FfiConverterTypeLatestEventValue.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum LogLevel: Equatable, Hashable {
    
    case error
    case warn
    case info
    case debug
    case trace





}

#if compiler(>=6)
extension LogLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeLogLevel: FfiConverterRustBuffer {
    typealias SwiftType = LogLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LogLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .error
        
        case 2: return .warn
        
        case 3: return .info
        
        case 4: return .debug
        
        case 5: return .trace
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: LogLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .error:
            writeInt(&buf, Int32(1))
        
        
        case .warn:
            writeInt(&buf, Int32(2))
        
        
        case .info:
            writeInt(&buf, Int32(3))
        
        
        case .debug:
            writeInt(&buf, Int32(4))
        
        
        case .trace:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lift(_ buf: RustBuffer) throws -> LogLevel {
    return try FfiConverterTypeLogLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeLogLevel_lower(_ value: LogLevel) -> RustBuffer {
    return FfiConverterTypeLogLevel.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A Matrix ID that can be a room, room alias, user, or event.
 */

public enum MatrixId: Equatable, Hashable {
    
    case room(id: String
    )
    case roomAlias(alias: String
    )
    case user(id: String
    )
    case eventOnRoomId(roomId: String, eventId: String
    )
    case eventOnRoomAlias(alias: String, eventId: String
    )





}

#if compiler(>=6)
extension MatrixId: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMatrixId: FfiConverterRustBuffer {
    typealias SwiftType = MatrixId

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MatrixId {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .room(id: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .roomAlias(alias: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .user(id: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .eventOnRoomId(roomId: try FfiConverterString.read(from: &buf), eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .eventOnRoomAlias(alias: try FfiConverterString.read(from: &buf), eventId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MatrixId, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .room(id):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(id, into: &buf)
            
        
        case let .roomAlias(alias):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(alias, into: &buf)
            
        
        case let .user(id):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(id, into: &buf)
            
        
        case let .eventOnRoomId(roomId,eventId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(roomId, into: &buf)
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .eventOnRoomAlias(alias,eventId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(alias, into: &buf)
            FfiConverterString.write(eventId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixId_lift(_ buf: RustBuffer) throws -> MatrixId {
    return try FfiConverterTypeMatrixId.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMatrixId_lower(_ value: MatrixId) -> RustBuffer {
    return FfiConverterTypeMatrixId.lower(value)
}



public enum MediaInfoError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case MissingField(message: String)
    
    case InvalidField(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension MediaInfoError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMediaInfoError: FfiConverterRustBuffer {
    typealias SwiftType = MediaInfoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaInfoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .MissingField(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidField(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MediaInfoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .MissingField(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidField(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaInfoError_lift(_ buf: RustBuffer) throws -> MediaInfoError {
    return try FfiConverterTypeMediaInfoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaInfoError_lower(_ value: MediaInfoError) -> RustBuffer {
    return FfiConverterTypeMediaInfoError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The policy that decides if media previews should be shown in the timeline.
 */

public enum MediaPreviews: Equatable, Hashable {
    
    /**
     * Always show media previews in the timeline.
     */
    case on
    /**
     * Show media previews in the timeline only if the room is private.
     */
    case `private`
    /**
     * Never show media previews in the timeline.
     */
    case off





}

#if compiler(>=6)
extension MediaPreviews: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMediaPreviews: FfiConverterRustBuffer {
    typealias SwiftType = MediaPreviews

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MediaPreviews {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .on
        
        case 2: return .`private`
        
        case 3: return .off
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MediaPreviews, into buf: inout [UInt8]) {
        switch value {
        
        
        case .on:
            writeInt(&buf, Int32(1))
        
        
        case .`private`:
            writeInt(&buf, Int32(2))
        
        
        case .off:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaPreviews_lift(_ buf: RustBuffer) throws -> MediaPreviews {
    return try FfiConverterTypeMediaPreviews.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMediaPreviews_lower(_ value: MediaPreviews) -> RustBuffer {
    return FfiConverterTypeMediaPreviews.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum Membership: Equatable, Hashable {
    
    case invited
    case joined
    case left
    case knocked
    case banned





}

#if compiler(>=6)
extension Membership: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Membership {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invited
        
        case 2: return .joined
        
        case 3: return .left
        
        case 4: return .knocked
        
        case 5: return .banned
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Membership, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invited:
            writeInt(&buf, Int32(1))
        
        
        case .joined:
            writeInt(&buf, Int32(2))
        
        
        case .left:
            writeInt(&buf, Int32(3))
        
        
        case .knocked:
            writeInt(&buf, Int32(4))
        
        
        case .banned:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMembership_lift(_ buf: RustBuffer) throws -> Membership {
    return try FfiConverterTypeMembership.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMembership_lower(_ value: Membership) -> RustBuffer {
    return FfiConverterTypeMembership.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MembershipChange: Equatable, Hashable {
    
    case none
    case error
    case joined
    case left
    case banned
    case unbanned
    case kicked
    case invited
    case kickedAndBanned
    case invitationAccepted
    case invitationRejected
    case invitationRevoked
    case knocked
    case knockAccepted
    case knockRetracted
    case knockDenied
    case notImplemented





}

#if compiler(>=6)
extension MembershipChange: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipChange {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .error
        
        case 3: return .joined
        
        case 4: return .left
        
        case 5: return .banned
        
        case 6: return .unbanned
        
        case 7: return .kicked
        
        case 8: return .invited
        
        case 9: return .kickedAndBanned
        
        case 10: return .invitationAccepted
        
        case 11: return .invitationRejected
        
        case 12: return .invitationRevoked
        
        case 13: return .knocked
        
        case 14: return .knockAccepted
        
        case 15: return .knockRetracted
        
        case 16: return .knockDenied
        
        case 17: return .notImplemented
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipChange, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .error:
            writeInt(&buf, Int32(2))
        
        
        case .joined:
            writeInt(&buf, Int32(3))
        
        
        case .left:
            writeInt(&buf, Int32(4))
        
        
        case .banned:
            writeInt(&buf, Int32(5))
        
        
        case .unbanned:
            writeInt(&buf, Int32(6))
        
        
        case .kicked:
            writeInt(&buf, Int32(7))
        
        
        case .invited:
            writeInt(&buf, Int32(8))
        
        
        case .kickedAndBanned:
            writeInt(&buf, Int32(9))
        
        
        case .invitationAccepted:
            writeInt(&buf, Int32(10))
        
        
        case .invitationRejected:
            writeInt(&buf, Int32(11))
        
        
        case .invitationRevoked:
            writeInt(&buf, Int32(12))
        
        
        case .knocked:
            writeInt(&buf, Int32(13))
        
        
        case .knockAccepted:
            writeInt(&buf, Int32(14))
        
        
        case .knockRetracted:
            writeInt(&buf, Int32(15))
        
        
        case .knockDenied:
            writeInt(&buf, Int32(16))
        
        
        case .notImplemented:
            writeInt(&buf, Int32(17))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMembershipChange_lift(_ buf: RustBuffer) throws -> MembershipChange {
    return try FfiConverterTypeMembershipChange.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMembershipChange_lower(_ value: MembershipChange) -> RustBuffer {
    return FfiConverterTypeMembershipChange.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MembershipState: Equatable, Hashable {
    
    /**
     * The user is banned.
     */
    case ban
    /**
     * The user has been invited.
     */
    case invite
    /**
     * The user has joined.
     */
    case join
    /**
     * The user has requested to join.
     */
    case knock
    /**
     * The user has left.
     */
    case leave
    /**
     * A custom membership state value.
     */
    case custom(value: String
    )





}

#if compiler(>=6)
extension MembershipState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMembershipState: FfiConverterRustBuffer {
    typealias SwiftType = MembershipState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MembershipState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ban
        
        case 2: return .invite
        
        case 3: return .join
        
        case 4: return .knock
        
        case 5: return .leave
        
        case 6: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MembershipState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ban:
            writeInt(&buf, Int32(1))
        
        
        case .invite:
            writeInt(&buf, Int32(2))
        
        
        case .join:
            writeInt(&buf, Int32(3))
        
        
        case .knock:
            writeInt(&buf, Int32(4))
        
        
        case .leave:
            writeInt(&buf, Int32(5))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMembershipState_lift(_ buf: RustBuffer) throws -> MembershipState {
    return try FfiConverterTypeMembershipState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMembershipState_lower(_ value: MembershipState) -> RustBuffer {
    return FfiConverterTypeMembershipState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageFormat: Equatable, Hashable {
    
    case html
    case unknown(format: String
    )





}

#if compiler(>=6)
extension MessageFormat: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageFormat: FfiConverterRustBuffer {
    typealias SwiftType = MessageFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .html
        
        case 2: return .unknown(format: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .html:
            writeInt(&buf, Int32(1))
        
        
        case let .unknown(format):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(format, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageFormat_lift(_ buf: RustBuffer) throws -> MessageFormat {
    return try FfiConverterTypeMessageFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageFormat_lower(_ value: MessageFormat) -> RustBuffer {
    return FfiConverterTypeMessageFormat.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageLikeEventContent {
    
    case callAnswer
    case callInvite
    case rtcNotification(notificationType: RtcNotificationType, 
        /**
         * The timestamp at which this notification is considered invalid.
         */expirationTs: Timestamp
    )
    case callHangup
    case callCandidates
    case keyVerificationReady
    case keyVerificationStart
    case keyVerificationCancel
    case keyVerificationAccept
    case keyVerificationKey
    case keyVerificationMac
    case keyVerificationDone
    case poll(question: String
    )
    case reactionContent(relatedEventId: String
    )
    case roomEncrypted
    case roomMessage(messageType: MessageType, inReplyToEventId: String?
    )
    case roomRedaction(redactedEventId: String?, reason: String?
    )
    case sticker





}

#if compiler(>=6)
extension MessageLikeEventContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageLikeEventContent: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .callAnswer
        
        case 2: return .callInvite
        
        case 3: return .rtcNotification(notificationType: try FfiConverterTypeRtcNotificationType.read(from: &buf), expirationTs: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 4: return .callHangup
        
        case 5: return .callCandidates
        
        case 6: return .keyVerificationReady
        
        case 7: return .keyVerificationStart
        
        case 8: return .keyVerificationCancel
        
        case 9: return .keyVerificationAccept
        
        case 10: return .keyVerificationKey
        
        case 11: return .keyVerificationMac
        
        case 12: return .keyVerificationDone
        
        case 13: return .poll(question: try FfiConverterString.read(from: &buf)
        )
        
        case 14: return .reactionContent(relatedEventId: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .roomEncrypted
        
        case 16: return .roomMessage(messageType: try FfiConverterTypeMessageType.read(from: &buf), inReplyToEventId: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 17: return .roomRedaction(redactedEventId: try FfiConverterOptionString.read(from: &buf), reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 18: return .sticker
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .callAnswer:
            writeInt(&buf, Int32(1))
        
        
        case .callInvite:
            writeInt(&buf, Int32(2))
        
        
        case let .rtcNotification(notificationType,expirationTs):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRtcNotificationType.write(notificationType, into: &buf)
            FfiConverterTypeTimestamp.write(expirationTs, into: &buf)
            
        
        case .callHangup:
            writeInt(&buf, Int32(4))
        
        
        case .callCandidates:
            writeInt(&buf, Int32(5))
        
        
        case .keyVerificationReady:
            writeInt(&buf, Int32(6))
        
        
        case .keyVerificationStart:
            writeInt(&buf, Int32(7))
        
        
        case .keyVerificationCancel:
            writeInt(&buf, Int32(8))
        
        
        case .keyVerificationAccept:
            writeInt(&buf, Int32(9))
        
        
        case .keyVerificationKey:
            writeInt(&buf, Int32(10))
        
        
        case .keyVerificationMac:
            writeInt(&buf, Int32(11))
        
        
        case .keyVerificationDone:
            writeInt(&buf, Int32(12))
        
        
        case let .poll(question):
            writeInt(&buf, Int32(13))
            FfiConverterString.write(question, into: &buf)
            
        
        case let .reactionContent(relatedEventId):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(relatedEventId, into: &buf)
            
        
        case .roomEncrypted:
            writeInt(&buf, Int32(15))
        
        
        case let .roomMessage(messageType,inReplyToEventId):
            writeInt(&buf, Int32(16))
            FfiConverterTypeMessageType.write(messageType, into: &buf)
            FfiConverterOptionString.write(inReplyToEventId, into: &buf)
            
        
        case let .roomRedaction(redactedEventId,reason):
            writeInt(&buf, Int32(17))
            FfiConverterOptionString.write(redactedEventId, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case .sticker:
            writeInt(&buf, Int32(18))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageLikeEventContent_lift(_ buf: RustBuffer) throws -> MessageLikeEventContent {
    return try FfiConverterTypeMessageLikeEventContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageLikeEventContent_lower(_ value: MessageLikeEventContent) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventContent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageLikeEventType: Equatable, Hashable {
    
    case audio
    case beacon
    case callAnswer
    case callCandidates
    case callHangup
    case callInvite
    case callNegotiate
    case callNotify
    case callReject
    case callSdpStreamMetadataChanged
    case callSelectAnswer
    case emote
    case encrypted
    case file
    case image
    case keyVerificationAccept
    case keyVerificationCancel
    case keyVerificationDone
    case keyVerificationKey
    case keyVerificationMac
    case keyVerificationReady
    case keyVerificationStart
    case location
    case message
    case pollEnd
    case pollResponse
    case pollStart
    case reaction
    case roomEncrypted
    case roomMessage
    case roomRedaction
    case rtcDecline
    case rtcNotification
    case sticker
    case unstablePollEnd
    case unstablePollResponse
    case unstablePollStart
    case video
    case voice
    case other(String
    )





}

#if compiler(>=6)
extension MessageLikeEventType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageLikeEventType: FfiConverterRustBuffer {
    typealias SwiftType = MessageLikeEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageLikeEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .audio
        
        case 2: return .beacon
        
        case 3: return .callAnswer
        
        case 4: return .callCandidates
        
        case 5: return .callHangup
        
        case 6: return .callInvite
        
        case 7: return .callNegotiate
        
        case 8: return .callNotify
        
        case 9: return .callReject
        
        case 10: return .callSdpStreamMetadataChanged
        
        case 11: return .callSelectAnswer
        
        case 12: return .emote
        
        case 13: return .encrypted
        
        case 14: return .file
        
        case 15: return .image
        
        case 16: return .keyVerificationAccept
        
        case 17: return .keyVerificationCancel
        
        case 18: return .keyVerificationDone
        
        case 19: return .keyVerificationKey
        
        case 20: return .keyVerificationMac
        
        case 21: return .keyVerificationReady
        
        case 22: return .keyVerificationStart
        
        case 23: return .location
        
        case 24: return .message
        
        case 25: return .pollEnd
        
        case 26: return .pollResponse
        
        case 27: return .pollStart
        
        case 28: return .reaction
        
        case 29: return .roomEncrypted
        
        case 30: return .roomMessage
        
        case 31: return .roomRedaction
        
        case 32: return .rtcDecline
        
        case 33: return .rtcNotification
        
        case 34: return .sticker
        
        case 35: return .unstablePollEnd
        
        case 36: return .unstablePollResponse
        
        case 37: return .unstablePollStart
        
        case 38: return .video
        
        case 39: return .voice
        
        case 40: return .other(try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageLikeEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .audio:
            writeInt(&buf, Int32(1))
        
        
        case .beacon:
            writeInt(&buf, Int32(2))
        
        
        case .callAnswer:
            writeInt(&buf, Int32(3))
        
        
        case .callCandidates:
            writeInt(&buf, Int32(4))
        
        
        case .callHangup:
            writeInt(&buf, Int32(5))
        
        
        case .callInvite:
            writeInt(&buf, Int32(6))
        
        
        case .callNegotiate:
            writeInt(&buf, Int32(7))
        
        
        case .callNotify:
            writeInt(&buf, Int32(8))
        
        
        case .callReject:
            writeInt(&buf, Int32(9))
        
        
        case .callSdpStreamMetadataChanged:
            writeInt(&buf, Int32(10))
        
        
        case .callSelectAnswer:
            writeInt(&buf, Int32(11))
        
        
        case .emote:
            writeInt(&buf, Int32(12))
        
        
        case .encrypted:
            writeInt(&buf, Int32(13))
        
        
        case .file:
            writeInt(&buf, Int32(14))
        
        
        case .image:
            writeInt(&buf, Int32(15))
        
        
        case .keyVerificationAccept:
            writeInt(&buf, Int32(16))
        
        
        case .keyVerificationCancel:
            writeInt(&buf, Int32(17))
        
        
        case .keyVerificationDone:
            writeInt(&buf, Int32(18))
        
        
        case .keyVerificationKey:
            writeInt(&buf, Int32(19))
        
        
        case .keyVerificationMac:
            writeInt(&buf, Int32(20))
        
        
        case .keyVerificationReady:
            writeInt(&buf, Int32(21))
        
        
        case .keyVerificationStart:
            writeInt(&buf, Int32(22))
        
        
        case .location:
            writeInt(&buf, Int32(23))
        
        
        case .message:
            writeInt(&buf, Int32(24))
        
        
        case .pollEnd:
            writeInt(&buf, Int32(25))
        
        
        case .pollResponse:
            writeInt(&buf, Int32(26))
        
        
        case .pollStart:
            writeInt(&buf, Int32(27))
        
        
        case .reaction:
            writeInt(&buf, Int32(28))
        
        
        case .roomEncrypted:
            writeInt(&buf, Int32(29))
        
        
        case .roomMessage:
            writeInt(&buf, Int32(30))
        
        
        case .roomRedaction:
            writeInt(&buf, Int32(31))
        
        
        case .rtcDecline:
            writeInt(&buf, Int32(32))
        
        
        case .rtcNotification:
            writeInt(&buf, Int32(33))
        
        
        case .sticker:
            writeInt(&buf, Int32(34))
        
        
        case .unstablePollEnd:
            writeInt(&buf, Int32(35))
        
        
        case .unstablePollResponse:
            writeInt(&buf, Int32(36))
        
        
        case .unstablePollStart:
            writeInt(&buf, Int32(37))
        
        
        case .video:
            writeInt(&buf, Int32(38))
        
        
        case .voice:
            writeInt(&buf, Int32(39))
        
        
        case let .other(v1):
            writeInt(&buf, Int32(40))
            FfiConverterString.write(v1, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageLikeEventType_lift(_ buf: RustBuffer) throws -> MessageLikeEventType {
    return try FfiConverterTypeMessageLikeEventType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageLikeEventType_lower(_ value: MessageLikeEventType) -> RustBuffer {
    return FfiConverterTypeMessageLikeEventType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MessageType {
    
    case emote(content: EmoteMessageContent
    )
    case image(content: ImageMessageContent
    )
    case audio(content: AudioMessageContent
    )
    case video(content: VideoMessageContent
    )
    case file(content: FileMessageContent
    )
    case gallery(content: GalleryMessageContent
    )
    case notice(content: NoticeMessageContent
    )
    case text(content: TextMessageContent
    )
    case location(content: LocationContent
    )
    case other(msgtype: String, body: String
    )





}

#if compiler(>=6)
extension MessageType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMessageType: FfiConverterRustBuffer {
    typealias SwiftType = MessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .emote(content: try FfiConverterTypeEmoteMessageContent.read(from: &buf)
        )
        
        case 2: return .image(content: try FfiConverterTypeImageMessageContent.read(from: &buf)
        )
        
        case 3: return .audio(content: try FfiConverterTypeAudioMessageContent.read(from: &buf)
        )
        
        case 4: return .video(content: try FfiConverterTypeVideoMessageContent.read(from: &buf)
        )
        
        case 5: return .file(content: try FfiConverterTypeFileMessageContent.read(from: &buf)
        )
        
        case 6: return .gallery(content: try FfiConverterTypeGalleryMessageContent.read(from: &buf)
        )
        
        case 7: return .notice(content: try FfiConverterTypeNoticeMessageContent.read(from: &buf)
        )
        
        case 8: return .text(content: try FfiConverterTypeTextMessageContent.read(from: &buf)
        )
        
        case 9: return .location(content: try FfiConverterTypeLocationContent.read(from: &buf)
        )
        
        case 10: return .other(msgtype: try FfiConverterString.read(from: &buf), body: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .emote(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeEmoteMessageContent.write(content, into: &buf)
            
        
        case let .image(content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeImageMessageContent.write(content, into: &buf)
            
        
        case let .audio(content):
            writeInt(&buf, Int32(3))
            FfiConverterTypeAudioMessageContent.write(content, into: &buf)
            
        
        case let .video(content):
            writeInt(&buf, Int32(4))
            FfiConverterTypeVideoMessageContent.write(content, into: &buf)
            
        
        case let .file(content):
            writeInt(&buf, Int32(5))
            FfiConverterTypeFileMessageContent.write(content, into: &buf)
            
        
        case let .gallery(content):
            writeInt(&buf, Int32(6))
            FfiConverterTypeGalleryMessageContent.write(content, into: &buf)
            
        
        case let .notice(content):
            writeInt(&buf, Int32(7))
            FfiConverterTypeNoticeMessageContent.write(content, into: &buf)
            
        
        case let .text(content):
            writeInt(&buf, Int32(8))
            FfiConverterTypeTextMessageContent.write(content, into: &buf)
            
        
        case let .location(content):
            writeInt(&buf, Int32(9))
            FfiConverterTypeLocationContent.write(content, into: &buf)
            
        
        case let .other(msgtype,body):
            writeInt(&buf, Int32(10))
            FfiConverterString.write(msgtype, into: &buf)
            FfiConverterString.write(body, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageType_lift(_ buf: RustBuffer) throws -> MessageType {
    return try FfiConverterTypeMessageType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMessageType_lower(_ value: MessageType) -> RustBuffer {
    return FfiConverterTypeMessageType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum MsgLikeKind {
    
    /**
     * An `m.room.message` event or extensible event, including edits.
     */
    case message(content: MessageContent
    )
    /**
     * An `m.sticker` event.
     */
    case sticker(body: String, info: ImageInfo, source: MediaSource
    )
    /**
     * An `m.poll.start` event.
     */
    case poll(question: String, kind: PollKind, maxSelections: UInt64, answers: [PollAnswer], votes: [String: [String]], endTime: Timestamp?, hasBeenEdited: Bool
    )
    /**
     * A redacted message.
     */
    case redacted
    /**
     * An `m.room.encrypted` event that could not be decrypted.
     */
    case unableToDecrypt(msg: EncryptedMessage
    )
    /**
     * A custom message like event.
     */
    case other(eventType: MessageLikeEventType
    )





}

#if compiler(>=6)
extension MsgLikeKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeMsgLikeKind: FfiConverterRustBuffer {
    typealias SwiftType = MsgLikeKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MsgLikeKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .message(content: try FfiConverterTypeMessageContent.read(from: &buf)
        )
        
        case 2: return .sticker(body: try FfiConverterString.read(from: &buf), info: try FfiConverterTypeImageInfo.read(from: &buf), source: try FfiConverterTypeMediaSource.read(from: &buf)
        )
        
        case 3: return .poll(question: try FfiConverterString.read(from: &buf), kind: try FfiConverterTypePollKind.read(from: &buf), maxSelections: try FfiConverterUInt64.read(from: &buf), answers: try FfiConverterSequenceTypePollAnswer.read(from: &buf), votes: try FfiConverterDictionaryStringSequenceString.read(from: &buf), endTime: try FfiConverterOptionTypeTimestamp.read(from: &buf), hasBeenEdited: try FfiConverterBool.read(from: &buf)
        )
        
        case 4: return .redacted
        
        case 5: return .unableToDecrypt(msg: try FfiConverterTypeEncryptedMessage.read(from: &buf)
        )
        
        case 6: return .other(eventType: try FfiConverterTypeMessageLikeEventType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: MsgLikeKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .message(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageContent.write(content, into: &buf)
            
        
        case let .sticker(body,info,source):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(body, into: &buf)
            FfiConverterTypeImageInfo.write(info, into: &buf)
            FfiConverterTypeMediaSource.write(source, into: &buf)
            
        
        case let .poll(question,kind,maxSelections,answers,votes,endTime,hasBeenEdited):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(question, into: &buf)
            FfiConverterTypePollKind.write(kind, into: &buf)
            FfiConverterUInt64.write(maxSelections, into: &buf)
            FfiConverterSequenceTypePollAnswer.write(answers, into: &buf)
            FfiConverterDictionaryStringSequenceString.write(votes, into: &buf)
            FfiConverterOptionTypeTimestamp.write(endTime, into: &buf)
            FfiConverterBool.write(hasBeenEdited, into: &buf)
            
        
        case .redacted:
            writeInt(&buf, Int32(4))
        
        
        case let .unableToDecrypt(msg):
            writeInt(&buf, Int32(5))
            FfiConverterTypeEncryptedMessage.write(msg, into: &buf)
            
        
        case let .other(eventType):
            writeInt(&buf, Int32(6))
            FfiConverterTypeMessageLikeEventType.write(eventType, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMsgLikeKind_lift(_ buf: RustBuffer) throws -> MsgLikeKind {
    return try FfiConverterTypeMsgLikeKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeMsgLikeKind_lower(_ value: MsgLikeKind) -> RustBuffer {
    return FfiConverterTypeMsgLikeKind.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotificationEvent {
    
    case timeline(event: TimelineEvent
    )
    case invite(sender: String
    )





}

#if compiler(>=6)
extension NotificationEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationEvent: FfiConverterRustBuffer {
    typealias SwiftType = NotificationEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .timeline(event: try FfiConverterTypeTimelineEvent.read(from: &buf)
        )
        
        case 2: return .invite(sender: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .timeline(event):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTimelineEvent.write(event, into: &buf)
            
        
        case let .invite(sender):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(sender, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationEvent_lift(_ buf: RustBuffer) throws -> NotificationEvent {
    return try FfiConverterTypeNotificationEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationEvent_lower(_ value: NotificationEvent) -> RustBuffer {
    return FfiConverterTypeNotificationEvent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotificationProcessSetup {
    
    case multipleProcesses
    case singleProcess(syncService: SyncService
    )





}

#if compiler(>=6)
extension NotificationProcessSetup: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationProcessSetup: FfiConverterRustBuffer {
    typealias SwiftType = NotificationProcessSetup

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationProcessSetup {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .multipleProcesses
        
        case 2: return .singleProcess(syncService: try FfiConverterTypeSyncService.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationProcessSetup, into buf: inout [UInt8]) {
        switch value {
        
        
        case .multipleProcesses:
            writeInt(&buf, Int32(1))
        
        
        case let .singleProcess(syncService):
            writeInt(&buf, Int32(2))
            FfiConverterTypeSyncService.write(syncService, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationProcessSetup_lift(_ buf: RustBuffer) throws -> NotificationProcessSetup {
    return try FfiConverterTypeNotificationProcessSetup.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationProcessSetup_lower(_ value: NotificationProcessSetup) -> RustBuffer {
    return FfiConverterTypeNotificationProcessSetup.lower(value)
}



public enum NotificationSettingsError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Generic(msg: String
    )
    /**
     * Invalid parameter.
     */
    case InvalidParameter(msg: String
    )
    /**
     * Invalid room id.
     */
    case InvalidRoomId(roomId: String
    )
    /**
     * Rule not found
     */
    case RuleNotFound(ruleId: String
    )
    /**
     * Unable to add push rule.
     */
    case UnableToAddPushRule
    /**
     * Unable to remove push rule.
     */
    case UnableToRemovePushRule
    /**
     * Unable to save the push rules
     */
    case UnableToSavePushRules
    /**
     * Unable to update push rule.
     */
    case UnableToUpdatePushRule

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension NotificationSettingsError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationSettingsError: FfiConverterRustBuffer {
    typealias SwiftType = NotificationSettingsError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationSettingsError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Generic(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 2: return .InvalidParameter(
            msg: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InvalidRoomId(
            roomId: try FfiConverterString.read(from: &buf)
            )
        case 4: return .RuleNotFound(
            ruleId: try FfiConverterString.read(from: &buf)
            )
        case 5: return .UnableToAddPushRule
        case 6: return .UnableToRemovePushRule
        case 7: return .UnableToSavePushRules
        case 8: return .UnableToUpdatePushRule

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationSettingsError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .Generic(msg):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .InvalidParameter(msg):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msg, into: &buf)
            
        
        case let .InvalidRoomId(roomId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(roomId, into: &buf)
            
        
        case let .RuleNotFound(ruleId):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(ruleId, into: &buf)
            
        
        case .UnableToAddPushRule:
            writeInt(&buf, Int32(5))
        
        
        case .UnableToRemovePushRule:
            writeInt(&buf, Int32(6))
        
        
        case .UnableToSavePushRules:
            writeInt(&buf, Int32(7))
        
        
        case .UnableToUpdatePushRule:
            writeInt(&buf, Int32(8))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationSettingsError_lift(_ buf: RustBuffer) throws -> NotificationSettingsError {
    return try FfiConverterTypeNotificationSettingsError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationSettingsError_lower(_ value: NotificationSettingsError) -> RustBuffer {
    return FfiConverterTypeNotificationSettingsError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum NotificationStatus {
    
    /**
     * The event has been found and was not filtered out.
     */
    case event(item: NotificationItem
    )
    /**
     * The event couldn't be found in the network queries used to find it.
     */
    case eventNotFound
    /**
     * The event has been filtered out, either because of the user's push
     * rules, or because the user which triggered it is ignored by the
     * current user.
     */
    case eventFilteredOut





}

#if compiler(>=6)
extension NotificationStatus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeNotificationStatus: FfiConverterRustBuffer {
    typealias SwiftType = NotificationStatus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> NotificationStatus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .event(item: try FfiConverterTypeNotificationItem.read(from: &buf)
        )
        
        case 2: return .eventNotFound
        
        case 3: return .eventFilteredOut
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: NotificationStatus, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .event(item):
            writeInt(&buf, Int32(1))
            FfiConverterTypeNotificationItem.write(item, into: &buf)
            
        
        case .eventNotFound:
            writeInt(&buf, Int32(2))
        
        
        case .eventFilteredOut:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationStatus_lift(_ buf: RustBuffer) throws -> NotificationStatus {
    return try FfiConverterTypeNotificationStatus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeNotificationStatus_lower(_ value: NotificationStatus) -> RustBuffer {
    return FfiConverterTypeNotificationStatus.lower(value)
}



public enum OidcError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case NotSupported(message: String)
    
    case MetadataInvalid(message: String)
    
    case CallbackUrlInvalid(message: String)
    
    case Cancelled(message: String)
    
    case Generic(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension OidcError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOidcError: FfiConverterRustBuffer {
    typealias SwiftType = OidcError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .NotSupported(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .MetadataInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .CallbackUrlInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .Cancelled(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OidcError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .NotSupported(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .MetadataInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .CallbackUrlInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .Cancelled(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcError_lift(_ buf: RustBuffer) throws -> OidcError {
    return try FfiConverterTypeOidcError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcError_lower(_ value: OidcError) -> RustBuffer {
    return FfiConverterTypeOidcError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OidcPrompt: Equatable, Hashable {
    
    /**
     * The Authorization Server should prompt the End-User to create a user
     * account.
     *
     * Defined in [Initiating User Registration via OpenID Connect](https://openid.net/specs/openid-connect-prompt-create-1_0.html).
     */
    case create
    /**
     * The Authorization Server should prompt the End-User for
     * reauthentication.
     */
    case login
    /**
     * The Authorization Server should prompt the End-User for consent before
     * returning information to the Client.
     */
    case consent
    /**
     * An unknown value.
     */
    case unknown(value: String
    )





}

#if compiler(>=6)
extension OidcPrompt: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOidcPrompt: FfiConverterRustBuffer {
    typealias SwiftType = OidcPrompt

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OidcPrompt {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .create
        
        case 2: return .login
        
        case 3: return .consent
        
        case 4: return .unknown(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OidcPrompt, into buf: inout [UInt8]) {
        switch value {
        
        
        case .create:
            writeInt(&buf, Int32(1))
        
        
        case .login:
            writeInt(&buf, Int32(2))
        
        
        case .consent:
            writeInt(&buf, Int32(3))
        
        
        case let .unknown(value):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcPrompt_lift(_ buf: RustBuffer) throws -> OidcPrompt {
    return try FfiConverterTypeOidcPrompt.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOidcPrompt_lower(_ value: OidcPrompt) -> RustBuffer {
    return FfiConverterTypeOidcPrompt.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum OtherState: Equatable, Hashable {
    
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar(url: String?
    )
    case roomCanonicalAlias
    case roomCreate(federate: Bool?
    )
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility(historyVisibility: HistoryVisibility?
    )
    case roomJoinRules(joinRule: JoinRule?
    )
    case roomName(name: String?
    )
    case roomPinnedEvents(change: RoomPinnedEventsChange
    )
    case roomPowerLevels(users: [String: Int64], previous: [String: Int64]?
    )
    case roomServerAcl
    case roomThirdPartyInvite(displayName: String?
    )
    case roomTombstone
    case roomTopic(topic: String?
    )
    case spaceChild
    case spaceParent
    case custom(eventType: String
    )





}

#if compiler(>=6)
extension OtherState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeOtherState: FfiConverterRustBuffer {
    typealias SwiftType = OtherState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> OtherState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .policyRuleRoom
        
        case 2: return .policyRuleServer
        
        case 3: return .policyRuleUser
        
        case 4: return .roomAliases
        
        case 5: return .roomAvatar(url: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .roomCanonicalAlias
        
        case 7: return .roomCreate(federate: try FfiConverterOptionBool.read(from: &buf)
        )
        
        case 8: return .roomEncryption
        
        case 9: return .roomGuestAccess
        
        case 10: return .roomHistoryVisibility(historyVisibility: try FfiConverterOptionTypeHistoryVisibility.read(from: &buf)
        )
        
        case 11: return .roomJoinRules(joinRule: try FfiConverterOptionTypeJoinRule.read(from: &buf)
        )
        
        case 12: return .roomName(name: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 13: return .roomPinnedEvents(change: try FfiConverterTypeRoomPinnedEventsChange.read(from: &buf)
        )
        
        case 14: return .roomPowerLevels(users: try FfiConverterDictionaryStringInt64.read(from: &buf), previous: try FfiConverterOptionDictionaryStringInt64.read(from: &buf)
        )
        
        case 15: return .roomServerAcl
        
        case 16: return .roomThirdPartyInvite(displayName: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 17: return .roomTombstone
        
        case 18: return .roomTopic(topic: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 19: return .spaceChild
        
        case 20: return .spaceParent
        
        case 21: return .custom(eventType: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: OtherState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(3))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(4))
        
        
        case let .roomAvatar(url):
            writeInt(&buf, Int32(5))
            FfiConverterOptionString.write(url, into: &buf)
            
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(6))
        
        
        case let .roomCreate(federate):
            writeInt(&buf, Int32(7))
            FfiConverterOptionBool.write(federate, into: &buf)
            
        
        case .roomEncryption:
            writeInt(&buf, Int32(8))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(9))
        
        
        case let .roomHistoryVisibility(historyVisibility):
            writeInt(&buf, Int32(10))
            FfiConverterOptionTypeHistoryVisibility.write(historyVisibility, into: &buf)
            
        
        case let .roomJoinRules(joinRule):
            writeInt(&buf, Int32(11))
            FfiConverterOptionTypeJoinRule.write(joinRule, into: &buf)
            
        
        case let .roomName(name):
            writeInt(&buf, Int32(12))
            FfiConverterOptionString.write(name, into: &buf)
            
        
        case let .roomPinnedEvents(change):
            writeInt(&buf, Int32(13))
            FfiConverterTypeRoomPinnedEventsChange.write(change, into: &buf)
            
        
        case let .roomPowerLevels(users,previous):
            writeInt(&buf, Int32(14))
            FfiConverterDictionaryStringInt64.write(users, into: &buf)
            FfiConverterOptionDictionaryStringInt64.write(previous, into: &buf)
            
        
        case .roomServerAcl:
            writeInt(&buf, Int32(15))
        
        
        case let .roomThirdPartyInvite(displayName):
            writeInt(&buf, Int32(16))
            FfiConverterOptionString.write(displayName, into: &buf)
            
        
        case .roomTombstone:
            writeInt(&buf, Int32(17))
        
        
        case let .roomTopic(topic):
            writeInt(&buf, Int32(18))
            FfiConverterOptionString.write(topic, into: &buf)
            
        
        case .spaceChild:
            writeInt(&buf, Int32(19))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(20))
        
        
        case let .custom(eventType):
            writeInt(&buf, Int32(21))
            FfiConverterString.write(eventType, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOtherState_lift(_ buf: RustBuffer) throws -> OtherState {
    return try FfiConverterTypeOtherState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeOtherState_lower(_ value: OtherState) -> RustBuffer {
    return FfiConverterTypeOtherState.lower(value)
}



public enum ParseError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case EmptyHost(message: String)
    
    case IdnaError(message: String)
    
    case InvalidPort(message: String)
    
    case InvalidIpv4Address(message: String)
    
    case InvalidIpv6Address(message: String)
    
    case InvalidDomainCharacter(message: String)
    
    case RelativeUrlWithoutBase(message: String)
    
    case RelativeUrlWithCannotBeABaseBase(message: String)
    
    case SetHostOnCannotBeABaseUrl(message: String)
    
    case Overflow(message: String)
    
    case Other(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension ParseError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeParseError: FfiConverterRustBuffer {
    typealias SwiftType = ParseError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ParseError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .EmptyHost(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .IdnaError(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidPort(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .InvalidIpv4Address(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidIpv6Address(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidDomainCharacter(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .RelativeUrlWithoutBase(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .RelativeUrlWithCannotBeABaseBase(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 9: return .SetHostOnCannotBeABaseUrl(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 10: return .Overflow(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 11: return .Other(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ParseError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .EmptyHost(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .IdnaError(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidPort(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .InvalidIpv4Address(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidIpv6Address(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidDomainCharacter(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .RelativeUrlWithoutBase(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))
        case .RelativeUrlWithCannotBeABaseBase(_ /* message is ignored*/):
            writeInt(&buf, Int32(8))
        case .SetHostOnCannotBeABaseUrl(_ /* message is ignored*/):
            writeInt(&buf, Int32(9))
        case .Overflow(_ /* message is ignored*/):
            writeInt(&buf, Int32(10))
        case .Other(_ /* message is ignored*/):
            writeInt(&buf, Int32(11))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseError_lift(_ buf: RustBuffer) throws -> ParseError {
    return try FfiConverterTypeParseError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeParseError_lower(_ value: ParseError) -> RustBuffer {
    return FfiConverterTypeParseError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PollKind: Equatable, Hashable {
    
    case disclosed
    case undisclosed





}

#if compiler(>=6)
extension PollKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePollKind: FfiConverterRustBuffer {
    typealias SwiftType = PollKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PollKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .disclosed
        
        case 2: return .undisclosed
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PollKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .disclosed:
            writeInt(&buf, Int32(1))
        
        
        case .undisclosed:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollKind_lift(_ buf: RustBuffer) throws -> PollKind {
    return try FfiConverterTypePollKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePollKind_lower(_ value: PollKind) -> RustBuffer {
    return FfiConverterTypePollKind.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PowerLevel: Equatable, Hashable {
    
    /**
     * The user is a room creator and has infinite power level.
     *
     * This power level was introduced in room version 12.
     */
    case infinite
    /**
     * The user has the given power level.
     */
    case value(value: Int64
    )





}

#if compiler(>=6)
extension PowerLevel: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePowerLevel: FfiConverterRustBuffer {
    typealias SwiftType = PowerLevel

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PowerLevel {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .infinite
        
        case 2: return .value(value: try FfiConverterInt64.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PowerLevel, into buf: inout [UInt8]) {
        switch value {
        
        
        case .infinite:
            writeInt(&buf, Int32(1))
        
        
        case let .value(value):
            writeInt(&buf, Int32(2))
            FfiConverterInt64.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePowerLevel_lift(_ buf: RustBuffer) throws -> PowerLevel {
    return try FfiConverterTypePowerLevel.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePowerLevel_lower(_ value: PowerLevel) -> RustBuffer {
    return FfiConverterTypePowerLevel.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum ProfileDetails: Equatable, Hashable {
    
    case unavailable
    case pending
    case ready(displayName: String?, displayNameAmbiguous: Bool, avatarUrl: String?
    )
    case error(message: String
    )





}

#if compiler(>=6)
extension ProfileDetails: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeProfileDetails: FfiConverterRustBuffer {
    typealias SwiftType = ProfileDetails

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ProfileDetails {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unavailable
        
        case 2: return .pending
        
        case 3: return .ready(displayName: try FfiConverterOptionString.read(from: &buf), displayNameAmbiguous: try FfiConverterBool.read(from: &buf), avatarUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 4: return .error(message: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ProfileDetails, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unavailable:
            writeInt(&buf, Int32(1))
        
        
        case .pending:
            writeInt(&buf, Int32(2))
        
        
        case let .ready(displayName,displayNameAmbiguous,avatarUrl):
            writeInt(&buf, Int32(3))
            FfiConverterOptionString.write(displayName, into: &buf)
            FfiConverterBool.write(displayNameAmbiguous, into: &buf)
            FfiConverterOptionString.write(avatarUrl, into: &buf)
            
        
        case let .error(message):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(message, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileDetails_lift(_ buf: RustBuffer) throws -> ProfileDetails {
    return try FfiConverterTypeProfileDetails.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeProfileDetails_lower(_ value: ProfileDetails) -> RustBuffer {
    return FfiConverterTypeProfileDetails.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PublicRoomJoinRule: Equatable, Hashable {
    
    case `public`
    case knock
    case restricted
    case knockRestricted
    case invite





}

#if compiler(>=6)
extension PublicRoomJoinRule: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePublicRoomJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = PublicRoomJoinRule

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PublicRoomJoinRule {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .knock
        
        case 3: return .restricted
        
        case 4: return .knockRestricted
        
        case 5: return .invite
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PublicRoomJoinRule, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .knock:
            writeInt(&buf, Int32(2))
        
        
        case .restricted:
            writeInt(&buf, Int32(3))
        
        
        case .knockRestricted:
            writeInt(&buf, Int32(4))
        
        
        case .invite:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicRoomJoinRule_lift(_ buf: RustBuffer) throws -> PublicRoomJoinRule {
    return try FfiConverterTypePublicRoomJoinRule.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePublicRoomJoinRule_lower(_ value: PublicRoomJoinRule) -> RustBuffer {
    return FfiConverterTypePublicRoomJoinRule.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PushCondition: Equatable, Hashable {
    
    /**
     * A glob pattern match on a field of the event.
     */
    case eventMatch(
        /**
         * The [dot-separated path] of the property of the event to match.
         *
         * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
         */key: String, 
        /**
         * The glob-style pattern to match against.
         *
         * Patterns with no special glob characters should be treated as having
         * asterisks prepended and appended when testing the condition.
         */pattern: String
    )
    /**
     * Matches unencrypted messages where `content.body` contains the owner's
     * display name in that room.
     */
    case containsDisplayName
    /**
     * Matches the current number of members in the room.
     */
    case roomMemberCount(prefix: ComparisonOperator, count: UInt64
    )
    /**
     * Takes into account the current power levels in the room, ensuring the
     * sender of the event has high enough power to trigger the
     * notification.
     */
    case senderNotificationPermission(
        /**
         * The field in the power level event the user needs a minimum power
         * level for.
         *
         * Fields must be specified under the `notifications` property in the
         * power level event's `content`.
         */key: String
    )
    /**
     * Exact value match on a property of the event.
     */
    case eventPropertyIs(
        /**
         * The [dot-separated path] of the property of the event to match.
         *
         * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
         */key: String, 
        /**
         * The value to match against.
         */value: JsonValue
    )
    /**
     * Exact value match on a value in an array property of the event.
     */
    case eventPropertyContains(
        /**
         * The [dot-separated path] of the property of the event to match.
         *
         * [dot-separated path]: https://spec.matrix.org/latest/appendices/#dot-separated-property-paths
         */key: String, 
        /**
         * The value to match against.
         */value: JsonValue
    )





}

#if compiler(>=6)
extension PushCondition: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePushCondition: FfiConverterRustBuffer {
    typealias SwiftType = PushCondition

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PushCondition {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventMatch(key: try FfiConverterString.read(from: &buf), pattern: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .containsDisplayName
        
        case 3: return .roomMemberCount(prefix: try FfiConverterTypeComparisonOperator.read(from: &buf), count: try FfiConverterUInt64.read(from: &buf)
        )
        
        case 4: return .senderNotificationPermission(key: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .eventPropertyIs(key: try FfiConverterString.read(from: &buf), value: try FfiConverterTypeJsonValue.read(from: &buf)
        )
        
        case 6: return .eventPropertyContains(key: try FfiConverterString.read(from: &buf), value: try FfiConverterTypeJsonValue.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PushCondition, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .eventMatch(key,pattern):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(pattern, into: &buf)
            
        
        case .containsDisplayName:
            writeInt(&buf, Int32(2))
        
        
        case let .roomMemberCount(prefix,count):
            writeInt(&buf, Int32(3))
            FfiConverterTypeComparisonOperator.write(prefix, into: &buf)
            FfiConverterUInt64.write(count, into: &buf)
            
        
        case let .senderNotificationPermission(key):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(key, into: &buf)
            
        
        case let .eventPropertyIs(key,value):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeJsonValue.write(value, into: &buf)
            
        
        case let .eventPropertyContains(key,value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeJsonValue.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePushCondition_lift(_ buf: RustBuffer) throws -> PushCondition {
    return try FfiConverterTypePushCondition.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePushCondition_lower(_ value: PushCondition) -> RustBuffer {
    return FfiConverterTypePushCondition.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PushFormat: Equatable, Hashable {
    
    case eventIdOnly





}

#if compiler(>=6)
extension PushFormat: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PushFormat {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventIdOnly
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PushFormat, into buf: inout [UInt8]) {
        switch value {
        
        
        case .eventIdOnly:
            writeInt(&buf, Int32(1))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePushFormat_lift(_ buf: RustBuffer) throws -> PushFormat {
    return try FfiConverterTypePushFormat.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePushFormat_lower(_ value: PushFormat) -> RustBuffer {
    return FfiConverterTypePushFormat.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum PusherKind: Equatable, Hashable {
    
    case http(data: HttpPusherData
    )
    case email





}

#if compiler(>=6)
extension PusherKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypePusherKind: FfiConverterRustBuffer {
    typealias SwiftType = PusherKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PusherKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .http(data: try FfiConverterTypeHttpPusherData.read(from: &buf)
        )
        
        case 2: return .email
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: PusherKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .http(data):
            writeInt(&buf, Int32(1))
            FfiConverterTypeHttpPusherData.write(data, into: &buf)
            
        
        case .email:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePusherKind_lift(_ buf: RustBuffer) throws -> PusherKind {
    return try FfiConverterTypePusherKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypePusherKind_lower(_ value: PusherKind) -> RustBuffer {
    return FfiConverterTypePusherKind.lower(value)
}



/**
 * Error type for the decoding of the [`QrCodeData`].
 */
public enum QrCodeDecodeError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case Crypto(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension QrCodeDecodeError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQrCodeDecodeError: FfiConverterRustBuffer {
    typealias SwiftType = QrCodeDecodeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrCodeDecodeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .Crypto(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrCodeDecodeError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .Crypto(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrCodeDecodeError_lift(_ buf: RustBuffer) throws -> QrCodeDecodeError {
    return try FfiConverterTypeQrCodeDecodeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrCodeDecodeError_lower(_ value: QrCodeDecodeError) -> RustBuffer {
    return FfiConverterTypeQrCodeDecodeError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum describing the progress of logging in by scanning a QR code that was
 * generated on an existing device.
 */

public enum QrLoginProgress: Equatable, Hashable {
    
    /**
     * The login process is starting.
     */
    case starting
    /**
     * We established a secure channel with the other device.
     */
    case establishingSecureChannel(
        /**
         * The check code that the device should display so the other device
         * can confirm that the channel is secure as well.
         */checkCode: UInt8, 
        /**
         * The string representation of the check code, will be guaranteed to
         * be 2 characters long, preserving the leading zero if the
         * first digit is a zero.
         */checkCodeString: String
    )
    /**
     * We are waiting for the login and for the OAuth 2.0 authorization server
     * to give us an access token.
     */
    case waitingForToken(userCode: String
    )
    /**
     * We are syncing secrets.
     */
    case syncingSecrets
    /**
     * The login has successfully finished.
     */
    case done





}

#if compiler(>=6)
extension QrLoginProgress: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQrLoginProgress: FfiConverterRustBuffer {
    typealias SwiftType = QrLoginProgress

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QrLoginProgress {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .starting
        
        case 2: return .establishingSecureChannel(checkCode: try FfiConverterUInt8.read(from: &buf), checkCodeString: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .waitingForToken(userCode: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .syncingSecrets
        
        case 5: return .done
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QrLoginProgress, into buf: inout [UInt8]) {
        switch value {
        
        
        case .starting:
            writeInt(&buf, Int32(1))
        
        
        case let .establishingSecureChannel(checkCode,checkCodeString):
            writeInt(&buf, Int32(2))
            FfiConverterUInt8.write(checkCode, into: &buf)
            FfiConverterString.write(checkCodeString, into: &buf)
            
        
        case let .waitingForToken(userCode):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(userCode, into: &buf)
            
        
        case .syncingSecrets:
            writeInt(&buf, Int32(4))
        
        
        case .done:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrLoginProgress_lift(_ buf: RustBuffer) throws -> QrLoginProgress {
    return try FfiConverterTypeQrLoginProgress.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQrLoginProgress_lower(_ value: QrLoginProgress) -> RustBuffer {
    return FfiConverterTypeQrLoginProgress.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Bindings version of the sdk type replacing OwnedUserId/DeviceIds with simple
 * String.
 *
 * Represent a failed to send unrecoverable error of an event sent via the
 * send_queue. It is a serializable representation of a client error, see
 * `From` implementation for more details. These errors can not be
 * automatically retried, but yet some manual action can be taken before retry
 * sending. If not the only solution is to delete the local event.
 */

public enum QueueWedgeError: Equatable, Hashable {
    
    /**
     * This error occurs when there are some insecure devices in the room, and
     * the current encryption setting prohibit sharing with them.
     */
    case insecureDevices(
        /**
         * The insecure devices as a Map of userID to deviceID.
         */userDeviceMap: [String: [String]]
    )
    /**
     * This error occurs when a previously verified user is not anymore, and
     * the current encryption setting prohibit sharing when it happens.
     */
    case identityViolations(
        /**
         * The users that are expected to be verified but are not.
         */users: [String]
    )
    /**
     * It is required to set up cross-signing and properly erify the current
     * session before sending.
     */
    case crossVerificationRequired
    /**
     * Some media content to be sent has disappeared from the cache.
     */
    case missingMediaContent
    /**
     * Some mime type couldn't be parsed.
     */
    case invalidMimeType(mimeType: String
    )
    /**
     * Other errors.
     */
    case genericApiError(msg: String
    )





}

#if compiler(>=6)
extension QueueWedgeError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeQueueWedgeError: FfiConverterRustBuffer {
    typealias SwiftType = QueueWedgeError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> QueueWedgeError {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .insecureDevices(userDeviceMap: try FfiConverterDictionaryStringSequenceString.read(from: &buf)
        )
        
        case 2: return .identityViolations(users: try FfiConverterSequenceString.read(from: &buf)
        )
        
        case 3: return .crossVerificationRequired
        
        case 4: return .missingMediaContent
        
        case 5: return .invalidMimeType(mimeType: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .genericApiError(msg: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: QueueWedgeError, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .insecureDevices(userDeviceMap):
            writeInt(&buf, Int32(1))
            FfiConverterDictionaryStringSequenceString.write(userDeviceMap, into: &buf)
            
        
        case let .identityViolations(users):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceString.write(users, into: &buf)
            
        
        case .crossVerificationRequired:
            writeInt(&buf, Int32(3))
        
        
        case .missingMediaContent:
            writeInt(&buf, Int32(4))
        
        
        case let .invalidMimeType(mimeType):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(mimeType, into: &buf)
            
        
        case let .genericApiError(msg):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(msg, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueueWedgeError_lift(_ buf: RustBuffer) throws -> QueueWedgeError {
    return try FfiConverterTypeQueueWedgeError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeQueueWedgeError_lower(_ value: QueueWedgeError) -> RustBuffer {
    return FfiConverterTypeQueueWedgeError.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */

public enum ReceiptType: Equatable, Hashable {
    
    case read
    case readPrivate
    case fullyRead





}

#if compiler(>=6)
extension ReceiptType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeReceiptType: FfiConverterRustBuffer {
    typealias SwiftType = ReceiptType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ReceiptType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .read
        
        case 2: return .readPrivate
        
        case 3: return .fullyRead
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ReceiptType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .read:
            writeInt(&buf, Int32(1))
        
        
        case .readPrivate:
            writeInt(&buf, Int32(2))
        
        
        case .fullyRead:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptType_lift(_ buf: RustBuffer) throws -> ReceiptType {
    return try FfiConverterTypeReceiptType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeReceiptType_lower(_ value: ReceiptType) -> RustBuffer {
    return FfiConverterTypeReceiptType.lower(value)
}



public enum RecoveryError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    /**
     * A backup already exists on the homeserver, the recovery subsystem does
     * not allow backups to be overwritten, disable recovery first.
     */
    case BackupExistsOnServer
    /**
     * A typical SDK error.
     */
    case Client(source: ClientError
    )
    /**
     * Error in the secret storage subsystem, except for when importing a
     * secret.
     */
    case SecretStorage(errorMessage: String
    )
    /**
     * Error when importing a secret from secret storage.
     */
    case Import(errorMessage: String
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension RecoveryError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecoveryError: FfiConverterRustBuffer {
    typealias SwiftType = RecoveryError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BackupExistsOnServer
        case 2: return .Client(
            source: try FfiConverterTypeClientError.read(from: &buf)
            )
        case 3: return .SecretStorage(
            errorMessage: try FfiConverterString.read(from: &buf)
            )
        case 4: return .Import(
            errorMessage: try FfiConverterString.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RecoveryError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case .BackupExistsOnServer:
            writeInt(&buf, Int32(1))
        
        
        case let .Client(source):
            writeInt(&buf, Int32(2))
            FfiConverterTypeClientError.write(source, into: &buf)
            
        
        case let .SecretStorage(errorMessage):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(errorMessage, into: &buf)
            
        
        case let .Import(errorMessage):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(errorMessage, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryError_lift(_ buf: RustBuffer) throws -> RecoveryError {
    return try FfiConverterTypeRecoveryError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryError_lower(_ value: RecoveryError) -> RustBuffer {
    return FfiConverterTypeRecoveryError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RecoveryState: Equatable, Hashable {
    
    case unknown
    case enabled
    case disabled
    case incomplete





}

#if compiler(>=6)
extension RecoveryState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRecoveryState: FfiConverterRustBuffer {
    typealias SwiftType = RecoveryState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RecoveryState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .enabled
        
        case 3: return .disabled
        
        case 4: return .incomplete
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RecoveryState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .enabled:
            writeInt(&buf, Int32(2))
        
        
        case .disabled:
            writeInt(&buf, Int32(3))
        
        
        case .incomplete:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryState_lift(_ buf: RustBuffer) throws -> RecoveryState {
    return try FfiConverterTypeRecoveryState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRecoveryState_lower(_ value: RecoveryState) -> RustBuffer {
    return FfiConverterTypeRecoveryState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Room account data events.
 */

public enum RoomAccountDataEvent: Equatable, Hashable {
    
    /**
     * m.fully_read
     */
    case fullyReadEvent(
        /**
         * The event the user's read marker is located at in the room.
         */eventId: String
    )
    /**
     * m.marked_unread
     */
    case markedUnread(
        /**
         * The current unread state.
         */unread: Bool
    )
    /**
     * m.tag
     */
    case tag(tags: [TagName: TagInfo]
    )
    /**
     * com.famedly.marked_unread
     */
    case unstableMarkedUnread(
        /**
         * The current unread state.
         */unread: Bool
    )





}

#if compiler(>=6)
extension RoomAccountDataEvent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomAccountDataEvent: FfiConverterRustBuffer {
    typealias SwiftType = RoomAccountDataEvent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomAccountDataEvent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fullyReadEvent(eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .markedUnread(unread: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .tag(tags: try FfiConverterDictionaryTypeTagNameTypeTagInfo.read(from: &buf)
        )
        
        case 4: return .unstableMarkedUnread(unread: try FfiConverterBool.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomAccountDataEvent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .fullyReadEvent(eventId):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .markedUnread(unread):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(unread, into: &buf)
            
        
        case let .tag(tags):
            writeInt(&buf, Int32(3))
            FfiConverterDictionaryTypeTagNameTypeTagInfo.write(tags, into: &buf)
            
        
        case let .unstableMarkedUnread(unread):
            writeInt(&buf, Int32(4))
            FfiConverterBool.write(unread, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomAccountDataEvent_lift(_ buf: RustBuffer) throws -> RoomAccountDataEvent {
    return try FfiConverterTypeRoomAccountDataEvent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomAccountDataEvent_lower(_ value: RoomAccountDataEvent) -> RustBuffer {
    return FfiConverterTypeRoomAccountDataEvent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Types of room account data events.
 */

public enum RoomAccountDataEventType: Equatable, Hashable {
    
    /**
     * m.fully_read
     */
    case fullyRead
    /**
     * m.marked_unread
     */
    case markedUnread
    /**
     * m.tag
     */
    case tag
    /**
     * com.famedly.marked_unread
     */
    case unstableMarkedUnread





}

#if compiler(>=6)
extension RoomAccountDataEventType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomAccountDataEventType: FfiConverterRustBuffer {
    typealias SwiftType = RoomAccountDataEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomAccountDataEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .fullyRead
        
        case 2: return .markedUnread
        
        case 3: return .tag
        
        case 4: return .unstableMarkedUnread
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomAccountDataEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .fullyRead:
            writeInt(&buf, Int32(1))
        
        
        case .markedUnread:
            writeInt(&buf, Int32(2))
        
        
        case .tag:
            writeInt(&buf, Int32(3))
        
        
        case .unstableMarkedUnread:
            writeInt(&buf, Int32(4))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomAccountDataEventType_lift(_ buf: RustBuffer) throws -> RoomAccountDataEventType {
    return try FfiConverterTypeRoomAccountDataEventType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomAccountDataEventType_lower(_ value: RoomAccountDataEventType) -> RustBuffer {
    return FfiConverterTypeRoomAccountDataEventType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomDirectorySearchEntryUpdate: Equatable, Hashable {
    
    case append(values: [RoomDescription]
    )
    case clear
    case pushFront(value: RoomDescription
    )
    case pushBack(value: RoomDescription
    )
    case popFront
    case popBack
    case insert(index: UInt32, value: RoomDescription
    )
    case set(index: UInt32, value: RoomDescription
    )
    case remove(index: UInt32
    )
    case truncate(length: UInt32
    )
    case reset(values: [RoomDescription]
    )





}

#if compiler(>=6)
extension RoomDirectorySearchEntryUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomDirectorySearchEntryUpdate: FfiConverterRustBuffer {
    typealias SwiftType = RoomDirectorySearchEntryUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomDirectorySearchEntryUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append(values: try FfiConverterSequenceTypeRoomDescription.read(from: &buf)
        )
        
        case 2: return .clear
        
        case 3: return .pushFront(value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 4: return .pushBack(value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 5: return .popFront
        
        case 6: return .popBack
        
        case 7: return .insert(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 8: return .set(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoomDescription.read(from: &buf)
        )
        
        case 9: return .remove(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .truncate(length: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .reset(values: try FfiConverterSequenceTypeRoomDescription.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomDirectorySearchEntryUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .append(values):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomDescription.write(values, into: &buf)
            
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case let .pushFront(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case let .pushBack(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case .popFront:
            writeInt(&buf, Int32(5))
        
        
        case .popBack:
            writeInt(&buf, Int32(6))
        
        
        case let .insert(index,value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case let .set(index,value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoomDescription.write(value, into: &buf)
            
        
        case let .remove(index):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .truncate(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .reset(values):
            writeInt(&buf, Int32(11))
            FfiConverterSequenceTypeRoomDescription.write(values, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDirectorySearchEntryUpdate_lift(_ buf: RustBuffer) throws -> RoomDirectorySearchEntryUpdate {
    return try FfiConverterTypeRoomDirectorySearchEntryUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomDirectorySearchEntryUpdate_lower(_ value: RoomDirectorySearchEntryUpdate) -> RustBuffer {
    return FfiConverterTypeRoomDirectorySearchEntryUpdate.lower(value)
}



public enum RoomError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case InvalidAttachmentData(message: String)
    
    case InvalidAttachmentMimeType(message: String)
    
    case InvalidMediaInfo(message: String)
    
    case TimelineUnavailable(message: String)
    
    case InvalidThumbnailData(message: String)
    
    case InvalidRepliedToEventId(message: String)
    
    case FailedSendingAttachment(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension RoomError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomError: FfiConverterRustBuffer {
    typealias SwiftType = RoomError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .InvalidAttachmentData(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .InvalidAttachmentMimeType(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .InvalidMediaInfo(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .TimelineUnavailable(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .InvalidThumbnailData(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .InvalidRepliedToEventId(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .FailedSendingAttachment(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .InvalidAttachmentData(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .InvalidAttachmentMimeType(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .InvalidMediaInfo(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))
        case .TimelineUnavailable(_ /* message is ignored*/):
            writeInt(&buf, Int32(4))
        case .InvalidThumbnailData(_ /* message is ignored*/):
            writeInt(&buf, Int32(5))
        case .InvalidRepliedToEventId(_ /* message is ignored*/):
            writeInt(&buf, Int32(6))
        case .FailedSendingAttachment(_ /* message is ignored*/):
            writeInt(&buf, Int32(7))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomError_lift(_ buf: RustBuffer) throws -> RoomError {
    return try FfiConverterTypeRoomError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomError_lower(_ value: RoomError) -> RustBuffer {
    return FfiConverterTypeRoomError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomHistoryVisibility: Equatable, Hashable {
    
    /**
     * Previous events are accessible to newly joined members from the point
     * they were invited onwards.
     *
     * Events stop being accessible when the member's state changes to
     * something other than *invite* or *join*.
     */
    case invited
    /**
     * Previous events are accessible to newly joined members from the point
     * they joined the room onwards.
     * Events stop being accessible when the member's state changes to
     * something other than *join*.
     */
    case joined
    /**
     * Previous events are always accessible to newly joined members.
     *
     * All events in the room are accessible, even those sent when the member
     * was not a part of the room.
     */
    case shared
    /**
     * All events while this is the `HistoryVisibility` value may be shared by
     * any participating homeserver with anyone, regardless of whether they
     * have ever joined the room.
     */
    case worldReadable
    /**
     * A custom visibility value.
     */
    case custom(value: String
    )





}

#if compiler(>=6)
extension RoomHistoryVisibility: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = RoomHistoryVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomHistoryVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .invited
        
        case 2: return .joined
        
        case 3: return .shared
        
        case 4: return .worldReadable
        
        case 5: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomHistoryVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .invited:
            writeInt(&buf, Int32(1))
        
        
        case .joined:
            writeInt(&buf, Int32(2))
        
        
        case .shared:
            writeInt(&buf, Int32(3))
        
        
        case .worldReadable:
            writeInt(&buf, Int32(4))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomHistoryVisibility_lift(_ buf: RustBuffer) throws -> RoomHistoryVisibility {
    return try FfiConverterTypeRoomHistoryVisibility.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomHistoryVisibility_lower(_ value: RoomHistoryVisibility) -> RustBuffer {
    return FfiConverterTypeRoomHistoryVisibility.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListEntriesDynamicFilterKind: Equatable, Hashable {
    
    case all(filters: [RoomListEntriesDynamicFilterKind]
    )
    case any(filters: [RoomListEntriesDynamicFilterKind]
    )
    case nonSpace
    case space
    case nonLeft
    case joined
    case unread
    case favourite
    case lowPriority
    case nonLowPriority
    case invite
    case category(expect: RoomListFilterCategory
    )
    case none
    case normalizedMatchRoomName(pattern: String
    )
    case fuzzyMatchRoomName(pattern: String
    )
    case deduplicateVersions





}

#if compiler(>=6)
extension RoomListEntriesDynamicFilterKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListEntriesDynamicFilterKind: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntriesDynamicFilterKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesDynamicFilterKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all(filters: try FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.read(from: &buf)
        )
        
        case 2: return .any(filters: try FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.read(from: &buf)
        )
        
        case 3: return .nonSpace
        
        case 4: return .space
        
        case 5: return .nonLeft
        
        case 6: return .joined
        
        case 7: return .unread
        
        case 8: return .favourite
        
        case 9: return .lowPriority
        
        case 10: return .nonLowPriority
        
        case 11: return .invite
        
        case 12: return .category(expect: try FfiConverterTypeRoomListFilterCategory.read(from: &buf)
        )
        
        case 13: return .none
        
        case 14: return .normalizedMatchRoomName(pattern: try FfiConverterString.read(from: &buf)
        )
        
        case 15: return .fuzzyMatchRoomName(pattern: try FfiConverterString.read(from: &buf)
        )
        
        case 16: return .deduplicateVersions
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntriesDynamicFilterKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .all(filters):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.write(filters, into: &buf)
            
        
        case let .any(filters):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind.write(filters, into: &buf)
            
        
        case .nonSpace:
            writeInt(&buf, Int32(3))
        
        
        case .space:
            writeInt(&buf, Int32(4))
        
        
        case .nonLeft:
            writeInt(&buf, Int32(5))
        
        
        case .joined:
            writeInt(&buf, Int32(6))
        
        
        case .unread:
            writeInt(&buf, Int32(7))
        
        
        case .favourite:
            writeInt(&buf, Int32(8))
        
        
        case .lowPriority:
            writeInt(&buf, Int32(9))
        
        
        case .nonLowPriority:
            writeInt(&buf, Int32(10))
        
        
        case .invite:
            writeInt(&buf, Int32(11))
        
        
        case let .category(expect):
            writeInt(&buf, Int32(12))
            FfiConverterTypeRoomListFilterCategory.write(expect, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(13))
        
        
        case let .normalizedMatchRoomName(pattern):
            writeInt(&buf, Int32(14))
            FfiConverterString.write(pattern, into: &buf)
            
        
        case let .fuzzyMatchRoomName(pattern):
            writeInt(&buf, Int32(15))
            FfiConverterString.write(pattern, into: &buf)
            
        
        case .deduplicateVersions:
            writeInt(&buf, Int32(16))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListEntriesDynamicFilterKind_lift(_ buf: RustBuffer) throws -> RoomListEntriesDynamicFilterKind {
    return try FfiConverterTypeRoomListEntriesDynamicFilterKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListEntriesDynamicFilterKind_lower(_ value: RoomListEntriesDynamicFilterKind) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesDynamicFilterKind.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListEntriesUpdate {
    
    case append(values: [Room]
    )
    case clear
    case pushFront(value: Room
    )
    case pushBack(value: Room
    )
    case popFront
    case popBack
    case insert(index: UInt32, value: Room
    )
    case set(index: UInt32, value: Room
    )
    case remove(index: UInt32
    )
    case truncate(length: UInt32
    )
    case reset(values: [Room]
    )





}

#if compiler(>=6)
extension RoomListEntriesUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListEntriesUpdate: FfiConverterRustBuffer {
    typealias SwiftType = RoomListEntriesUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListEntriesUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append(values: try FfiConverterSequenceTypeRoom.read(from: &buf)
        )
        
        case 2: return .clear
        
        case 3: return .pushFront(value: try FfiConverterTypeRoom.read(from: &buf)
        )
        
        case 4: return .pushBack(value: try FfiConverterTypeRoom.read(from: &buf)
        )
        
        case 5: return .popFront
        
        case 6: return .popBack
        
        case 7: return .insert(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoom.read(from: &buf)
        )
        
        case 8: return .set(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeRoom.read(from: &buf)
        )
        
        case 9: return .remove(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .truncate(length: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .reset(values: try FfiConverterSequenceTypeRoom.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListEntriesUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .append(values):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeRoom.write(values, into: &buf)
            
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case let .pushFront(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeRoom.write(value, into: &buf)
            
        
        case let .pushBack(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeRoom.write(value, into: &buf)
            
        
        case .popFront:
            writeInt(&buf, Int32(5))
        
        
        case .popBack:
            writeInt(&buf, Int32(6))
        
        
        case let .insert(index,value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoom.write(value, into: &buf)
            
        
        case let .set(index,value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeRoom.write(value, into: &buf)
            
        
        case let .remove(index):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .truncate(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .reset(values):
            writeInt(&buf, Int32(11))
            FfiConverterSequenceTypeRoom.write(values, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListEntriesUpdate_lift(_ buf: RustBuffer) throws -> RoomListEntriesUpdate {
    return try FfiConverterTypeRoomListEntriesUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListEntriesUpdate_lower(_ value: RoomListEntriesUpdate) -> RustBuffer {
    return FfiConverterTypeRoomListEntriesUpdate.lower(value)
}



public enum RoomListError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case SlidingSync(error: String
    )
    case UnknownList(listName: String
    )
    case InputCannotBeApplied
    case RoomNotFound(roomName: String
    )
    case InvalidRoomId(error: String
    )
    case EventCache(error: String
    )
    case IncorrectRoomMembership(expected: [Membership], actual: Membership
    )

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension RoomListError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListError: FfiConverterRustBuffer {
    typealias SwiftType = RoomListError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .SlidingSync(
            error: try FfiConverterString.read(from: &buf)
            )
        case 2: return .UnknownList(
            listName: try FfiConverterString.read(from: &buf)
            )
        case 3: return .InputCannotBeApplied
        case 4: return .RoomNotFound(
            roomName: try FfiConverterString.read(from: &buf)
            )
        case 5: return .InvalidRoomId(
            error: try FfiConverterString.read(from: &buf)
            )
        case 6: return .EventCache(
            error: try FfiConverterString.read(from: &buf)
            )
        case 7: return .IncorrectRoomMembership(
            expected: try FfiConverterSequenceTypeMembership.read(from: &buf), 
            actual: try FfiConverterTypeMembership.read(from: &buf)
            )

         default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListError, into buf: inout [UInt8]) {
        switch value {

        

        
        
        case let .SlidingSync(error):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .UnknownList(listName):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(listName, into: &buf)
            
        
        case .InputCannotBeApplied:
            writeInt(&buf, Int32(3))
        
        
        case let .RoomNotFound(roomName):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(roomName, into: &buf)
            
        
        case let .InvalidRoomId(error):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .EventCache(error):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(error, into: &buf)
            
        
        case let .IncorrectRoomMembership(expected,actual):
            writeInt(&buf, Int32(7))
            FfiConverterSequenceTypeMembership.write(expected, into: &buf)
            FfiConverterTypeMembership.write(actual, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListError_lift(_ buf: RustBuffer) throws -> RoomListError {
    return try FfiConverterTypeRoomListError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListError_lower(_ value: RoomListError) -> RustBuffer {
    return FfiConverterTypeRoomListError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListFilterCategory: Equatable, Hashable {
    
    case group
    case people





}

#if compiler(>=6)
extension RoomListFilterCategory: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListFilterCategory: FfiConverterRustBuffer {
    typealias SwiftType = RoomListFilterCategory

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListFilterCategory {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .group
        
        case 2: return .people
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListFilterCategory, into buf: inout [UInt8]) {
        switch value {
        
        
        case .group:
            writeInt(&buf, Int32(1))
        
        
        case .people:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListFilterCategory_lift(_ buf: RustBuffer) throws -> RoomListFilterCategory {
    return try FfiConverterTypeRoomListFilterCategory.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListFilterCategory_lower(_ value: RoomListFilterCategory) -> RustBuffer {
    return FfiConverterTypeRoomListFilterCategory.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListLoadingState: Equatable, Hashable {
    
    case notLoaded
    case loaded(maximumNumberOfRooms: UInt32?
    )





}

#if compiler(>=6)
extension RoomListLoadingState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListLoadingState: FfiConverterRustBuffer {
    typealias SwiftType = RoomListLoadingState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListLoadingState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .notLoaded
        
        case 2: return .loaded(maximumNumberOfRooms: try FfiConverterOptionUInt32.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListLoadingState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .notLoaded:
            writeInt(&buf, Int32(1))
        
        
        case let .loaded(maximumNumberOfRooms):
            writeInt(&buf, Int32(2))
            FfiConverterOptionUInt32.write(maximumNumberOfRooms, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListLoadingState_lift(_ buf: RustBuffer) throws -> RoomListLoadingState {
    return try FfiConverterTypeRoomListLoadingState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListLoadingState_lower(_ value: RoomListLoadingState) -> RustBuffer {
    return FfiConverterTypeRoomListLoadingState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListServiceState: Equatable, Hashable {
    
    case initial
    case settingUp
    case recovering
    case running
    case error
    case terminated





}

#if compiler(>=6)
extension RoomListServiceState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListServiceState: FfiConverterRustBuffer {
    typealias SwiftType = RoomListServiceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListServiceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .initial
        
        case 2: return .settingUp
        
        case 3: return .recovering
        
        case 4: return .running
        
        case 5: return .error
        
        case 6: return .terminated
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListServiceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .initial:
            writeInt(&buf, Int32(1))
        
        
        case .settingUp:
            writeInt(&buf, Int32(2))
        
        
        case .recovering:
            writeInt(&buf, Int32(3))
        
        
        case .running:
            writeInt(&buf, Int32(4))
        
        
        case .error:
            writeInt(&buf, Int32(5))
        
        
        case .terminated:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListServiceState_lift(_ buf: RustBuffer) throws -> RoomListServiceState {
    return try FfiConverterTypeRoomListServiceState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListServiceState_lower(_ value: RoomListServiceState) -> RustBuffer {
    return FfiConverterTypeRoomListServiceState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomListServiceSyncIndicator: Equatable, Hashable {
    
    case show
    case hide





}

#if compiler(>=6)
extension RoomListServiceSyncIndicator: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomListServiceSyncIndicator: FfiConverterRustBuffer {
    typealias SwiftType = RoomListServiceSyncIndicator

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomListServiceSyncIndicator {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .show
        
        case 2: return .hide
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomListServiceSyncIndicator, into buf: inout [UInt8]) {
        switch value {
        
        
        case .show:
            writeInt(&buf, Int32(1))
        
        
        case .hide:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListServiceSyncIndicator_lift(_ buf: RustBuffer) throws -> RoomListServiceSyncIndicator {
    return try FfiConverterTypeRoomListServiceSyncIndicator.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomListServiceSyncIndicator_lower(_ value: RoomListServiceSyncIndicator) -> RustBuffer {
    return FfiConverterTypeRoomListServiceSyncIndicator.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Configure how many rooms will be restored when restoring the session with
 * [`Client::restore_session_with`].
 *
 * Please, see the documentation of [`matrix_sdk::store::RoomLoadSettings`] to
 * learn more.
 */

public enum RoomLoadSettings: Equatable, Hashable {
    
    /**
     * Load all rooms from the `StateStore` into the in-memory state store
     * `BaseStateStore`.
     */
    case all
    /**
     * Load a single room from the `StateStore` into the in-memory state
     * store `BaseStateStore`.
     *
     * Please, be careful with this option. Read the documentation of
     * [`RoomLoadSettings`].
     */
    case one(roomId: String
    )





}

#if compiler(>=6)
extension RoomLoadSettings: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomLoadSettings: FfiConverterRustBuffer {
    typealias SwiftType = RoomLoadSettings

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomLoadSettings {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .one(roomId: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomLoadSettings, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case let .one(roomId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(roomId, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomLoadSettings_lift(_ buf: RustBuffer) throws -> RoomLoadSettings {
    return try FfiConverterTypeRoomLoadSettings.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomLoadSettings_lower(_ value: RoomLoadSettings) -> RustBuffer {
    return FfiConverterTypeRoomLoadSettings.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomMessageEventMessageType: Equatable, Hashable {
    
    case audio
    case emote
    case file
    case gallery
    case image
    case location
    case notice
    case serverNotice
    case text
    case video
    case verificationRequest
    case other





}

#if compiler(>=6)
extension RoomMessageEventMessageType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomMessageEventMessageType: FfiConverterRustBuffer {
    typealias SwiftType = RoomMessageEventMessageType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomMessageEventMessageType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .audio
        
        case 2: return .emote
        
        case 3: return .file
        
        case 4: return .gallery
        
        case 5: return .image
        
        case 6: return .location
        
        case 7: return .notice
        
        case 8: return .serverNotice
        
        case 9: return .text
        
        case 10: return .video
        
        case 11: return .verificationRequest
        
        case 12: return .other
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomMessageEventMessageType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .audio:
            writeInt(&buf, Int32(1))
        
        
        case .emote:
            writeInt(&buf, Int32(2))
        
        
        case .file:
            writeInt(&buf, Int32(3))
        
        
        case .gallery:
            writeInt(&buf, Int32(4))
        
        
        case .image:
            writeInt(&buf, Int32(5))
        
        
        case .location:
            writeInt(&buf, Int32(6))
        
        
        case .notice:
            writeInt(&buf, Int32(7))
        
        
        case .serverNotice:
            writeInt(&buf, Int32(8))
        
        
        case .text:
            writeInt(&buf, Int32(9))
        
        
        case .video:
            writeInt(&buf, Int32(10))
        
        
        case .verificationRequest:
            writeInt(&buf, Int32(11))
        
        
        case .other:
            writeInt(&buf, Int32(12))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMessageEventMessageType_lift(_ buf: RustBuffer) throws -> RoomMessageEventMessageType {
    return try FfiConverterTypeRoomMessageEventMessageType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomMessageEventMessageType_lower(_ value: RoomMessageEventMessageType) -> RustBuffer {
    return FfiConverterTypeRoomMessageEventMessageType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing the push notification modes for a room.
 */

public enum RoomNotificationMode: Equatable, Hashable {
    
    /**
     * Receive notifications for all messages.
     */
    case allMessages
    /**
     * Receive notifications for mentions and keywords only.
     */
    case mentionsAndKeywordsOnly
    /**
     * Do not receive any notifications.
     */
    case mute





}

#if compiler(>=6)
extension RoomNotificationMode: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomNotificationMode: FfiConverterRustBuffer {
    typealias SwiftType = RoomNotificationMode

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomNotificationMode {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .allMessages
        
        case 2: return .mentionsAndKeywordsOnly
        
        case 3: return .mute
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomNotificationMode, into buf: inout [UInt8]) {
        switch value {
        
        
        case .allMessages:
            writeInt(&buf, Int32(1))
        
        
        case .mentionsAndKeywordsOnly:
            writeInt(&buf, Int32(2))
        
        
        case .mute:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomNotificationMode_lift(_ buf: RustBuffer) throws -> RoomNotificationMode {
    return try FfiConverterTypeRoomNotificationMode.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomNotificationMode_lower(_ value: RoomNotificationMode) -> RustBuffer {
    return FfiConverterTypeRoomNotificationMode.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomPreset: Equatable, Hashable {
    
    /**
     * `join_rules` is set to `invite` and `history_visibility` is set to
     * `shared`.
     */
    case privateChat
    /**
     * `join_rules` is set to `public` and `history_visibility` is set to
     * `shared`.
     */
    case publicChat
    /**
     * Same as `PrivateChat`, but all initial invitees get the same power level
     * as the creator.
     */
    case trustedPrivateChat





}

#if compiler(>=6)
extension RoomPreset: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomPreset: FfiConverterRustBuffer {
    typealias SwiftType = RoomPreset

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomPreset {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .privateChat
        
        case 2: return .publicChat
        
        case 3: return .trustedPrivateChat
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomPreset, into buf: inout [UInt8]) {
        switch value {
        
        
        case .privateChat:
            writeInt(&buf, Int32(1))
        
        
        case .publicChat:
            writeInt(&buf, Int32(2))
        
        
        case .trustedPrivateChat:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPreset_lift(_ buf: RustBuffer) throws -> RoomPreset {
    return try FfiConverterTypeRoomPreset.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomPreset_lower(_ value: RoomPreset) -> RustBuffer {
    return FfiConverterTypeRoomPreset.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An update to a room send queue.
 */

public enum RoomSendQueueUpdate {
    
    /**
     * A new local event is being sent.
     */
    case newLocalEvent(
        /**
         * Transaction id used to identify this event.
         */transactionId: String
    )
    /**
     * A local event that hadn't been sent to the server yet has been cancelled
     * before sending.
     */
    case cancelledLocalEvent(
        /**
         * Transaction id used to identify this event.
         */transactionId: String
    )
    /**
     * A local event's content has been replaced with something else.
     */
    case replacedLocalEvent(
        /**
         * Transaction id used to identify this event.
         */transactionId: String
    )
    /**
     * An error happened when an event was being sent.
     *
     * The event has not been removed from the queue. All the send queues
     * will be disabled after this happens, and must be manually re-enabled.
     */
    case sendError(
        /**
         * Transaction id used to identify this event.
         */transactionId: String, 
        /**
         * Error received while sending the event.
         */error: QueueWedgeError, 
        /**
         * Whether the error is considered recoverable or not.
         *
         * An error that's recoverable will disable the room's send queue,
         * while an unrecoverable error will be parked, until the user
         * decides to cancel sending it.
         */isRecoverable: Bool
    )
    /**
     * The event has been unwedged and sending is now being retried.
     */
    case retryEvent(
        /**
         * Transaction id used to identify this event.
         */transactionId: String
    )
    /**
     * The event has been sent to the server, and the query returned
     * successfully.
     */
    case sentEvent(
        /**
         * Transaction id used to identify this event.
         */transactionId: String, 
        /**
         * Received event id from the send response.
         */eventId: String
    )
    /**
     * A media upload (consisting of a file and possibly a thumbnail) has made
     * progress.
     */
    case mediaUpload(
        /**
         * The media event this uploaded media relates to.
         */relatedTo: String, 
        /**
         * The final media source for the file if it has finished uploading.
         */file: MediaSource?, 
        /**
         * The index of the media within the transaction. A file and its
         * thumbnail share the same index. Will always be 0 for non-gallery
         * media uploads.
         */index: UInt64, 
        /**
         * The combined upload progress across the file and, if existing, its
         * thumbnail. For gallery uploads, the progress is reported per indexed
         * gallery item.
         */progress: AbstractProgress
    )





}

#if compiler(>=6)
extension RoomSendQueueUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomSendQueueUpdate: FfiConverterRustBuffer {
    typealias SwiftType = RoomSendQueueUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomSendQueueUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .newLocalEvent(transactionId: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .cancelledLocalEvent(transactionId: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .replacedLocalEvent(transactionId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .sendError(transactionId: try FfiConverterString.read(from: &buf), error: try FfiConverterTypeQueueWedgeError.read(from: &buf), isRecoverable: try FfiConverterBool.read(from: &buf)
        )
        
        case 5: return .retryEvent(transactionId: try FfiConverterString.read(from: &buf)
        )
        
        case 6: return .sentEvent(transactionId: try FfiConverterString.read(from: &buf), eventId: try FfiConverterString.read(from: &buf)
        )
        
        case 7: return .mediaUpload(relatedTo: try FfiConverterString.read(from: &buf), file: try FfiConverterOptionTypeMediaSource.read(from: &buf), index: try FfiConverterUInt64.read(from: &buf), progress: try FfiConverterTypeAbstractProgress.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomSendQueueUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .newLocalEvent(transactionId):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(transactionId, into: &buf)
            
        
        case let .cancelledLocalEvent(transactionId):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(transactionId, into: &buf)
            
        
        case let .replacedLocalEvent(transactionId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(transactionId, into: &buf)
            
        
        case let .sendError(transactionId,error,isRecoverable):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(transactionId, into: &buf)
            FfiConverterTypeQueueWedgeError.write(error, into: &buf)
            FfiConverterBool.write(isRecoverable, into: &buf)
            
        
        case let .retryEvent(transactionId):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(transactionId, into: &buf)
            
        
        case let .sentEvent(transactionId,eventId):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(transactionId, into: &buf)
            FfiConverterString.write(eventId, into: &buf)
            
        
        case let .mediaUpload(relatedTo,file,index,progress):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(relatedTo, into: &buf)
            FfiConverterOptionTypeMediaSource.write(file, into: &buf)
            FfiConverterUInt64.write(index, into: &buf)
            FfiConverterTypeAbstractProgress.write(progress, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomSendQueueUpdate_lift(_ buf: RustBuffer) throws -> RoomSendQueueUpdate {
    return try FfiConverterTypeRoomSendQueueUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomSendQueueUpdate_lower(_ value: RoomSendQueueUpdate) -> RustBuffer {
    return FfiConverterTypeRoomSendQueueUpdate.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The type of room for a [`RoomPreviewInfo`].
 */

public enum RoomType: Equatable, Hashable {
    
    /**
     * It's a plain chat room.
     */
    case room
    /**
     * It's a space that can group several rooms.
     */
    case space
    /**
     * It's a custom implementation.
     */
    case custom(value: String
    )





}

#if compiler(>=6)
extension RoomType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomType: FfiConverterRustBuffer {
    typealias SwiftType = RoomType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .room
        
        case 2: return .space
        
        case 3: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .room:
            writeInt(&buf, Int32(1))
        
        
        case .space:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomType_lift(_ buf: RustBuffer) throws -> RoomType {
    return try FfiConverterTypeRoomType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomType_lower(_ value: RoomType) -> RustBuffer {
    return FfiConverterTypeRoomType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RoomVisibility: Equatable, Hashable {
    
    /**
     * Indicates that the room will be shown in the published room list.
     */
    case `public`
    /**
     * Indicates that the room will not be shown in the published room list.
     */
    case `private`
    /**
     * A custom value that's not present in the spec.
     */
    case custom(value: String
    )





}

#if compiler(>=6)
extension RoomVisibility: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRoomVisibility: FfiConverterRustBuffer {
    typealias SwiftType = RoomVisibility

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RoomVisibility {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .`public`
        
        case 2: return .`private`
        
        case 3: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RoomVisibility, into buf: inout [UInt8]) {
        switch value {
        
        
        case .`public`:
            writeInt(&buf, Int32(1))
        
        
        case .`private`:
            writeInt(&buf, Int32(2))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomVisibility_lift(_ buf: RustBuffer) throws -> RoomVisibility {
    return try FfiConverterTypeRoomVisibility.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRoomVisibility_lower(_ value: RoomVisibility) -> RustBuffer {
    return FfiConverterTypeRoomVisibility.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RtcNotificationType: Equatable, Hashable {
    
    case ring
    case notification





}

#if compiler(>=6)
extension RtcNotificationType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRtcNotificationType: FfiConverterRustBuffer {
    typealias SwiftType = RtcNotificationType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RtcNotificationType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .ring
        
        case 2: return .notification
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RtcNotificationType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .ring:
            writeInt(&buf, Int32(1))
        
        
        case .notification:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRtcNotificationType_lift(_ buf: RustBuffer) throws -> RtcNotificationType {
    return try FfiConverterTypeRtcNotificationType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRtcNotificationType_lower(_ value: RtcNotificationType) -> RustBuffer {
    return FfiConverterTypeRtcNotificationType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum RuleKind: Equatable, Hashable {
    
    /**
     * User-configured rules that override all other kinds.
     */
    case override
    /**
     * Lowest priority user-defined rules.
     */
    case underride
    /**
     * Sender-specific rules.
     */
    case sender
    /**
     * Room-specific rules.
     */
    case room
    /**
     * Content-specific rules.
     */
    case content
    case custom(value: String
    )





}

#if compiler(>=6)
extension RuleKind: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeRuleKind: FfiConverterRustBuffer {
    typealias SwiftType = RuleKind

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RuleKind {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .override
        
        case 2: return .underride
        
        case 3: return .sender
        
        case 4: return .room
        
        case 5: return .content
        
        case 6: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: RuleKind, into buf: inout [UInt8]) {
        switch value {
        
        
        case .override:
            writeInt(&buf, Int32(1))
        
        
        case .underride:
            writeInt(&buf, Int32(2))
        
        
        case .sender:
            writeInt(&buf, Int32(3))
        
        
        case .room:
            writeInt(&buf, Int32(4))
        
        
        case .content:
            writeInt(&buf, Int32(5))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRuleKind_lift(_ buf: RustBuffer) throws -> RuleKind {
    return try FfiConverterTypeRuleKind.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeRuleKind_lower(_ value: RuleKind) -> RustBuffer {
    return FfiConverterTypeRuleKind.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * An algorithm and its properties, used to encrypt a secret.
 */

public enum SecretStorageEncryptionAlgorithm: Equatable, Hashable {
    
    /**
     * Encrypted using the `m.secret_storage.v1.aes-hmac-sha2` algorithm.
     *
     * Secrets using this method are encrypted using AES-CTR-256 and
     * authenticated using HMAC-SHA-256.
     */
    case v1AesHmacSha2(properties: SecretStorageV1AesHmacSha2Properties
    )





}

#if compiler(>=6)
extension SecretStorageEncryptionAlgorithm: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSecretStorageEncryptionAlgorithm: FfiConverterRustBuffer {
    typealias SwiftType = SecretStorageEncryptionAlgorithm

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecretStorageEncryptionAlgorithm {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .v1AesHmacSha2(properties: try FfiConverterTypeSecretStorageV1AesHmacSha2Properties.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecretStorageEncryptionAlgorithm, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .v1AesHmacSha2(properties):
            writeInt(&buf, Int32(1))
            FfiConverterTypeSecretStorageV1AesHmacSha2Properties.write(properties, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretStorageEncryptionAlgorithm_lift(_ buf: RustBuffer) throws -> SecretStorageEncryptionAlgorithm {
    return try FfiConverterTypeSecretStorageEncryptionAlgorithm.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSecretStorageEncryptionAlgorithm_lower(_ value: SecretStorageEncryptionAlgorithm) -> RustBuffer {
    return FfiConverterTypeSecretStorageEncryptionAlgorithm.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SessionVerificationData {
    
    case emojis(emojis: [SessionVerificationEmoji], indices: Data
    )
    case decimals(values: [UInt16]
    )





}

#if compiler(>=6)
extension SessionVerificationData: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSessionVerificationData: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationData

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SessionVerificationData {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .emojis(emojis: try FfiConverterSequenceTypeSessionVerificationEmoji.read(from: &buf), indices: try FfiConverterData.read(from: &buf)
        )
        
        case 2: return .decimals(values: try FfiConverterSequenceUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SessionVerificationData, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .emojis(emojis,indices):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeSessionVerificationEmoji.write(emojis, into: &buf)
            FfiConverterData.write(indices, into: &buf)
            
        
        case let .decimals(values):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceUInt16.write(values, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationData_lift(_ buf: RustBuffer) throws -> SessionVerificationData {
    return try FfiConverterTypeSessionVerificationData.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSessionVerificationData_lower(_ value: SessionVerificationData) -> RustBuffer {
    return FfiConverterTypeSessionVerificationData.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Recommended decorations for decrypted messages, representing the message's
 * authenticity properties.
 */

public enum ShieldState: Equatable, Hashable {
    
    /**
     * A red shield with a tooltip containing the associated message should be
     * presented.
     */
    case red(code: ShieldStateCode, message: String
    )
    /**
     * A grey shield with a tooltip containing the associated message should be
     * presented.
     */
    case grey(code: ShieldStateCode, message: String
    )
    /**
     * No shield should be presented.
     */
    case none





}

#if compiler(>=6)
extension ShieldState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeShieldState: FfiConverterRustBuffer {
    typealias SwiftType = ShieldState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ShieldState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .red(code: try FfiConverterTypeShieldStateCode.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .grey(code: try FfiConverterTypeShieldStateCode.read(from: &buf), message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .none
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: ShieldState, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .red(code,message):
            writeInt(&buf, Int32(1))
            FfiConverterTypeShieldStateCode.write(code, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case let .grey(code,message):
            writeInt(&buf, Int32(2))
            FfiConverterTypeShieldStateCode.write(code, into: &buf)
            FfiConverterString.write(message, into: &buf)
            
        
        case .none:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShieldState_lift(_ buf: RustBuffer) throws -> ShieldState {
    return try FfiConverterTypeShieldState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeShieldState_lower(_ value: ShieldState) -> RustBuffer {
    return FfiConverterTypeShieldState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SlidingSyncVersion: Equatable, Hashable {
    
    case none
    case native





}

#if compiler(>=6)
extension SlidingSyncVersion: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSlidingSyncVersion: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncVersion

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncVersion {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .native
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncVersion, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .native:
            writeInt(&buf, Int32(2))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSlidingSyncVersion_lift(_ buf: RustBuffer) throws -> SlidingSyncVersion {
    return try FfiConverterTypeSlidingSyncVersion.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSlidingSyncVersion_lower(_ value: SlidingSyncVersion) -> RustBuffer {
    return FfiConverterTypeSlidingSyncVersion.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SlidingSyncVersionBuilder: Equatable, Hashable {
    
    case none
    case native
    case discoverNative





}

#if compiler(>=6)
extension SlidingSyncVersionBuilder: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSlidingSyncVersionBuilder: FfiConverterRustBuffer {
    typealias SwiftType = SlidingSyncVersionBuilder

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SlidingSyncVersionBuilder {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .native
        
        case 3: return .discoverNative
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SlidingSyncVersionBuilder, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .native:
            writeInt(&buf, Int32(2))
        
        
        case .discoverNative:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSlidingSyncVersionBuilder_lift(_ buf: RustBuffer) throws -> SlidingSyncVersionBuilder {
    return try FfiConverterTypeSlidingSyncVersionBuilder.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSlidingSyncVersionBuilder_lower(_ value: SlidingSyncVersionBuilder) -> RustBuffer {
    return FfiConverterTypeSlidingSyncVersionBuilder.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SpaceListUpdate: Equatable, Hashable {
    
    case append(values: [SpaceRoom]
    )
    case clear
    case pushFront(value: SpaceRoom
    )
    case pushBack(value: SpaceRoom
    )
    case popFront
    case popBack
    case insert(index: UInt32, value: SpaceRoom
    )
    case set(index: UInt32, value: SpaceRoom
    )
    case remove(index: UInt32
    )
    case truncate(length: UInt32
    )
    case reset(values: [SpaceRoom]
    )





}

#if compiler(>=6)
extension SpaceListUpdate: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSpaceListUpdate: FfiConverterRustBuffer {
    typealias SwiftType = SpaceListUpdate

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SpaceListUpdate {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append(values: try FfiConverterSequenceTypeSpaceRoom.read(from: &buf)
        )
        
        case 2: return .clear
        
        case 3: return .pushFront(value: try FfiConverterTypeSpaceRoom.read(from: &buf)
        )
        
        case 4: return .pushBack(value: try FfiConverterTypeSpaceRoom.read(from: &buf)
        )
        
        case 5: return .popFront
        
        case 6: return .popBack
        
        case 7: return .insert(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeSpaceRoom.read(from: &buf)
        )
        
        case 8: return .set(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeSpaceRoom.read(from: &buf)
        )
        
        case 9: return .remove(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .truncate(length: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .reset(values: try FfiConverterSequenceTypeSpaceRoom.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SpaceListUpdate, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .append(values):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeSpaceRoom.write(values, into: &buf)
            
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case let .pushFront(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeSpaceRoom.write(value, into: &buf)
            
        
        case let .pushBack(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeSpaceRoom.write(value, into: &buf)
            
        
        case .popFront:
            writeInt(&buf, Int32(5))
        
        
        case .popBack:
            writeInt(&buf, Int32(6))
        
        
        case let .insert(index,value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeSpaceRoom.write(value, into: &buf)
            
        
        case let .set(index,value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeSpaceRoom.write(value, into: &buf)
            
        
        case let .remove(index):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .truncate(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .reset(values):
            writeInt(&buf, Int32(11))
            FfiConverterSequenceTypeSpaceRoom.write(values, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceListUpdate_lift(_ buf: RustBuffer) throws -> SpaceListUpdate {
    return try FfiConverterTypeSpaceListUpdate.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSpaceListUpdate_lower(_ value: SpaceListUpdate) -> RustBuffer {
    return FfiConverterTypeSpaceListUpdate.lower(value)
}



public enum SsoError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case CallbackUrlInvalid(message: String)
    
    case LoginWithTokenFailed(message: String)
    
    case Generic(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SsoError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSsoError: FfiConverterRustBuffer {
    typealias SwiftType = SsoError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SsoError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .CallbackUrlInvalid(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .LoginWithTokenFailed(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Generic(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SsoError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .CallbackUrlInvalid(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .LoginWithTokenFailed(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Generic(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSsoError_lift(_ buf: RustBuffer) throws -> SsoError {
    return try FfiConverterTypeSsoError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSsoError_lower(_ value: SsoError) -> RustBuffer {
    return FfiConverterTypeSsoError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum StateEventContent: Equatable, Hashable {
    
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomJoinRules
    case roomMemberContent(userId: String, membershipState: MembershipState
    )
    case roomName
    case roomPinnedEvents
    case roomPowerLevels
    case roomServerAcl
    case roomThirdPartyInvite
    case roomTombstone
    case roomTopic(topic: String
    )
    case spaceChild
    case spaceParent





}

#if compiler(>=6)
extension StateEventContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStateEventContent: FfiConverterRustBuffer {
    typealias SwiftType = StateEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .policyRuleRoom
        
        case 2: return .policyRuleServer
        
        case 3: return .policyRuleUser
        
        case 4: return .roomAliases
        
        case 5: return .roomAvatar
        
        case 6: return .roomCanonicalAlias
        
        case 7: return .roomCreate
        
        case 8: return .roomEncryption
        
        case 9: return .roomGuestAccess
        
        case 10: return .roomHistoryVisibility
        
        case 11: return .roomJoinRules
        
        case 12: return .roomMemberContent(userId: try FfiConverterString.read(from: &buf), membershipState: try FfiConverterTypeMembershipState.read(from: &buf)
        )
        
        case 13: return .roomName
        
        case 14: return .roomPinnedEvents
        
        case 15: return .roomPowerLevels
        
        case 16: return .roomServerAcl
        
        case 17: return .roomThirdPartyInvite
        
        case 18: return .roomTombstone
        
        case 19: return .roomTopic(topic: try FfiConverterString.read(from: &buf)
        )
        
        case 20: return .spaceChild
        
        case 21: return .spaceParent
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(1))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(2))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(3))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(4))
        
        
        case .roomAvatar:
            writeInt(&buf, Int32(5))
        
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(6))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(7))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(8))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(9))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(10))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(11))
        
        
        case let .roomMemberContent(userId,membershipState):
            writeInt(&buf, Int32(12))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterTypeMembershipState.write(membershipState, into: &buf)
            
        
        case .roomName:
            writeInt(&buf, Int32(13))
        
        
        case .roomPinnedEvents:
            writeInt(&buf, Int32(14))
        
        
        case .roomPowerLevels:
            writeInt(&buf, Int32(15))
        
        
        case .roomServerAcl:
            writeInt(&buf, Int32(16))
        
        
        case .roomThirdPartyInvite:
            writeInt(&buf, Int32(17))
        
        
        case .roomTombstone:
            writeInt(&buf, Int32(18))
        
        
        case let .roomTopic(topic):
            writeInt(&buf, Int32(19))
            FfiConverterString.write(topic, into: &buf)
            
        
        case .spaceChild:
            writeInt(&buf, Int32(20))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(21))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStateEventContent_lift(_ buf: RustBuffer) throws -> StateEventContent {
    return try FfiConverterTypeStateEventContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStateEventContent_lower(_ value: StateEventContent) -> RustBuffer {
    return FfiConverterTypeStateEventContent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum StateEventType: Equatable, Hashable {
    
    case beaconInfo
    case callMember
    case memberHints
    case policyRuleRoom
    case policyRuleServer
    case policyRuleUser
    case roomAliases
    case roomAvatar
    case roomCanonicalAlias
    case roomCreate
    case roomEncryption
    case roomGuestAccess
    case roomHistoryVisibility
    case roomImagePack
    case roomJoinRules
    case roomMemberEvent
    case roomLanguage
    case roomName
    case roomPinnedEvents
    case roomPowerLevels
    case roomServerAcl
    case roomThirdPartyInvite
    case roomTombstone
    case roomTopic
    case spaceChild
    case spaceParent
    case custom(value: String
    )





}

#if compiler(>=6)
extension StateEventType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeStateEventType: FfiConverterRustBuffer {
    typealias SwiftType = StateEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> StateEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .beaconInfo
        
        case 2: return .callMember
        
        case 3: return .memberHints
        
        case 4: return .policyRuleRoom
        
        case 5: return .policyRuleServer
        
        case 6: return .policyRuleUser
        
        case 7: return .roomAliases
        
        case 8: return .roomAvatar
        
        case 9: return .roomCanonicalAlias
        
        case 10: return .roomCreate
        
        case 11: return .roomEncryption
        
        case 12: return .roomGuestAccess
        
        case 13: return .roomHistoryVisibility
        
        case 14: return .roomImagePack
        
        case 15: return .roomJoinRules
        
        case 16: return .roomMemberEvent
        
        case 17: return .roomLanguage
        
        case 18: return .roomName
        
        case 19: return .roomPinnedEvents
        
        case 20: return .roomPowerLevels
        
        case 21: return .roomServerAcl
        
        case 22: return .roomThirdPartyInvite
        
        case 23: return .roomTombstone
        
        case 24: return .roomTopic
        
        case 25: return .spaceChild
        
        case 26: return .spaceParent
        
        case 27: return .custom(value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: StateEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .beaconInfo:
            writeInt(&buf, Int32(1))
        
        
        case .callMember:
            writeInt(&buf, Int32(2))
        
        
        case .memberHints:
            writeInt(&buf, Int32(3))
        
        
        case .policyRuleRoom:
            writeInt(&buf, Int32(4))
        
        
        case .policyRuleServer:
            writeInt(&buf, Int32(5))
        
        
        case .policyRuleUser:
            writeInt(&buf, Int32(6))
        
        
        case .roomAliases:
            writeInt(&buf, Int32(7))
        
        
        case .roomAvatar:
            writeInt(&buf, Int32(8))
        
        
        case .roomCanonicalAlias:
            writeInt(&buf, Int32(9))
        
        
        case .roomCreate:
            writeInt(&buf, Int32(10))
        
        
        case .roomEncryption:
            writeInt(&buf, Int32(11))
        
        
        case .roomGuestAccess:
            writeInt(&buf, Int32(12))
        
        
        case .roomHistoryVisibility:
            writeInt(&buf, Int32(13))
        
        
        case .roomImagePack:
            writeInt(&buf, Int32(14))
        
        
        case .roomJoinRules:
            writeInt(&buf, Int32(15))
        
        
        case .roomMemberEvent:
            writeInt(&buf, Int32(16))
        
        
        case .roomLanguage:
            writeInt(&buf, Int32(17))
        
        
        case .roomName:
            writeInt(&buf, Int32(18))
        
        
        case .roomPinnedEvents:
            writeInt(&buf, Int32(19))
        
        
        case .roomPowerLevels:
            writeInt(&buf, Int32(20))
        
        
        case .roomServerAcl:
            writeInt(&buf, Int32(21))
        
        
        case .roomThirdPartyInvite:
            writeInt(&buf, Int32(22))
        
        
        case .roomTombstone:
            writeInt(&buf, Int32(23))
        
        
        case .roomTopic:
            writeInt(&buf, Int32(24))
        
        
        case .spaceChild:
            writeInt(&buf, Int32(25))
        
        
        case .spaceParent:
            writeInt(&buf, Int32(26))
        
        
        case let .custom(value):
            writeInt(&buf, Int32(27))
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStateEventType_lift(_ buf: RustBuffer) throws -> StateEventType {
    return try FfiConverterTypeStateEventType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeStateEventType_lower(_ value: StateEventType) -> RustBuffer {
    return FfiConverterTypeStateEventType.lower(value)
}



public enum SteadyStateError: Swift.Error, Equatable, Hashable, Foundation.LocalizedError {

    
    
    case BackupDisabled(message: String)
    
    case Connection(message: String)
    
    case Lagged(message: String)
    

    

    

    
    public var errorDescription: String? {
        String(reflecting: self)
    }
    
}

#if compiler(>=6)
extension SteadyStateError: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSteadyStateError: FfiConverterRustBuffer {
    typealias SwiftType = SteadyStateError

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SteadyStateError {
        let variant: Int32 = try readInt(&buf)
        switch variant {

        

        
        case 1: return .BackupDisabled(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .Connection(
            message: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .Lagged(
            message: try FfiConverterString.read(from: &buf)
        )
        

        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SteadyStateError, into buf: inout [UInt8]) {
        switch value {

        

        
        case .BackupDisabled(_ /* message is ignored*/):
            writeInt(&buf, Int32(1))
        case .Connection(_ /* message is ignored*/):
            writeInt(&buf, Int32(2))
        case .Lagged(_ /* message is ignored*/):
            writeInt(&buf, Int32(3))

        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSteadyStateError_lift(_ buf: RustBuffer) throws -> SteadyStateError {
    return try FfiConverterTypeSteadyStateError.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSteadyStateError_lower(_ value: SteadyStateError) -> RustBuffer {
    return FfiConverterTypeSteadyStateError.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SyncServiceState: Equatable, Hashable {
    
    case idle
    case running
    case terminated
    case error
    case offline





}

#if compiler(>=6)
extension SyncServiceState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeSyncServiceState: FfiConverterRustBuffer {
    typealias SwiftType = SyncServiceState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SyncServiceState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .idle
        
        case 2: return .running
        
        case 3: return .terminated
        
        case 4: return .error
        
        case 5: return .offline
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SyncServiceState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .idle:
            writeInt(&buf, Int32(1))
        
        
        case .running:
            writeInt(&buf, Int32(2))
        
        
        case .terminated:
            writeInt(&buf, Int32(3))
        
        
        case .error:
            writeInt(&buf, Int32(4))
        
        
        case .offline:
            writeInt(&buf, Int32(5))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncServiceState_lift(_ buf: RustBuffer) throws -> SyncServiceState {
    return try FfiConverterTypeSyncServiceState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeSyncServiceState_lower(_ value: SyncServiceState) -> RustBuffer {
    return FfiConverterTypeSyncServiceState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The name of a tag.
 */

public enum TagName: Equatable, Hashable {
    
    /**
     * `m.favourite`: The user's favorite rooms.
     */
    case favorite
    /**
     * `m.lowpriority`: These should be shown with lower precedence than
     * others.
     */
    case lowPriority
    /**
     * `m.server_notice`: Used to identify
     */
    case serverNotice
    /**
     * `u.*`: User-defined tag
     */
    case user(name: UserTagName
    )





}

#if compiler(>=6)
extension TagName: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTagName: FfiConverterRustBuffer {
    typealias SwiftType = TagName

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TagName {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .favorite
        
        case 2: return .lowPriority
        
        case 3: return .serverNotice
        
        case 4: return .user(name: try FfiConverterTypeUserTagName.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TagName, into buf: inout [UInt8]) {
        switch value {
        
        
        case .favorite:
            writeInt(&buf, Int32(1))
        
        
        case .lowPriority:
            writeInt(&buf, Int32(2))
        
        
        case .serverNotice:
            writeInt(&buf, Int32(3))
        
        
        case let .user(name):
            writeInt(&buf, Int32(4))
            FfiConverterTypeUserTagName.write(name, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagName_lift(_ buf: RustBuffer) throws -> TagName {
    return try FfiConverterTypeTagName.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTagName_lower(_ value: TagName) -> RustBuffer {
    return FfiConverterTypeTagName.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineDiff {
    
    case append(values: [TimelineItem]
    )
    case clear
    case pushFront(value: TimelineItem
    )
    case pushBack(value: TimelineItem
    )
    case popFront
    case popBack
    case insert(index: UInt32, value: TimelineItem
    )
    case set(index: UInt32, value: TimelineItem
    )
    case remove(index: UInt32
    )
    case truncate(length: UInt32
    )
    case reset(values: [TimelineItem]
    )





}

#if compiler(>=6)
extension TimelineDiff: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineDiff: FfiConverterRustBuffer {
    typealias SwiftType = TimelineDiff

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineDiff {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .append(values: try FfiConverterSequenceTypeTimelineItem.read(from: &buf)
        )
        
        case 2: return .clear
        
        case 3: return .pushFront(value: try FfiConverterTypeTimelineItem.read(from: &buf)
        )
        
        case 4: return .pushBack(value: try FfiConverterTypeTimelineItem.read(from: &buf)
        )
        
        case 5: return .popFront
        
        case 6: return .popBack
        
        case 7: return .insert(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeTimelineItem.read(from: &buf)
        )
        
        case 8: return .set(index: try FfiConverterUInt32.read(from: &buf), value: try FfiConverterTypeTimelineItem.read(from: &buf)
        )
        
        case 9: return .remove(index: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 10: return .truncate(length: try FfiConverterUInt32.read(from: &buf)
        )
        
        case 11: return .reset(values: try FfiConverterSequenceTypeTimelineItem.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineDiff, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .append(values):
            writeInt(&buf, Int32(1))
            FfiConverterSequenceTypeTimelineItem.write(values, into: &buf)
            
        
        case .clear:
            writeInt(&buf, Int32(2))
        
        
        case let .pushFront(value):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTimelineItem.write(value, into: &buf)
            
        
        case let .pushBack(value):
            writeInt(&buf, Int32(4))
            FfiConverterTypeTimelineItem.write(value, into: &buf)
            
        
        case .popFront:
            writeInt(&buf, Int32(5))
        
        
        case .popBack:
            writeInt(&buf, Int32(6))
        
        
        case let .insert(index,value):
            writeInt(&buf, Int32(7))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeTimelineItem.write(value, into: &buf)
            
        
        case let .set(index,value):
            writeInt(&buf, Int32(8))
            FfiConverterUInt32.write(index, into: &buf)
            FfiConverterTypeTimelineItem.write(value, into: &buf)
            
        
        case let .remove(index):
            writeInt(&buf, Int32(9))
            FfiConverterUInt32.write(index, into: &buf)
            
        
        case let .truncate(length):
            writeInt(&buf, Int32(10))
            FfiConverterUInt32.write(length, into: &buf)
            
        
        case let .reset(values):
            writeInt(&buf, Int32(11))
            FfiConverterSequenceTypeTimelineItem.write(values, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineDiff_lift(_ buf: RustBuffer) throws -> TimelineDiff {
    return try FfiConverterTypeTimelineDiff.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineDiff_lower(_ value: TimelineDiff) -> RustBuffer {
    return FfiConverterTypeTimelineDiff.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineEventContent {
    
    case messageLike(content: MessageLikeEventContent
    )
    case state(content: StateEventContent
    )





}

#if compiler(>=6)
extension TimelineEventContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineEventContent: FfiConverterRustBuffer {
    typealias SwiftType = TimelineEventContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEventContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLike(content: try FfiConverterTypeMessageLikeEventContent.read(from: &buf)
        )
        
        case 2: return .state(content: try FfiConverterTypeStateEventContent.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineEventContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLike(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageLikeEventContent.write(content, into: &buf)
            
        
        case let .state(content):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStateEventContent.write(content, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEventContent_lift(_ buf: RustBuffer) throws -> TimelineEventContent {
    return try FfiConverterTypeTimelineEventContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEventContent_lower(_ value: TimelineEventContent) -> RustBuffer {
    return FfiConverterTypeTimelineEventContent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * The timeline event type.
 */

public enum TimelineEventType: Equatable, Hashable {
    
    /**
     * The event is a message-like one and should be displayed as such.
     */
    case messageLike(value: MessageLikeEventType
    )
    /**
     * The event is a state event, and may or may not be displayed in the
     * timeline.
     */
    case state(value: StateEventType
    )





}

#if compiler(>=6)
extension TimelineEventType: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = TimelineEventType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineEventType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLike(value: try FfiConverterTypeMessageLikeEventType.read(from: &buf)
        )
        
        case 2: return .state(value: try FfiConverterTypeStateEventType.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineEventType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLike(value):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMessageLikeEventType.write(value, into: &buf)
            
        
        case let .state(value):
            writeInt(&buf, Int32(2))
            FfiConverterTypeStateEventType.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEventType_lift(_ buf: RustBuffer) throws -> TimelineEventType {
    return try FfiConverterTypeTimelineEventType.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineEventType_lower(_ value: TimelineEventType) -> RustBuffer {
    return FfiConverterTypeTimelineEventType.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineFilter {
    
    /**
     * Show all the events in the timeline, independent of their type.
     */
    case all
    /**
     * Show only `m.room.messages` of the given room message types.
     */
    case onlyMessage(
        /**
         * A list of [`RoomMessageEventMessageType`] that will be allowed to
         * appear in the timeline.
         */types: [RoomMessageEventMessageType]
    )
    /**
     * Show only events which match this filter.
     */
    case eventTypeFilter(filter: TimelineEventTypeFilter
    )





}

#if compiler(>=6)
extension TimelineFilter: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineFilter: FfiConverterRustBuffer {
    typealias SwiftType = TimelineFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .all
        
        case 2: return .onlyMessage(types: try FfiConverterSequenceTypeRoomMessageEventMessageType.read(from: &buf)
        )
        
        case 3: return .eventTypeFilter(filter: try FfiConverterTypeTimelineEventTypeFilter.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case .all:
            writeInt(&buf, Int32(1))
        
        
        case let .onlyMessage(types):
            writeInt(&buf, Int32(2))
            FfiConverterSequenceTypeRoomMessageEventMessageType.write(types, into: &buf)
            
        
        case let .eventTypeFilter(filter):
            writeInt(&buf, Int32(3))
            FfiConverterTypeTimelineEventTypeFilter.write(filter, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineFilter_lift(_ buf: RustBuffer) throws -> TimelineFilter {
    return try FfiConverterTypeTimelineFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineFilter_lower(_ value: TimelineFilter) -> RustBuffer {
    return FfiConverterTypeTimelineFilter.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineFocus: Equatable, Hashable {
    
    case live(
        /**
         * Whether to hide in-thread replies from the live timeline.
         */hideThreadedEvents: Bool
    )
    case event(
        /**
         * The initial event to focus on. This is usually the target of a
         * permalink.
         */eventId: String, 
        /**
         * The number of context events to load around the focused event.
         */numContextEvents: UInt16, 
        /**
         * Whether to hide in-thread replies from the live timeline.
         */hideThreadedEvents: Bool
    )
    case thread(
        /**
         * The thread root event ID to focus on.
         */rootEventId: String
    )
    case pinnedEvents(maxEventsToLoad: UInt16, maxConcurrentRequests: UInt16
    )





}

#if compiler(>=6)
extension TimelineFocus: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineFocus: FfiConverterRustBuffer {
    typealias SwiftType = TimelineFocus

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineFocus {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .live(hideThreadedEvents: try FfiConverterBool.read(from: &buf)
        )
        
        case 2: return .event(eventId: try FfiConverterString.read(from: &buf), numContextEvents: try FfiConverterUInt16.read(from: &buf), hideThreadedEvents: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .thread(rootEventId: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .pinnedEvents(maxEventsToLoad: try FfiConverterUInt16.read(from: &buf), maxConcurrentRequests: try FfiConverterUInt16.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineFocus, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .live(hideThreadedEvents):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(hideThreadedEvents, into: &buf)
            
        
        case let .event(eventId,numContextEvents,hideThreadedEvents):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(eventId, into: &buf)
            FfiConverterUInt16.write(numContextEvents, into: &buf)
            FfiConverterBool.write(hideThreadedEvents, into: &buf)
            
        
        case let .thread(rootEventId):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(rootEventId, into: &buf)
            
        
        case let .pinnedEvents(maxEventsToLoad,maxConcurrentRequests):
            writeInt(&buf, Int32(4))
            FfiConverterUInt16.write(maxEventsToLoad, into: &buf)
            FfiConverterUInt16.write(maxConcurrentRequests, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineFocus_lift(_ buf: RustBuffer) throws -> TimelineFocus {
    return try FfiConverterTypeTimelineFocus.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineFocus_lower(_ value: TimelineFocus) -> RustBuffer {
    return FfiConverterTypeTimelineFocus.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum TimelineItemContent {
    
    case msgLike(content: MsgLikeContent
    )
    case callInvite
    case rtcNotification
    case roomMembership(userId: String, userDisplayName: String?, change: MembershipChange?, reason: String?
    )
    case profileChange(displayName: String?, prevDisplayName: String?, avatarUrl: String?, prevAvatarUrl: String?
    )
    case state(stateKey: String, content: OtherState
    )
    case failedToParseMessageLike(eventType: String, error: String
    )
    case failedToParseState(eventType: String, stateKey: String, error: String
    )





}

#if compiler(>=6)
extension TimelineItemContent: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimelineItemContent: FfiConverterRustBuffer {
    typealias SwiftType = TimelineItemContent

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TimelineItemContent {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .msgLike(content: try FfiConverterTypeMsgLikeContent.read(from: &buf)
        )
        
        case 2: return .callInvite
        
        case 3: return .rtcNotification
        
        case 4: return .roomMembership(userId: try FfiConverterString.read(from: &buf), userDisplayName: try FfiConverterOptionString.read(from: &buf), change: try FfiConverterOptionTypeMembershipChange.read(from: &buf), reason: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 5: return .profileChange(displayName: try FfiConverterOptionString.read(from: &buf), prevDisplayName: try FfiConverterOptionString.read(from: &buf), avatarUrl: try FfiConverterOptionString.read(from: &buf), prevAvatarUrl: try FfiConverterOptionString.read(from: &buf)
        )
        
        case 6: return .state(stateKey: try FfiConverterString.read(from: &buf), content: try FfiConverterTypeOtherState.read(from: &buf)
        )
        
        case 7: return .failedToParseMessageLike(eventType: try FfiConverterString.read(from: &buf), error: try FfiConverterString.read(from: &buf)
        )
        
        case 8: return .failedToParseState(eventType: try FfiConverterString.read(from: &buf), stateKey: try FfiConverterString.read(from: &buf), error: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TimelineItemContent, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .msgLike(content):
            writeInt(&buf, Int32(1))
            FfiConverterTypeMsgLikeContent.write(content, into: &buf)
            
        
        case .callInvite:
            writeInt(&buf, Int32(2))
        
        
        case .rtcNotification:
            writeInt(&buf, Int32(3))
        
        
        case let .roomMembership(userId,userDisplayName,change,reason):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(userId, into: &buf)
            FfiConverterOptionString.write(userDisplayName, into: &buf)
            FfiConverterOptionTypeMembershipChange.write(change, into: &buf)
            FfiConverterOptionString.write(reason, into: &buf)
            
        
        case let .profileChange(displayName,prevDisplayName,avatarUrl,prevAvatarUrl):
            writeInt(&buf, Int32(5))
            FfiConverterOptionString.write(displayName, into: &buf)
            FfiConverterOptionString.write(prevDisplayName, into: &buf)
            FfiConverterOptionString.write(avatarUrl, into: &buf)
            FfiConverterOptionString.write(prevAvatarUrl, into: &buf)
            
        
        case let .state(stateKey,content):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(stateKey, into: &buf)
            FfiConverterTypeOtherState.write(content, into: &buf)
            
        
        case let .failedToParseMessageLike(eventType,error):
            writeInt(&buf, Int32(7))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        
        case let .failedToParseState(eventType,stateKey,error):
            writeInt(&buf, Int32(8))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(stateKey, into: &buf)
            FfiConverterString.write(error, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineItemContent_lift(_ buf: RustBuffer) throws -> TimelineItemContent {
    return try FfiConverterTypeTimelineItemContent.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimelineItemContent_lower(_ value: TimelineItemContent) -> RustBuffer {
    return FfiConverterTypeTimelineItemContent.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A log pack can be used to set the trace log level for a group of multiple
 * log targets at once, for debugging purposes.
 */

public enum TraceLogPacks: Equatable, Hashable {
    
    /**
     * Enables all the logs relevant to the event cache.
     */
    case eventCache
    /**
     * Enables all the logs relevant to the send queue.
     */
    case sendQueue
    /**
     * Enables all the logs relevant to the timeline.
     */
    case timeline
    /**
     * Enables all the logs relevant to the notification client.
     */
    case notificationClient
    /**
     * Enables all the logs relevant to sync profiling.
     */
    case syncProfiling
    /**
     * Enables all the logs relevant to the latest events.
     */
    case latestEvents





}

#if compiler(>=6)
extension TraceLogPacks: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTraceLogPacks: FfiConverterRustBuffer {
    typealias SwiftType = TraceLogPacks

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TraceLogPacks {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .eventCache
        
        case 2: return .sendQueue
        
        case 3: return .timeline
        
        case 4: return .notificationClient
        
        case 5: return .syncProfiling
        
        case 6: return .latestEvents
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: TraceLogPacks, into buf: inout [UInt8]) {
        switch value {
        
        
        case .eventCache:
            writeInt(&buf, Int32(1))
        
        
        case .sendQueue:
            writeInt(&buf, Int32(2))
        
        
        case .timeline:
            writeInt(&buf, Int32(3))
        
        
        case .notificationClient:
            writeInt(&buf, Int32(4))
        
        
        case .syncProfiling:
            writeInt(&buf, Int32(5))
        
        
        case .latestEvents:
            writeInt(&buf, Int32(6))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTraceLogPacks_lift(_ buf: RustBuffer) throws -> TraceLogPacks {
    return try FfiConverterTypeTraceLogPacks.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTraceLogPacks_lower(_ value: TraceLogPacks) -> RustBuffer {
    return FfiConverterTypeTraceLogPacks.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Enum representing the push notification tweaks for a rule.
 */

public enum Tweak: Equatable, Hashable {
    
    /**
     * A string representing the sound to be played when this notification
     * arrives.
     *
     * A value of "default" means to play a default sound. A device may choose
     * to alert the user by some other means if appropriate, eg. vibration.
     */
    case sound(value: String
    )
    /**
     * A boolean representing whether or not this message should be highlighted
     * in the UI.
     */
    case highlight(value: Bool
    )
    /**
     * A custom tweak
     */
    case custom(
        /**
         * The name of the custom tweak (`set_tweak` field)
         */name: String, 
        /**
         * The value of the custom tweak as an encoded JSON string
         */value: String
    )





}

#if compiler(>=6)
extension Tweak: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTweak: FfiConverterRustBuffer {
    typealias SwiftType = Tweak

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Tweak {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .sound(value: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .highlight(value: try FfiConverterBool.read(from: &buf)
        )
        
        case 3: return .custom(name: try FfiConverterString.read(from: &buf), value: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: Tweak, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .sound(value):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(value, into: &buf)
            
        
        case let .highlight(value):
            writeInt(&buf, Int32(2))
            FfiConverterBool.write(value, into: &buf)
            
        
        case let .custom(name,value):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(name, into: &buf)
            FfiConverterString.write(value, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTweak_lift(_ buf: RustBuffer) throws -> Tweak {
    return try FfiConverterTypeTweak.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTweak_lower(_ value: Tweak) -> RustBuffer {
    return FfiConverterTypeTweak.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A source for uploading a file
 */

public enum UploadSource: Equatable, Hashable {
    
    /**
     * Upload source is a file on disk
     */
    case file(
        /**
         * Path to file
         */filename: String
    )
    /**
     * Upload source is data in memory
     */
    case data(
        /**
         * Bytes being uploaded
         */bytes: Data, 
        /**
         * Filename to associate with bytes
         */filename: String
    )





}

#if compiler(>=6)
extension UploadSource: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeUploadSource: FfiConverterRustBuffer {
    typealias SwiftType = UploadSource

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UploadSource {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .file(filename: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .data(bytes: try FfiConverterData.read(from: &buf), filename: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UploadSource, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .file(filename):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(filename, into: &buf)
            
        
        case let .data(bytes,filename):
            writeInt(&buf, Int32(2))
            FfiConverterData.write(bytes, into: &buf)
            FfiConverterString.write(filename, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadSource_lift(_ buf: RustBuffer) throws -> UploadSource {
    return try FfiConverterTypeUploadSource.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeUploadSource_lower(_ value: UploadSource) -> RustBuffer {
    return FfiConverterTypeUploadSource.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum VerificationState: Equatable, Hashable {
    
    case unknown
    case verified
    case unverified





}

#if compiler(>=6)
extension VerificationState: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVerificationState: FfiConverterRustBuffer {
    typealias SwiftType = VerificationState

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VerificationState {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .unknown
        
        case 2: return .verified
        
        case 3: return .unverified
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VerificationState, into buf: inout [UInt8]) {
        switch value {
        
        
        case .unknown:
            writeInt(&buf, Int32(1))
        
        
        case .verified:
            writeInt(&buf, Int32(2))
        
        
        case .unverified:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerificationState_lift(_ buf: RustBuffer) throws -> VerificationState {
    return try FfiConverterTypeVerificationState.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVerificationState_lower(_ value: VerificationState) -> RustBuffer {
    return FfiConverterTypeVerificationState.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * A [`TimelineItem`](super::TimelineItem) that doesn't correspond to an event.
 */

public enum VirtualTimelineItem: Equatable, Hashable {
    
    /**
     * A divider between messages of different day or month depending on
     * timeline settings.
     */
    case dateDivider(
        /**
         * A timestamp in milliseconds since Unix Epoch on that day in local
         * time.
         */ts: Timestamp
    )
    /**
     * The user's own read marker.
     */
    case readMarker
    /**
     * The timeline start, that is, the *oldest* event in time for that room.
     */
    case timelineStart





}

#if compiler(>=6)
extension VirtualTimelineItem: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> VirtualTimelineItem {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .dateDivider(ts: try FfiConverterTypeTimestamp.read(from: &buf)
        )
        
        case 2: return .readMarker
        
        case 3: return .timelineStart
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: VirtualTimelineItem, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .dateDivider(ts):
            writeInt(&buf, Int32(1))
            FfiConverterTypeTimestamp.write(ts, into: &buf)
            
        
        case .readMarker:
            writeInt(&buf, Int32(2))
        
        
        case .timelineStart:
            writeInt(&buf, Int32(3))
        
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVirtualTimelineItem_lift(_ buf: RustBuffer) throws -> VirtualTimelineItem {
    return try FfiConverterTypeVirtualTimelineItem.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeVirtualTimelineItem_lower(_ value: VirtualTimelineItem) -> RustBuffer {
    return FfiConverterTypeVirtualTimelineItem.lower(value)
}


// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.
/**
 * Different kinds of filters that could be applied to the timeline events.
 */

public enum WidgetEventFilter: Equatable, Hashable {
    
    /**
     * Matches message-like events with the given `type`.
     */
    case messageLikeWithType(eventType: String
    )
    /**
     * Matches `m.room.message` events with the given `msgtype`.
     */
    case roomMessageWithMsgtype(msgtype: String
    )
    /**
     * Matches state events with the given `type`, regardless of `state_key`.
     */
    case stateWithType(eventType: String
    )
    /**
     * Matches state events with the given `type` and `state_key`.
     */
    case stateWithTypeAndStateKey(eventType: String, stateKey: String
    )
    /**
     * Matches to-device events with the given `event_type`.
     */
    case toDevice(eventType: String
    )





}

#if compiler(>=6)
extension WidgetEventFilter: Sendable {}
#endif

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeWidgetEventFilter: FfiConverterRustBuffer {
    typealias SwiftType = WidgetEventFilter

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> WidgetEventFilter {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .messageLikeWithType(eventType: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .roomMessageWithMsgtype(msgtype: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .stateWithType(eventType: try FfiConverterString.read(from: &buf)
        )
        
        case 4: return .stateWithTypeAndStateKey(eventType: try FfiConverterString.read(from: &buf), stateKey: try FfiConverterString.read(from: &buf)
        )
        
        case 5: return .toDevice(eventType: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: WidgetEventFilter, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .messageLikeWithType(eventType):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(eventType, into: &buf)
            
        
        case let .roomMessageWithMsgtype(msgtype):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(msgtype, into: &buf)
            
        
        case let .stateWithType(eventType):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(eventType, into: &buf)
            
        
        case let .stateWithTypeAndStateKey(eventType,stateKey):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(eventType, into: &buf)
            FfiConverterString.write(stateKey, into: &buf)
            
        
        case let .toDevice(eventType):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(eventType, into: &buf)
            
        }
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetEventFilter_lift(_ buf: RustBuffer) throws -> WidgetEventFilter {
    return try FfiConverterTypeWidgetEventFilter.lift(buf)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeWidgetEventFilter_lower(_ value: WidgetEventFilter) -> RustBuffer {
    return FfiConverterTypeWidgetEventFilter.lower(value)
}





/**
 * A listener for changes of global account data events.
 */
public protocol AccountDataListener: AnyObject, Sendable {
    
    /**
     * Called when a global account data event has changed.
     */
    func onChange(event: AccountDataEvent) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceAccountDataListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceAccountDataListener] = [UniffiVTableCallbackInterfaceAccountDataListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceAccountDataListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface AccountDataListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceAccountDataListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface AccountDataListener: handle missing in uniffiClone")
            }
        },
        onChange: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceAccountDataListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onChange(
                     event: try FfiConverterTypeAccountDataEvent_lift(event)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitAccountDataListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_accountdatalistener(UniffiCallbackInterfaceAccountDataListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceAccountDataListener {
    fileprivate static let handleMap = UniffiHandleMap<AccountDataListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceAccountDataListener : FfiConverter {
    typealias SwiftType = AccountDataListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAccountDataListener_lift(_ handle: UInt64) throws -> AccountDataListener {
    return try FfiConverterCallbackInterfaceAccountDataListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceAccountDataListener_lower(_ v: AccountDataListener) -> UInt64 {
    return FfiConverterCallbackInterfaceAccountDataListener.lower(v)
}




public protocol BackupStateListener: AnyObject, Sendable {
    
    func onUpdate(status: BackupState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBackupStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceBackupStateListener] = [UniffiVTableCallbackInterfaceBackupStateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceBackupStateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface BackupStateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceBackupStateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface BackupStateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBackupStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeBackupState_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitBackupStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupstatelistener(UniffiCallbackInterfaceBackupStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceBackupStateListener {
    fileprivate static let handleMap = UniffiHandleMap<BackupStateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceBackupStateListener : FfiConverter {
    typealias SwiftType = BackupStateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceBackupStateListener_lift(_ handle: UInt64) throws -> BackupStateListener {
    return try FfiConverterCallbackInterfaceBackupStateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceBackupStateListener_lower(_ v: BackupStateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceBackupStateListener.lower(v)
}




public protocol BackupSteadyStateListener: AnyObject, Sendable {
    
    func onUpdate(status: BackupUploadState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceBackupSteadyStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceBackupSteadyStateListener] = [UniffiVTableCallbackInterfaceBackupSteadyStateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceBackupSteadyStateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface BackupSteadyStateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceBackupSteadyStateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface BackupSteadyStateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceBackupSteadyStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeBackupUploadState_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitBackupSteadyStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_backupsteadystatelistener(UniffiCallbackInterfaceBackupSteadyStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceBackupSteadyStateListener {
    fileprivate static let handleMap = UniffiHandleMap<BackupSteadyStateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceBackupSteadyStateListener : FfiConverter {
    typealias SwiftType = BackupSteadyStateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceBackupSteadyStateListener_lift(_ handle: UInt64) throws -> BackupSteadyStateListener {
    return try FfiConverterCallbackInterfaceBackupSteadyStateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceBackupSteadyStateListener_lower(_ v: BackupSteadyStateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceBackupSteadyStateListener.lower(v)
}




/**
 * A listener for receiving call decline events in a room.
 */
public protocol CallDeclineListener: AnyObject, Sendable {
    
    func call(declinerUserId: String) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceCallDeclineListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceCallDeclineListener] = [UniffiVTableCallbackInterfaceCallDeclineListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceCallDeclineListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface CallDeclineListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceCallDeclineListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface CallDeclineListener: handle missing in uniffiClone")
            }
        },
        call: { (
            uniffiHandle: UInt64,
            declinerUserId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceCallDeclineListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     declinerUserId: try FfiConverterString.lift(declinerUserId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitCallDeclineListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_calldeclinelistener(UniffiCallbackInterfaceCallDeclineListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceCallDeclineListener {
    fileprivate static let handleMap = UniffiHandleMap<CallDeclineListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceCallDeclineListener : FfiConverter {
    typealias SwiftType = CallDeclineListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCallDeclineListener_lift(_ handle: UInt64) throws -> CallDeclineListener {
    return try FfiConverterCallbackInterfaceCallDeclineListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceCallDeclineListener_lower(_ v: CallDeclineListener) -> UInt64 {
    return FfiConverterCallbackInterfaceCallDeclineListener.lower(v)
}




public protocol ClientDelegate: AnyObject, Sendable {
    
    func didReceiveAuthError(isSoftLogout: Bool) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceClientDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceClientDelegate] = [UniffiVTableCallbackInterfaceClientDelegate(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceClientDelegate.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface ClientDelegate: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceClientDelegate.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface ClientDelegate: handle missing in uniffiClone")
            }
        },
        didReceiveAuthError: { (
            uniffiHandle: UInt64,
            isSoftLogout: Int8,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceClientDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didReceiveAuthError(
                     isSoftLogout: try FfiConverterBool.lift(isSoftLogout)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitClientDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientdelegate(UniffiCallbackInterfaceClientDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceClientDelegate {
    fileprivate static let handleMap = UniffiHandleMap<ClientDelegate>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceClientDelegate : FfiConverter {
    typealias SwiftType = ClientDelegate
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceClientDelegate_lift(_ handle: UInt64) throws -> ClientDelegate {
    return try FfiConverterCallbackInterfaceClientDelegate.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceClientDelegate_lower(_ v: ClientDelegate) -> UInt64 {
    return FfiConverterCallbackInterfaceClientDelegate.lower(v)
}




public protocol ClientSessionDelegate: AnyObject, Sendable {
    
    func retrieveSessionFromKeychain(userId: String) throws  -> Session
    
    func saveSessionInKeychain(session: Session) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceClientSessionDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceClientSessionDelegate] = [UniffiVTableCallbackInterfaceClientSessionDelegate(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceClientSessionDelegate.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface ClientSessionDelegate: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceClientSessionDelegate.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface ClientSessionDelegate: handle missing in uniffiClone")
            }
        },
        retrieveSessionFromKeychain: { (
            uniffiHandle: UInt64,
            userId: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> Session in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceClientSessionDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return try uniffiObj.retrieveSessionFromKeychain(
                     userId: try FfiConverterString.lift(userId)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeSession_lower($0) }
            uniffiTraitInterfaceCallWithError(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn,
                lowerError: FfiConverterTypeClientError_lower
            )
        },
        saveSessionInKeychain: { (
            uniffiHandle: UInt64,
            session: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceClientSessionDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.saveSessionInKeychain(
                     session: try FfiConverterTypeSession_lift(session)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitClientSessionDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_clientsessiondelegate(UniffiCallbackInterfaceClientSessionDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceClientSessionDelegate {
    fileprivate static let handleMap = UniffiHandleMap<ClientSessionDelegate>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceClientSessionDelegate : FfiConverter {
    typealias SwiftType = ClientSessionDelegate
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceClientSessionDelegate_lift(_ handle: UInt64) throws -> ClientSessionDelegate {
    return try FfiConverterCallbackInterfaceClientSessionDelegate.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceClientSessionDelegate_lower(_ v: ClientSessionDelegate) -> UInt64 {
    return FfiConverterCallbackInterfaceClientSessionDelegate.lower(v)
}




public protocol EnableRecoveryProgressListener: AnyObject, Sendable {
    
    func onUpdate(status: EnableRecoveryProgress) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceEnableRecoveryProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceEnableRecoveryProgressListener] = [UniffiVTableCallbackInterfaceEnableRecoveryProgressListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceEnableRecoveryProgressListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface EnableRecoveryProgressListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceEnableRecoveryProgressListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface EnableRecoveryProgressListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceEnableRecoveryProgressListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeEnableRecoveryProgress_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitEnableRecoveryProgressListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_enablerecoveryprogresslistener(UniffiCallbackInterfaceEnableRecoveryProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceEnableRecoveryProgressListener {
    fileprivate static let handleMap = UniffiHandleMap<EnableRecoveryProgressListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceEnableRecoveryProgressListener : FfiConverter {
    typealias SwiftType = EnableRecoveryProgressListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceEnableRecoveryProgressListener_lift(_ handle: UInt64) throws -> EnableRecoveryProgressListener {
    return try FfiConverterCallbackInterfaceEnableRecoveryProgressListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceEnableRecoveryProgressListener_lower(_ v: EnableRecoveryProgressListener) -> UInt64 {
    return FfiConverterCallbackInterfaceEnableRecoveryProgressListener.lower(v)
}




public protocol GeneratedQrLoginProgressListener: AnyObject, Sendable {
    
    func onUpdate(state: GeneratedQrLoginProgress) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceGeneratedQrLoginProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceGeneratedQrLoginProgressListener] = [UniffiVTableCallbackInterfaceGeneratedQrLoginProgressListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface GeneratedQrLoginProgressListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface GeneratedQrLoginProgressListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeGeneratedQrLoginProgress_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitGeneratedQrLoginProgressListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_generatedqrloginprogresslistener(UniffiCallbackInterfaceGeneratedQrLoginProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener {
    fileprivate static let handleMap = UniffiHandleMap<GeneratedQrLoginProgressListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener : FfiConverter {
    typealias SwiftType = GeneratedQrLoginProgressListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener_lift(_ handle: UInt64) throws -> GeneratedQrLoginProgressListener {
    return try FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener_lower(_ v: GeneratedQrLoginProgressListener) -> UInt64 {
    return FfiConverterCallbackInterfaceGeneratedQrLoginProgressListener.lower(v)
}




public protocol GrantGeneratedQrLoginProgressListener: AnyObject, Sendable {
    
    func onUpdate(state: GrantGeneratedQrLoginProgress) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceGrantGeneratedQrLoginProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceGrantGeneratedQrLoginProgressListener] = [UniffiVTableCallbackInterfaceGrantGeneratedQrLoginProgressListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface GrantGeneratedQrLoginProgressListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface GrantGeneratedQrLoginProgressListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeGrantGeneratedQrLoginProgress_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitGrantGeneratedQrLoginProgressListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_grantgeneratedqrloginprogresslistener(UniffiCallbackInterfaceGrantGeneratedQrLoginProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener {
    fileprivate static let handleMap = UniffiHandleMap<GrantGeneratedQrLoginProgressListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener : FfiConverter {
    typealias SwiftType = GrantGeneratedQrLoginProgressListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener_lift(_ handle: UInt64) throws -> GrantGeneratedQrLoginProgressListener {
    return try FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener_lower(_ v: GrantGeneratedQrLoginProgressListener) -> UInt64 {
    return FfiConverterCallbackInterfaceGrantGeneratedQrLoginProgressListener.lower(v)
}




public protocol GrantQrLoginProgressListener: AnyObject, Sendable {
    
    func onUpdate(state: GrantQrLoginProgress) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceGrantQrLoginProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceGrantQrLoginProgressListener] = [UniffiVTableCallbackInterfaceGrantQrLoginProgressListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceGrantQrLoginProgressListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface GrantQrLoginProgressListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceGrantQrLoginProgressListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface GrantQrLoginProgressListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceGrantQrLoginProgressListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeGrantQrLoginProgress_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitGrantQrLoginProgressListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_grantqrloginprogresslistener(UniffiCallbackInterfaceGrantQrLoginProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceGrantQrLoginProgressListener {
    fileprivate static let handleMap = UniffiHandleMap<GrantQrLoginProgressListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceGrantQrLoginProgressListener : FfiConverter {
    typealias SwiftType = GrantQrLoginProgressListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceGrantQrLoginProgressListener_lift(_ handle: UInt64) throws -> GrantQrLoginProgressListener {
    return try FfiConverterCallbackInterfaceGrantQrLoginProgressListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceGrantQrLoginProgressListener_lower(_ v: GrantQrLoginProgressListener) -> UInt64 {
    return FfiConverterCallbackInterfaceGrantQrLoginProgressListener.lower(v)
}




public protocol IdentityStatusChangeListener: AnyObject, Sendable {
    
    func call(identityStatusChange: [IdentityStatusChange]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceIdentityStatusChangeListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceIdentityStatusChangeListener] = [UniffiVTableCallbackInterfaceIdentityStatusChangeListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceIdentityStatusChangeListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface IdentityStatusChangeListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceIdentityStatusChangeListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface IdentityStatusChangeListener: handle missing in uniffiClone")
            }
        },
        call: { (
            uniffiHandle: UInt64,
            identityStatusChange: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceIdentityStatusChangeListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     identityStatusChange: try FfiConverterSequenceTypeIdentityStatusChange.lift(identityStatusChange)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitIdentityStatusChangeListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_identitystatuschangelistener(UniffiCallbackInterfaceIdentityStatusChangeListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceIdentityStatusChangeListener {
    fileprivate static let handleMap = UniffiHandleMap<IdentityStatusChangeListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceIdentityStatusChangeListener : FfiConverter {
    typealias SwiftType = IdentityStatusChangeListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceIdentityStatusChangeListener_lift(_ handle: UInt64) throws -> IdentityStatusChangeListener {
    return try FfiConverterCallbackInterfaceIdentityStatusChangeListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceIdentityStatusChangeListener_lower(_ v: IdentityStatusChangeListener) -> UInt64 {
    return FfiConverterCallbackInterfaceIdentityStatusChangeListener.lower(v)
}




public protocol IgnoredUsersListener: AnyObject, Sendable {
    
    func call(ignoredUserIds: [String]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceIgnoredUsersListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceIgnoredUsersListener] = [UniffiVTableCallbackInterfaceIgnoredUsersListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceIgnoredUsersListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface IgnoredUsersListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceIgnoredUsersListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface IgnoredUsersListener: handle missing in uniffiClone")
            }
        },
        call: { (
            uniffiHandle: UInt64,
            ignoredUserIds: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceIgnoredUsersListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     ignoredUserIds: try FfiConverterSequenceString.lift(ignoredUserIds)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitIgnoredUsersListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_ignoreduserslistener(UniffiCallbackInterfaceIgnoredUsersListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceIgnoredUsersListener {
    fileprivate static let handleMap = UniffiHandleMap<IgnoredUsersListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceIgnoredUsersListener : FfiConverter {
    typealias SwiftType = IgnoredUsersListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceIgnoredUsersListener_lift(_ handle: UInt64) throws -> IgnoredUsersListener {
    return try FfiConverterCallbackInterfaceIgnoredUsersListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceIgnoredUsersListener_lower(_ v: IgnoredUsersListener) -> UInt64 {
    return FfiConverterCallbackInterfaceIgnoredUsersListener.lower(v)
}




/**
 * A listener for receiving new requests to a join a room.
 */
public protocol KnockRequestsListener: AnyObject, Sendable {
    
    func call(joinRequests: [KnockRequest]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceKnockRequestsListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceKnockRequestsListener] = [UniffiVTableCallbackInterfaceKnockRequestsListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceKnockRequestsListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface KnockRequestsListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceKnockRequestsListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface KnockRequestsListener: handle missing in uniffiClone")
            }
        },
        call: { (
            uniffiHandle: UInt64,
            joinRequests: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceKnockRequestsListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     joinRequests: try FfiConverterSequenceTypeKnockRequest.lift(joinRequests)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitKnockRequestsListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_knockrequestslistener(UniffiCallbackInterfaceKnockRequestsListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceKnockRequestsListener {
    fileprivate static let handleMap = UniffiHandleMap<KnockRequestsListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceKnockRequestsListener : FfiConverter {
    typealias SwiftType = KnockRequestsListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceKnockRequestsListener_lift(_ handle: UInt64) throws -> KnockRequestsListener {
    return try FfiConverterCallbackInterfaceKnockRequestsListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceKnockRequestsListener_lower(_ v: KnockRequestsListener) -> UInt64 {
    return FfiConverterCallbackInterfaceKnockRequestsListener.lower(v)
}




/**
 * A listener for receiving new live location shares in a room.
 */
public protocol LiveLocationShareListener: AnyObject, Sendable {
    
    func call(liveLocationShares: [LiveLocationShare]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceLiveLocationShareListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceLiveLocationShareListener] = [UniffiVTableCallbackInterfaceLiveLocationShareListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceLiveLocationShareListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface LiveLocationShareListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceLiveLocationShareListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface LiveLocationShareListener: handle missing in uniffiClone")
            }
        },
        call: { (
            uniffiHandle: UInt64,
            liveLocationShares: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceLiveLocationShareListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     liveLocationShares: try FfiConverterSequenceTypeLiveLocationShare.lift(liveLocationShares)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitLiveLocationShareListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_livelocationsharelistener(UniffiCallbackInterfaceLiveLocationShareListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceLiveLocationShareListener {
    fileprivate static let handleMap = UniffiHandleMap<LiveLocationShareListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceLiveLocationShareListener : FfiConverter {
    typealias SwiftType = LiveLocationShareListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLiveLocationShareListener_lift(_ handle: UInt64) throws -> LiveLocationShareListener {
    return try FfiConverterCallbackInterfaceLiveLocationShareListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceLiveLocationShareListener_lower(_ v: LiveLocationShareListener) -> UInt64 {
    return FfiConverterCallbackInterfaceLiveLocationShareListener.lower(v)
}




public protocol MediaPreviewConfigListener: AnyObject, Sendable {
    
    func onChange(mediaPreviewConfig: MediaPreviewConfig?) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceMediaPreviewConfigListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceMediaPreviewConfigListener] = [UniffiVTableCallbackInterfaceMediaPreviewConfigListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceMediaPreviewConfigListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface MediaPreviewConfigListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceMediaPreviewConfigListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface MediaPreviewConfigListener: handle missing in uniffiClone")
            }
        },
        onChange: { (
            uniffiHandle: UInt64,
            mediaPreviewConfig: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceMediaPreviewConfigListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onChange(
                     mediaPreviewConfig: try FfiConverterOptionTypeMediaPreviewConfig.lift(mediaPreviewConfig)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitMediaPreviewConfigListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_mediapreviewconfiglistener(UniffiCallbackInterfaceMediaPreviewConfigListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceMediaPreviewConfigListener {
    fileprivate static let handleMap = UniffiHandleMap<MediaPreviewConfigListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceMediaPreviewConfigListener : FfiConverter {
    typealias SwiftType = MediaPreviewConfigListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceMediaPreviewConfigListener_lift(_ handle: UInt64) throws -> MediaPreviewConfigListener {
    return try FfiConverterCallbackInterfaceMediaPreviewConfigListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceMediaPreviewConfigListener_lower(_ v: MediaPreviewConfigListener) -> UInt64 {
    return FfiConverterCallbackInterfaceMediaPreviewConfigListener.lower(v)
}




/**
 * Delegate to notify of changes in push rules
 */
public protocol NotificationSettingsDelegate: AnyObject, Sendable {
    
    func settingsDidChange() 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceNotificationSettingsDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceNotificationSettingsDelegate] = [UniffiVTableCallbackInterfaceNotificationSettingsDelegate(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceNotificationSettingsDelegate.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface NotificationSettingsDelegate: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceNotificationSettingsDelegate.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface NotificationSettingsDelegate: handle missing in uniffiClone")
            }
        },
        settingsDidChange: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceNotificationSettingsDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.settingsDidChange(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitNotificationSettingsDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_notificationsettingsdelegate(UniffiCallbackInterfaceNotificationSettingsDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceNotificationSettingsDelegate {
    fileprivate static let handleMap = UniffiHandleMap<NotificationSettingsDelegate>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceNotificationSettingsDelegate : FfiConverter {
    typealias SwiftType = NotificationSettingsDelegate
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceNotificationSettingsDelegate_lift(_ handle: UInt64) throws -> NotificationSettingsDelegate {
    return try FfiConverterCallbackInterfaceNotificationSettingsDelegate.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceNotificationSettingsDelegate_lower(_ v: NotificationSettingsDelegate) -> UInt64 {
    return FfiConverterCallbackInterfaceNotificationSettingsDelegate.lower(v)
}




public protocol PaginationStatusListener: AnyObject, Sendable {
    
    func onUpdate(status: RoomPaginationStatus) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfacePaginationStatusListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfacePaginationStatusListener] = [UniffiVTableCallbackInterfacePaginationStatusListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfacePaginationStatusListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface PaginationStatusListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfacePaginationStatusListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface PaginationStatusListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfacePaginationStatusListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeRoomPaginationStatus_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitPaginationStatusListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_paginationstatuslistener(UniffiCallbackInterfacePaginationStatusListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfacePaginationStatusListener {
    fileprivate static let handleMap = UniffiHandleMap<PaginationStatusListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfacePaginationStatusListener : FfiConverter {
    typealias SwiftType = PaginationStatusListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePaginationStatusListener_lift(_ handle: UInt64) throws -> PaginationStatusListener {
    return try FfiConverterCallbackInterfacePaginationStatusListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfacePaginationStatusListener_lower(_ v: PaginationStatusListener) -> UInt64 {
    return FfiConverterCallbackInterfacePaginationStatusListener.lower(v)
}




public protocol ProgressWatcher: AnyObject, Sendable {
    
    func transmissionProgress(progress: TransmissionProgress) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceProgressWatcher {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceProgressWatcher] = [UniffiVTableCallbackInterfaceProgressWatcher(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceProgressWatcher.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface ProgressWatcher: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceProgressWatcher.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface ProgressWatcher: handle missing in uniffiClone")
            }
        },
        transmissionProgress: { (
            uniffiHandle: UInt64,
            progress: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceProgressWatcher.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.transmissionProgress(
                     progress: try FfiConverterTypeTransmissionProgress_lift(progress)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitProgressWatcher() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_progresswatcher(UniffiCallbackInterfaceProgressWatcher.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceProgressWatcher {
    fileprivate static let handleMap = UniffiHandleMap<ProgressWatcher>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceProgressWatcher : FfiConverter {
    typealias SwiftType = ProgressWatcher
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceProgressWatcher_lift(_ handle: UInt64) throws -> ProgressWatcher {
    return try FfiConverterCallbackInterfaceProgressWatcher.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceProgressWatcher_lower(_ v: ProgressWatcher) -> UInt64 {
    return FfiConverterCallbackInterfaceProgressWatcher.lower(v)
}




public protocol QrLoginProgressListener: AnyObject, Sendable {
    
    func onUpdate(state: QrLoginProgress) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceQrLoginProgressListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceQrLoginProgressListener] = [UniffiVTableCallbackInterfaceQrLoginProgressListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceQrLoginProgressListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface QrLoginProgressListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceQrLoginProgressListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface QrLoginProgressListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceQrLoginProgressListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeQrLoginProgress_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitQrLoginProgressListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_qrloginprogresslistener(UniffiCallbackInterfaceQrLoginProgressListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceQrLoginProgressListener {
    fileprivate static let handleMap = UniffiHandleMap<QrLoginProgressListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceQrLoginProgressListener : FfiConverter {
    typealias SwiftType = QrLoginProgressListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceQrLoginProgressListener_lift(_ handle: UInt64) throws -> QrLoginProgressListener {
    return try FfiConverterCallbackInterfaceQrLoginProgressListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceQrLoginProgressListener_lower(_ v: QrLoginProgressListener) -> UInt64 {
    return FfiConverterCallbackInterfaceQrLoginProgressListener.lower(v)
}




public protocol RecoveryStateListener: AnyObject, Sendable {
    
    func onUpdate(status: RecoveryState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRecoveryStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRecoveryStateListener] = [UniffiVTableCallbackInterfaceRecoveryStateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRecoveryStateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RecoveryStateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRecoveryStateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RecoveryStateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRecoveryStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeRecoveryState_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRecoveryStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_recoverystatelistener(UniffiCallbackInterfaceRecoveryStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRecoveryStateListener {
    fileprivate static let handleMap = UniffiHandleMap<RecoveryStateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRecoveryStateListener : FfiConverter {
    typealias SwiftType = RecoveryStateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRecoveryStateListener_lift(_ handle: UInt64) throws -> RecoveryStateListener {
    return try FfiConverterCallbackInterfaceRecoveryStateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRecoveryStateListener_lower(_ v: RecoveryStateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRecoveryStateListener.lower(v)
}




/**
 * A listener for changes of room account data events.
 */
public protocol RoomAccountDataListener: AnyObject, Sendable {
    
    /**
     * Called when a room account data event was changed.
     */
    func onChange(event: RoomAccountDataEvent, roomId: String) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomAccountDataListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRoomAccountDataListener] = [UniffiVTableCallbackInterfaceRoomAccountDataListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRoomAccountDataListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RoomAccountDataListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRoomAccountDataListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RoomAccountDataListener: handle missing in uniffiClone")
            }
        },
        onChange: { (
            uniffiHandle: UInt64,
            event: RustBuffer,
            roomId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomAccountDataListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onChange(
                     event: try FfiConverterTypeRoomAccountDataEvent_lift(event),
                     roomId: try FfiConverterString.lift(roomId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRoomAccountDataListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomaccountdatalistener(UniffiCallbackInterfaceRoomAccountDataListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRoomAccountDataListener {
    fileprivate static let handleMap = UniffiHandleMap<RoomAccountDataListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRoomAccountDataListener : FfiConverter {
    typealias SwiftType = RoomAccountDataListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomAccountDataListener_lift(_ handle: UInt64) throws -> RoomAccountDataListener {
    return try FfiConverterCallbackInterfaceRoomAccountDataListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomAccountDataListener_lower(_ v: RoomAccountDataListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRoomAccountDataListener.lower(v)
}




public protocol RoomDirectorySearchEntriesListener: AnyObject, Sendable {
    
    func onUpdate(roomEntriesUpdate: [RoomDirectorySearchEntryUpdate]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomDirectorySearchEntriesListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener] = [UniffiVTableCallbackInterfaceRoomDirectorySearchEntriesListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RoomDirectorySearchEntriesListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RoomDirectorySearchEntriesListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            roomEntriesUpdate: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     roomEntriesUpdate: try FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate.lift(roomEntriesUpdate)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRoomDirectorySearchEntriesListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomdirectorysearchentrieslistener(UniffiCallbackInterfaceRoomDirectorySearchEntriesListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener {
    fileprivate static let handleMap = UniffiHandleMap<RoomDirectorySearchEntriesListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener : FfiConverter {
    typealias SwiftType = RoomDirectorySearchEntriesListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener_lift(_ handle: UInt64) throws -> RoomDirectorySearchEntriesListener {
    return try FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener_lower(_ v: RoomDirectorySearchEntriesListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRoomDirectorySearchEntriesListener.lower(v)
}




public protocol RoomInfoListener: AnyObject, Sendable {
    
    func call(roomInfo: RoomInfo) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomInfoListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRoomInfoListener] = [UniffiVTableCallbackInterfaceRoomInfoListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRoomInfoListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RoomInfoListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRoomInfoListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RoomInfoListener: handle missing in uniffiClone")
            }
        },
        call: { (
            uniffiHandle: UInt64,
            roomInfo: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomInfoListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     roomInfo: try FfiConverterTypeRoomInfo_lift(roomInfo)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRoomInfoListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roominfolistener(UniffiCallbackInterfaceRoomInfoListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRoomInfoListener {
    fileprivate static let handleMap = UniffiHandleMap<RoomInfoListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRoomInfoListener : FfiConverter {
    typealias SwiftType = RoomInfoListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomInfoListener_lift(_ handle: UInt64) throws -> RoomInfoListener {
    return try FfiConverterCallbackInterfaceRoomInfoListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomInfoListener_lower(_ v: RoomInfoListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRoomInfoListener.lower(v)
}




public protocol RoomListEntriesListener: AnyObject, Sendable {
    
    func onUpdate(roomEntriesUpdate: [RoomListEntriesUpdate]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListEntriesListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRoomListEntriesListener] = [UniffiVTableCallbackInterfaceRoomListEntriesListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRoomListEntriesListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RoomListEntriesListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRoomListEntriesListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RoomListEntriesListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            roomEntriesUpdate: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListEntriesListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     roomEntriesUpdate: try FfiConverterSequenceTypeRoomListEntriesUpdate.lift(roomEntriesUpdate)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRoomListEntriesListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistentrieslistener(UniffiCallbackInterfaceRoomListEntriesListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRoomListEntriesListener {
    fileprivate static let handleMap = UniffiHandleMap<RoomListEntriesListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRoomListEntriesListener : FfiConverter {
    typealias SwiftType = RoomListEntriesListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListEntriesListener_lift(_ handle: UInt64) throws -> RoomListEntriesListener {
    return try FfiConverterCallbackInterfaceRoomListEntriesListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListEntriesListener_lower(_ v: RoomListEntriesListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRoomListEntriesListener.lower(v)
}




public protocol RoomListLoadingStateListener: AnyObject, Sendable {
    
    func onUpdate(state: RoomListLoadingState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListLoadingStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRoomListLoadingStateListener] = [UniffiVTableCallbackInterfaceRoomListLoadingStateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRoomListLoadingStateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RoomListLoadingStateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRoomListLoadingStateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RoomListLoadingStateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListLoadingStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeRoomListLoadingState_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRoomListLoadingStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistloadingstatelistener(UniffiCallbackInterfaceRoomListLoadingStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRoomListLoadingStateListener {
    fileprivate static let handleMap = UniffiHandleMap<RoomListLoadingStateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRoomListLoadingStateListener : FfiConverter {
    typealias SwiftType = RoomListLoadingStateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListLoadingStateListener_lift(_ handle: UInt64) throws -> RoomListLoadingStateListener {
    return try FfiConverterCallbackInterfaceRoomListLoadingStateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListLoadingStateListener_lower(_ v: RoomListLoadingStateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRoomListLoadingStateListener.lower(v)
}




public protocol RoomListServiceStateListener: AnyObject, Sendable {
    
    func onUpdate(state: RoomListServiceState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListServiceStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRoomListServiceStateListener] = [UniffiVTableCallbackInterfaceRoomListServiceStateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRoomListServiceStateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RoomListServiceStateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRoomListServiceStateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RoomListServiceStateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListServiceStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeRoomListServiceState_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRoomListServiceStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicestatelistener(UniffiCallbackInterfaceRoomListServiceStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRoomListServiceStateListener {
    fileprivate static let handleMap = UniffiHandleMap<RoomListServiceStateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRoomListServiceStateListener : FfiConverter {
    typealias SwiftType = RoomListServiceStateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListServiceStateListener_lift(_ handle: UInt64) throws -> RoomListServiceStateListener {
    return try FfiConverterCallbackInterfaceRoomListServiceStateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListServiceStateListener_lower(_ v: RoomListServiceStateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRoomListServiceStateListener.lower(v)
}




public protocol RoomListServiceSyncIndicatorListener: AnyObject, Sendable {
    
    func onUpdate(syncIndicator: RoomListServiceSyncIndicator) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceRoomListServiceSyncIndicatorListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener] = [UniffiVTableCallbackInterfaceRoomListServiceSyncIndicatorListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface RoomListServiceSyncIndicatorListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface RoomListServiceSyncIndicatorListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            syncIndicator: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     syncIndicator: try FfiConverterTypeRoomListServiceSyncIndicator_lift(syncIndicator)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitRoomListServiceSyncIndicatorListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_roomlistservicesyncindicatorlistener(UniffiCallbackInterfaceRoomListServiceSyncIndicatorListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener {
    fileprivate static let handleMap = UniffiHandleMap<RoomListServiceSyncIndicatorListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener : FfiConverter {
    typealias SwiftType = RoomListServiceSyncIndicatorListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener_lift(_ handle: UInt64) throws -> RoomListServiceSyncIndicatorListener {
    return try FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener_lower(_ v: RoomListServiceSyncIndicatorListener) -> UInt64 {
    return FfiConverterCallbackInterfaceRoomListServiceSyncIndicatorListener.lower(v)
}




/**
 * A listener to send queue updates in a specific room.
 */
public protocol SendQueueListener: AnyObject, Sendable {
    
    /**
     * Called every time the send queue dispatches an update for the given
     * room.
     */
    func onUpdate(update: RoomSendQueueUpdate) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSendQueueListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSendQueueListener] = [UniffiVTableCallbackInterfaceSendQueueListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSendQueueListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SendQueueListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSendQueueListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SendQueueListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            update: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSendQueueListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     update: try FfiConverterTypeRoomSendQueueUpdate_lift(update)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSendQueueListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueuelistener(UniffiCallbackInterfaceSendQueueListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSendQueueListener {
    fileprivate static let handleMap = UniffiHandleMap<SendQueueListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSendQueueListener : FfiConverter {
    typealias SwiftType = SendQueueListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendQueueListener_lift(_ handle: UInt64) throws -> SendQueueListener {
    return try FfiConverterCallbackInterfaceSendQueueListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendQueueListener_lower(_ v: SendQueueListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSendQueueListener.lower(v)
}




/**
 * A listener to the global (client-wide) error reporter of the send queue.
 */
public protocol SendQueueRoomErrorListener: AnyObject, Sendable {
    
    /**
     * Called every time the send queue has ran into an error for a given room,
     * which will disable the send queue for that particular room.
     */
    func onError(roomId: String, error: ClientError) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSendQueueRoomErrorListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSendQueueRoomErrorListener] = [UniffiVTableCallbackInterfaceSendQueueRoomErrorListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSendQueueRoomErrorListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SendQueueRoomErrorListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSendQueueRoomErrorListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SendQueueRoomErrorListener: handle missing in uniffiClone")
            }
        },
        onError: { (
            uniffiHandle: UInt64,
            roomId: RustBuffer,
            error: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSendQueueRoomErrorListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onError(
                     roomId: try FfiConverterString.lift(roomId),
                     error: try FfiConverterTypeClientError_lift(error)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSendQueueRoomErrorListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomerrorlistener(UniffiCallbackInterfaceSendQueueRoomErrorListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSendQueueRoomErrorListener {
    fileprivate static let handleMap = UniffiHandleMap<SendQueueRoomErrorListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSendQueueRoomErrorListener : FfiConverter {
    typealias SwiftType = SendQueueRoomErrorListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendQueueRoomErrorListener_lift(_ handle: UInt64) throws -> SendQueueRoomErrorListener {
    return try FfiConverterCallbackInterfaceSendQueueRoomErrorListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendQueueRoomErrorListener_lower(_ v: SendQueueRoomErrorListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSendQueueRoomErrorListener.lower(v)
}




/**
 * A listener to the global (client-wide) update reporter of the send queue.
 */
public protocol SendQueueRoomUpdateListener: AnyObject, Sendable {
    
    /**
     * Called every time the send queue emits an update for a given room.
     */
    func onUpdate(roomId: String, update: RoomSendQueueUpdate) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSendQueueRoomUpdateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSendQueueRoomUpdateListener] = [UniffiVTableCallbackInterfaceSendQueueRoomUpdateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSendQueueRoomUpdateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SendQueueRoomUpdateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSendQueueRoomUpdateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SendQueueRoomUpdateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            roomId: RustBuffer,
            update: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSendQueueRoomUpdateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     roomId: try FfiConverterString.lift(roomId),
                     update: try FfiConverterTypeRoomSendQueueUpdate_lift(update)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSendQueueRoomUpdateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sendqueueroomupdatelistener(UniffiCallbackInterfaceSendQueueRoomUpdateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSendQueueRoomUpdateListener {
    fileprivate static let handleMap = UniffiHandleMap<SendQueueRoomUpdateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSendQueueRoomUpdateListener : FfiConverter {
    typealias SwiftType = SendQueueRoomUpdateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendQueueRoomUpdateListener_lift(_ handle: UInt64) throws -> SendQueueRoomUpdateListener {
    return try FfiConverterCallbackInterfaceSendQueueRoomUpdateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSendQueueRoomUpdateListener_lower(_ v: SendQueueRoomUpdateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSendQueueRoomUpdateListener.lower(v)
}




public protocol SessionVerificationControllerDelegate: AnyObject, Sendable {
    
    func didReceiveVerificationRequest(details: SessionVerificationRequestDetails) 
    
    func didAcceptVerificationRequest() 
    
    func didStartSasVerification() 
    
    func didReceiveVerificationData(data: SessionVerificationData) 
    
    func didFail() 
    
    func didCancel() 
    
    func didFinish() 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSessionVerificationControllerDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate] = [UniffiVTableCallbackInterfaceSessionVerificationControllerDelegate(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SessionVerificationControllerDelegate: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SessionVerificationControllerDelegate: handle missing in uniffiClone")
            }
        },
        didReceiveVerificationRequest: { (
            uniffiHandle: UInt64,
            details: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didReceiveVerificationRequest(
                     details: try FfiConverterTypeSessionVerificationRequestDetails_lift(details)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didAcceptVerificationRequest: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didAcceptVerificationRequest(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didStartSasVerification: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didStartSasVerification(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didReceiveVerificationData: { (
            uniffiHandle: UInt64,
            data: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didReceiveVerificationData(
                     data: try FfiConverterTypeSessionVerificationData_lift(data)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didFail: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didFail(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didCancel: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didCancel(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        },
        didFinish: { (
            uniffiHandle: UInt64,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.didFinish(
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSessionVerificationControllerDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_sessionverificationcontrollerdelegate(UniffiCallbackInterfaceSessionVerificationControllerDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSessionVerificationControllerDelegate {
    fileprivate static let handleMap = UniffiHandleMap<SessionVerificationControllerDelegate>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSessionVerificationControllerDelegate : FfiConverter {
    typealias SwiftType = SessionVerificationControllerDelegate
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSessionVerificationControllerDelegate_lift(_ handle: UInt64) throws -> SessionVerificationControllerDelegate {
    return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSessionVerificationControllerDelegate_lower(_ v: SessionVerificationControllerDelegate) -> UInt64 {
    return FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.lower(v)
}




public protocol SpaceRoomListEntriesListener: AnyObject, Sendable {
    
    func onUpdate(rooms: [SpaceListUpdate]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSpaceRoomListEntriesListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSpaceRoomListEntriesListener] = [UniffiVTableCallbackInterfaceSpaceRoomListEntriesListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSpaceRoomListEntriesListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SpaceRoomListEntriesListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSpaceRoomListEntriesListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SpaceRoomListEntriesListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            rooms: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSpaceRoomListEntriesListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     rooms: try FfiConverterSequenceTypeSpaceListUpdate.lift(rooms)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSpaceRoomListEntriesListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistentrieslistener(UniffiCallbackInterfaceSpaceRoomListEntriesListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSpaceRoomListEntriesListener {
    fileprivate static let handleMap = UniffiHandleMap<SpaceRoomListEntriesListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSpaceRoomListEntriesListener : FfiConverter {
    typealias SwiftType = SpaceRoomListEntriesListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceRoomListEntriesListener_lift(_ handle: UInt64) throws -> SpaceRoomListEntriesListener {
    return try FfiConverterCallbackInterfaceSpaceRoomListEntriesListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceRoomListEntriesListener_lower(_ v: SpaceRoomListEntriesListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSpaceRoomListEntriesListener.lower(v)
}




public protocol SpaceRoomListPaginationStateListener: AnyObject, Sendable {
    
    func onUpdate(paginationState: SpaceRoomListPaginationState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSpaceRoomListPaginationStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSpaceRoomListPaginationStateListener] = [UniffiVTableCallbackInterfaceSpaceRoomListPaginationStateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SpaceRoomListPaginationStateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SpaceRoomListPaginationStateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            paginationState: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     paginationState: try FfiConverterTypeSpaceRoomListPaginationState_lift(paginationState)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSpaceRoomListPaginationStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistpaginationstatelistener(UniffiCallbackInterfaceSpaceRoomListPaginationStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener {
    fileprivate static let handleMap = UniffiHandleMap<SpaceRoomListPaginationStateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener : FfiConverter {
    typealias SwiftType = SpaceRoomListPaginationStateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener_lift(_ handle: UInt64) throws -> SpaceRoomListPaginationStateListener {
    return try FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener_lower(_ v: SpaceRoomListPaginationStateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSpaceRoomListPaginationStateListener.lower(v)
}




public protocol SpaceRoomListSpaceListener: AnyObject, Sendable {
    
    func onUpdate(space: SpaceRoom?) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSpaceRoomListSpaceListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSpaceRoomListSpaceListener] = [UniffiVTableCallbackInterfaceSpaceRoomListSpaceListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSpaceRoomListSpaceListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SpaceRoomListSpaceListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSpaceRoomListSpaceListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SpaceRoomListSpaceListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            space: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSpaceRoomListSpaceListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     space: try FfiConverterOptionTypeSpaceRoom.lift(space)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSpaceRoomListSpaceListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceroomlistspacelistener(UniffiCallbackInterfaceSpaceRoomListSpaceListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSpaceRoomListSpaceListener {
    fileprivate static let handleMap = UniffiHandleMap<SpaceRoomListSpaceListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSpaceRoomListSpaceListener : FfiConverter {
    typealias SwiftType = SpaceRoomListSpaceListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceRoomListSpaceListener_lift(_ handle: UInt64) throws -> SpaceRoomListSpaceListener {
    return try FfiConverterCallbackInterfaceSpaceRoomListSpaceListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceRoomListSpaceListener_lower(_ v: SpaceRoomListSpaceListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSpaceRoomListSpaceListener.lower(v)
}




public protocol SpaceServiceJoinedSpacesListener: AnyObject, Sendable {
    
    func onUpdate(roomUpdates: [SpaceListUpdate]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSpaceServiceJoinedSpacesListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSpaceServiceJoinedSpacesListener] = [UniffiVTableCallbackInterfaceSpaceServiceJoinedSpacesListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SpaceServiceJoinedSpacesListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SpaceServiceJoinedSpacesListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            roomUpdates: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     roomUpdates: try FfiConverterSequenceTypeSpaceListUpdate.lift(roomUpdates)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSpaceServiceJoinedSpacesListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_spaceservicejoinedspaceslistener(UniffiCallbackInterfaceSpaceServiceJoinedSpacesListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener {
    fileprivate static let handleMap = UniffiHandleMap<SpaceServiceJoinedSpacesListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener : FfiConverter {
    typealias SwiftType = SpaceServiceJoinedSpacesListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener_lift(_ handle: UInt64) throws -> SpaceServiceJoinedSpacesListener {
    return try FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener_lower(_ v: SpaceServiceJoinedSpacesListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSpaceServiceJoinedSpacesListener.lower(v)
}




/**
 * A listener for notifications generated from sync responses.
 *
 * This is called during sync for each event that triggers a notification
 * based on the user's push rules.
 */
public protocol SyncNotificationListener: AnyObject, Sendable {
    
    /**
     * Called when a notifying event is received during sync.
     */
    func onNotification(notification: NotificationItem, roomId: String) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncNotificationListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSyncNotificationListener] = [UniffiVTableCallbackInterfaceSyncNotificationListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSyncNotificationListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SyncNotificationListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSyncNotificationListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SyncNotificationListener: handle missing in uniffiClone")
            }
        },
        onNotification: { (
            uniffiHandle: UInt64,
            notification: RustBuffer,
            roomId: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSyncNotificationListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onNotification(
                     notification: try FfiConverterTypeNotificationItem_lift(notification),
                     roomId: try FfiConverterString.lift(roomId)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSyncNotificationListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncnotificationlistener(UniffiCallbackInterfaceSyncNotificationListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSyncNotificationListener {
    fileprivate static let handleMap = UniffiHandleMap<SyncNotificationListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSyncNotificationListener : FfiConverter {
    typealias SwiftType = SyncNotificationListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncNotificationListener_lift(_ handle: UInt64) throws -> SyncNotificationListener {
    return try FfiConverterCallbackInterfaceSyncNotificationListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncNotificationListener_lower(_ v: SyncNotificationListener) -> UInt64 {
    return FfiConverterCallbackInterfaceSyncNotificationListener.lower(v)
}




public protocol SyncServiceStateObserver: AnyObject, Sendable {
    
    func onUpdate(state: SyncServiceState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceSyncServiceStateObserver {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceSyncServiceStateObserver] = [UniffiVTableCallbackInterfaceSyncServiceStateObserver(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceSyncServiceStateObserver.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface SyncServiceStateObserver: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceSyncServiceStateObserver.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface SyncServiceStateObserver: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            state: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceSyncServiceStateObserver.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     state: try FfiConverterTypeSyncServiceState_lift(state)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitSyncServiceStateObserver() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_syncservicestateobserver(UniffiCallbackInterfaceSyncServiceStateObserver.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceSyncServiceStateObserver {
    fileprivate static let handleMap = UniffiHandleMap<SyncServiceStateObserver>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceSyncServiceStateObserver : FfiConverter {
    typealias SwiftType = SyncServiceStateObserver
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncServiceStateObserver_lift(_ handle: UInt64) throws -> SyncServiceStateObserver {
    return try FfiConverterCallbackInterfaceSyncServiceStateObserver.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceSyncServiceStateObserver_lower(_ v: SyncServiceStateObserver) -> UInt64 {
    return FfiConverterCallbackInterfaceSyncServiceStateObserver.lower(v)
}




public protocol TimelineListener: AnyObject, Sendable {
    
    func onUpdate(diff: [TimelineDiff]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceTimelineListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceTimelineListener] = [UniffiVTableCallbackInterfaceTimelineListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceTimelineListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface TimelineListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceTimelineListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface TimelineListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            diff: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTimelineListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     diff: try FfiConverterSequenceTypeTimelineDiff.lift(diff)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitTimelineListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_timelinelistener(UniffiCallbackInterfaceTimelineListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceTimelineListener {
    fileprivate static let handleMap = UniffiHandleMap<TimelineListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceTimelineListener : FfiConverter {
    typealias SwiftType = TimelineListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTimelineListener_lift(_ handle: UInt64) throws -> TimelineListener {
    return try FfiConverterCallbackInterfaceTimelineListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTimelineListener_lower(_ v: TimelineListener) -> UInt64 {
    return FfiConverterCallbackInterfaceTimelineListener.lower(v)
}




public protocol TypingNotificationsListener: AnyObject, Sendable {
    
    func call(typingUserIds: [String]) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceTypingNotificationsListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceTypingNotificationsListener] = [UniffiVTableCallbackInterfaceTypingNotificationsListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceTypingNotificationsListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface TypingNotificationsListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceTypingNotificationsListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface TypingNotificationsListener: handle missing in uniffiClone")
            }
        },
        call: { (
            uniffiHandle: UInt64,
            typingUserIds: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceTypingNotificationsListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.call(
                     typingUserIds: try FfiConverterSequenceString.lift(typingUserIds)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitTypingNotificationsListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_typingnotificationslistener(UniffiCallbackInterfaceTypingNotificationsListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceTypingNotificationsListener {
    fileprivate static let handleMap = UniffiHandleMap<TypingNotificationsListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceTypingNotificationsListener : FfiConverter {
    typealias SwiftType = TypingNotificationsListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTypingNotificationsListener_lift(_ handle: UInt64) throws -> TypingNotificationsListener {
    return try FfiConverterCallbackInterfaceTypingNotificationsListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceTypingNotificationsListener_lower(_ v: TypingNotificationsListener) -> UInt64 {
    return FfiConverterCallbackInterfaceTypingNotificationsListener.lower(v)
}




public protocol UnableToDecryptDelegate: AnyObject, Sendable {
    
    func onUtd(info: UnableToDecryptInfo) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceUnableToDecryptDelegate {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceUnableToDecryptDelegate] = [UniffiVTableCallbackInterfaceUnableToDecryptDelegate(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceUnableToDecryptDelegate.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface UnableToDecryptDelegate: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceUnableToDecryptDelegate.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface UnableToDecryptDelegate: handle missing in uniffiClone")
            }
        },
        onUtd: { (
            uniffiHandle: UInt64,
            info: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceUnableToDecryptDelegate.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUtd(
                     info: try FfiConverterTypeUnableToDecryptInfo_lift(info)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitUnableToDecryptDelegate() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_unabletodecryptdelegate(UniffiCallbackInterfaceUnableToDecryptDelegate.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceUnableToDecryptDelegate {
    fileprivate static let handleMap = UniffiHandleMap<UnableToDecryptDelegate>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceUnableToDecryptDelegate : FfiConverter {
    typealias SwiftType = UnableToDecryptDelegate
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceUnableToDecryptDelegate_lift(_ handle: UInt64) throws -> UnableToDecryptDelegate {
    return try FfiConverterCallbackInterfaceUnableToDecryptDelegate.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceUnableToDecryptDelegate_lower(_ v: UnableToDecryptDelegate) -> UInt64 {
    return FfiConverterCallbackInterfaceUnableToDecryptDelegate.lower(v)
}




public protocol VerificationStateListener: AnyObject, Sendable {
    
    func onUpdate(status: VerificationState) 
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceVerificationStateListener {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceVerificationStateListener] = [UniffiVTableCallbackInterfaceVerificationStateListener(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceVerificationStateListener.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface VerificationStateListener: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceVerificationStateListener.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface VerificationStateListener: handle missing in uniffiClone")
            }
        },
        onUpdate: { (
            uniffiHandle: UInt64,
            status: RustBuffer,
            uniffiOutReturn: UnsafeMutableRawPointer,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> () in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceVerificationStateListener.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.onUpdate(
                     status: try FfiConverterTypeVerificationState_lift(status)
                )
            }

            
            let writeReturn = { () }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitVerificationStateListener() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_verificationstatelistener(UniffiCallbackInterfaceVerificationStateListener.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceVerificationStateListener {
    fileprivate static let handleMap = UniffiHandleMap<VerificationStateListener>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceVerificationStateListener : FfiConverter {
    typealias SwiftType = VerificationStateListener
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceVerificationStateListener_lift(_ handle: UInt64) throws -> VerificationStateListener {
    return try FfiConverterCallbackInterfaceVerificationStateListener.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceVerificationStateListener_lower(_ v: VerificationStateListener) -> UInt64 {
    return FfiConverterCallbackInterfaceVerificationStateListener.lower(v)
}




public protocol WidgetCapabilitiesProvider: AnyObject, Sendable {
    
    func acquireCapabilities(capabilities: WidgetCapabilities)  -> WidgetCapabilities
    
}


// Put the implementation in a struct so we don't pollute the top-level namespace
fileprivate struct UniffiCallbackInterfaceWidgetCapabilitiesProvider {

    // Create the VTable using a series of closures.
    // Swift automatically converts these into C callback functions.
    //
    // This creates 1-element array, since this seems to be the only way to construct a const
    // pointer that we can pass to the Rust code.
    static let vtable: [UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider] = [UniffiVTableCallbackInterfaceWidgetCapabilitiesProvider(
        uniffiFree: { (uniffiHandle: UInt64) -> () in
            do {
                try FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.handleMap.remove(handle: uniffiHandle)
            } catch {
                print("Uniffi callback interface WidgetCapabilitiesProvider: handle missing in uniffiFree")
            }
        },
        uniffiClone: { (uniffiHandle: UInt64) -> UInt64 in
            do {
                return try FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.handleMap.clone(handle: uniffiHandle)
            } catch {
                fatalError("Uniffi callback interface WidgetCapabilitiesProvider: handle missing in uniffiClone")
            }
        },
        acquireCapabilities: { (
            uniffiHandle: UInt64,
            capabilities: RustBuffer,
            uniffiOutReturn: UnsafeMutablePointer<RustBuffer>,
            uniffiCallStatus: UnsafeMutablePointer<RustCallStatus>
        ) in
            let makeCall = {
                () throws -> WidgetCapabilities in
                guard let uniffiObj = try? FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.handleMap.get(handle: uniffiHandle) else {
                    throw UniffiInternalError.unexpectedStaleHandle
                }
                return uniffiObj.acquireCapabilities(
                     capabilities: try FfiConverterTypeWidgetCapabilities_lift(capabilities)
                )
            }

            
            let writeReturn = { uniffiOutReturn.pointee = FfiConverterTypeWidgetCapabilities_lower($0) }
            uniffiTraitInterfaceCall(
                callStatus: uniffiCallStatus,
                makeCall: makeCall,
                writeReturn: writeReturn
            )
        }
    )]
}

private func uniffiCallbackInitWidgetCapabilitiesProvider() {
    uniffi_matrix_sdk_ffi_fn_init_callback_vtable_widgetcapabilitiesprovider(UniffiCallbackInterfaceWidgetCapabilitiesProvider.vtable)
}

// FfiConverter protocol for callback interfaces
#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterCallbackInterfaceWidgetCapabilitiesProvider {
    fileprivate static let handleMap = UniffiHandleMap<WidgetCapabilitiesProvider>()
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
extension FfiConverterCallbackInterfaceWidgetCapabilitiesProvider : FfiConverter {
    typealias SwiftType = WidgetCapabilitiesProvider
    typealias FfiType = UInt64

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lift(_ handle: UInt64) throws -> SwiftType {
        try handleMap.get(handle: handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        let handle: UInt64 = try readInt(&buf)
        return try lift(handle)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func lower(_ v: SwiftType) -> UInt64 {
        return handleMap.insert(obj: v)
    }

#if swift(>=5.8)
    @_documentation(visibility: private)
#endif
    public static func write(_ v: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(v))
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceWidgetCapabilitiesProvider_lift(_ handle: UInt64) throws -> WidgetCapabilitiesProvider {
    return try FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.lift(handle)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterCallbackInterfaceWidgetCapabilitiesProvider_lower(_ v: WidgetCapabilitiesProvider) -> UInt64 {
    return FfiConverterCallbackInterfaceWidgetCapabilitiesProvider.lower(v)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt8: FfiConverterRustBuffer {
    typealias SwiftType = UInt8?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt8.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt8.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt16: FfiConverterRustBuffer {
    typealias SwiftType = UInt16?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt16.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt16.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionInt32: FfiConverterRustBuffer {
    typealias SwiftType = Int32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionUInt64: FfiConverterRustBuffer {
    typealias SwiftType = UInt64?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDouble: FfiConverterRustBuffer {
    typealias SwiftType = Double?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDouble.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDouble.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDuration: FfiConverterRustBuffer {
    typealias SwiftType = TimeInterval?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDuration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDuration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeIdentityResetHandle: FfiConverterRustBuffer {
    typealias SwiftType = IdentityResetHandle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentityResetHandle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentityResetHandle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeInReplyToDetails: FfiConverterRustBuffer {
    typealias SwiftType = InReplyToDetails?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInReplyToDetails.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInReplyToDetails.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMediaSource: FfiConverterRustBuffer {
    typealias SwiftType = MediaSource?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaSource.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaSource.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = Room?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoomMessageEventContentWithoutRelation: FfiConverterRustBuffer {
    typealias SwiftType = RoomMessageEventContentWithoutRelation?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMessageEventContentWithoutRelation.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMessageEventContentWithoutRelation.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoomPowerLevels: FfiConverterRustBuffer {
    typealias SwiftType = RoomPowerLevels?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomPowerLevels.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomPowerLevels.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSendHandle: FfiConverterRustBuffer {
    typealias SwiftType = SendHandle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSendHandle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSendHandle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSyncService: FfiConverterRustBuffer {
    typealias SwiftType = SyncService?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSyncService.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSyncService.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTaskHandle: FfiConverterRustBuffer {
    typealias SwiftType = TaskHandle?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTaskHandle.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTaskHandle.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeThreadSummary: FfiConverterRustBuffer {
    typealias SwiftType = ThreadSummary?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThreadSummary.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThreadSummary.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUserIdentity: FfiConverterRustBuffer {
    typealias SwiftType = UserIdentity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUserIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUserIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAudioInfo: FfiConverterRustBuffer {
    typealias SwiftType = AudioInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAudioInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAudioInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeComposerDraft: FfiConverterRustBuffer {
    typealias SwiftType = ComposerDraft?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeComposerDraft.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeComposerDraft.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeEventTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = EventTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFileInfo: FfiConverterRustBuffer {
    typealias SwiftType = FileInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFileInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFileInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeFormattedBody: FfiConverterRustBuffer {
    typealias SwiftType = FormattedBody?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeFormattedBody.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeFormattedBody.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeImageInfo: FfiConverterRustBuffer {
    typealias SwiftType = ImageInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeImageInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeImageInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMatrixEntity: FfiConverterRustBuffer {
    typealias SwiftType = MatrixEntity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMatrixEntity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMatrixEntity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMediaPreviewConfig: FfiConverterRustBuffer {
    typealias SwiftType = MediaPreviewConfig?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaPreviewConfig.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaPreviewConfig.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMediaUploadProgress: FfiConverterRustBuffer {
    typealias SwiftType = MediaUploadProgress?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaUploadProgress.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaUploadProgress.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMentions: FfiConverterRustBuffer {
    typealias SwiftType = Mentions?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMentions.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMentions.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeNotificationPowerLevels: FfiConverterRustBuffer {
    typealias SwiftType = NotificationPowerLevels?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeNotificationPowerLevels.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeNotificationPowerLevels.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePassPhrase: FfiConverterRustBuffer {
    typealias SwiftType = PassPhrase?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePassPhrase.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePassPhrase.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePowerLevels: FfiConverterRustBuffer {
    typealias SwiftType = PowerLevels?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePowerLevels.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePowerLevels.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePredecessorRoom: FfiConverterRustBuffer {
    typealias SwiftType = PredecessorRoom?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePredecessorRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePredecessorRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeResolvedRoomAlias: FfiConverterRustBuffer {
    typealias SwiftType = ResolvedRoomAlias?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeResolvedRoomAlias.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeResolvedRoomAlias.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = RoomMember?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMember.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMember.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoomMemberWithSenderInfo: FfiConverterRustBuffer {
    typealias SwiftType = RoomMemberWithSenderInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomMemberWithSenderInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomMemberWithSenderInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSpaceRoom: FfiConverterRustBuffer {
    typealias SwiftType = SpaceRoom?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSpaceRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSpaceRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeSuccessorRoom: FfiConverterRustBuffer {
    typealias SwiftType = SuccessorRoom?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSuccessorRoom.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSuccessorRoom.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeThreadSubscription: FfiConverterRustBuffer {
    typealias SwiftType = ThreadSubscription?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThreadSubscription.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThreadSubscription.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeThumbnailInfo: FfiConverterRustBuffer {
    typealias SwiftType = ThumbnailInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeThumbnailInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeThumbnailInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTracingFileConfiguration: FfiConverterRustBuffer {
    typealias SwiftType = TracingFileConfiguration?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTracingFileConfiguration.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTracingFileConfiguration.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUnstableAudioDetailsContent: FfiConverterRustBuffer {
    typealias SwiftType = UnstableAudioDetailsContent?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnstableAudioDetailsContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnstableAudioDetailsContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUnstableVoiceContent: FfiConverterRustBuffer {
    typealias SwiftType = UnstableVoiceContent?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUnstableVoiceContent.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUnstableVoiceContent.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeVideoInfo: FfiConverterRustBuffer {
    typealias SwiftType = VideoInfo?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVideoInfo.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVideoInfo.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAccountManagementAction: FfiConverterRustBuffer {
    typealias SwiftType = AccountManagementAction?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAccountManagementAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAccountManagementAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAssetType: FfiConverterRustBuffer {
    typealias SwiftType = AssetType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAssetType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAssetType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeAuthData: FfiConverterRustBuffer {
    typealias SwiftType = AuthData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeAuthData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeAuthData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeEventSendState: FfiConverterRustBuffer {
    typealias SwiftType = EventSendState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventSendState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventSendState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = HistoryVisibility?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeHistoryVisibility.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeHistoryVisibility.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeInviteAvatars: FfiConverterRustBuffer {
    typealias SwiftType = InviteAvatars?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeInviteAvatars.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeInviteAvatars.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = JoinRule?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeJoinRule.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeJoinRule.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMediaPreviews: FfiConverterRustBuffer {
    typealias SwiftType = MediaPreviews?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMediaPreviews.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMediaPreviews.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = Membership?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembership.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembership.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeMembershipChange: FfiConverterRustBuffer {
    typealias SwiftType = MembershipChange?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeMembershipChange.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeMembershipChange.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeOidcPrompt: FfiConverterRustBuffer {
    typealias SwiftType = OidcPrompt?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeOidcPrompt.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeOidcPrompt.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePublicRoomJoinRule: FfiConverterRustBuffer {
    typealias SwiftType = PublicRoomJoinRule?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePublicRoomJoinRule.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePublicRoomJoinRule.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypePushFormat: FfiConverterRustBuffer {
    typealias SwiftType = PushFormat?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypePushFormat.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypePushFormat.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoomHistoryVisibility: FfiConverterRustBuffer {
    typealias SwiftType = RoomHistoryVisibility?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomHistoryVisibility.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomHistoryVisibility.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeRoomNotificationMode: FfiConverterRustBuffer {
    typealias SwiftType = RoomNotificationMode?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeRoomNotificationMode.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeRoomNotificationMode.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeShieldState: FfiConverterRustBuffer {
    typealias SwiftType = ShieldState?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeShieldState.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeShieldState.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeUploadSource: FfiConverterRustBuffer {
    typealias SwiftType = UploadSource?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUploadSource.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUploadSource.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeVirtualTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = VirtualTimelineItem?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeVirtualTimelineItem.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeVirtualTimelineItem.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeEventItemOrigin: FfiConverterRustBuffer {
    typealias SwiftType = EventItemOrigin?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEventItemOrigin.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEventItemOrigin.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceBackupSteadyStateListener: FfiConverterRustBuffer {
    typealias SwiftType = BackupSteadyStateListener?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceBackupSteadyStateListener.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceBackupSteadyStateListener.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceClientDelegate: FfiConverterRustBuffer {
    typealias SwiftType = ClientDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceClientDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceClientDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceNotificationSettingsDelegate: FfiConverterRustBuffer {
    typealias SwiftType = NotificationSettingsDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceNotificationSettingsDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceNotificationSettingsDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceProgressWatcher: FfiConverterRustBuffer {
    typealias SwiftType = ProgressWatcher?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceProgressWatcher.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceProgressWatcher.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionCallbackInterfaceSessionVerificationControllerDelegate: FfiConverterRustBuffer {
    typealias SwiftType = SessionVerificationControllerDelegate?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterCallbackInterfaceSessionVerificationControllerDelegate.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeRoomHero: FfiConverterRustBuffer {
    typealias SwiftType = [RoomHero]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRoomHero.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRoomHero.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeRoomMember.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeRoomMember.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionSequenceTypeAction: FfiConverterRustBuffer {
    typealias SwiftType = [Action]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAction.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAction.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionDictionaryStringInt64: FfiConverterRustBuffer {
    typealias SwiftType = [String: Int64]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterDictionaryStringInt64.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterDictionaryStringInt64.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterOptionTypeTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Timestamp?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTimestamp.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTimestamp.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceUInt16: FfiConverterRustBuffer {
    typealias SwiftType = [UInt16]

    public static func write(_ value: [UInt16], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterUInt16.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UInt16] {
        let len: Int32 = try readInt(&buf)
        var seq = [UInt16]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterUInt16.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceFloat: FfiConverterRustBuffer {
    typealias SwiftType = [Float]

    public static func write(_ value: [Float], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterFloat.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Float] {
        let len: Int32 = try readInt(&buf)
        var seq = [Float]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterFloat.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceString: FfiConverterRustBuffer {
    typealias SwiftType = [String]

    public static func write(_ value: [String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterString.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String] {
        let len: Int32 = try readInt(&buf)
        var seq = [String]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterString.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceData: FfiConverterRustBuffer {
    typealias SwiftType = [Data]

    public static func write(_ value: [Data], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Data] {
        let len: Int32 = try readInt(&buf)
        var seq = [Data]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoom: FfiConverterRustBuffer {
    typealias SwiftType = [Room]

    public static func write(_ value: [Room], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Room] {
        let len: Int32 = try readInt(&buf)
        var seq = [Room]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoom.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSessionVerificationEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [SessionVerificationEmoji]

    public static func write(_ value: [SessionVerificationEmoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSessionVerificationEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SessionVerificationEmoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [SessionVerificationEmoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSessionVerificationEmoji.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTimelineItem: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineItem]

    public static func write(_ value: [TimelineItem], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineItem.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineItem] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineItem]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineItem.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeConditionalPushRule: FfiConverterRustBuffer {
    typealias SwiftType = [ConditionalPushRule]

    public static func write(_ value: [ConditionalPushRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeConditionalPushRule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ConditionalPushRule] {
        let len: Int32 = try readInt(&buf)
        var seq = [ConditionalPushRule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeConditionalPushRule.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeIdentityStatusChange: FfiConverterRustBuffer {
    typealias SwiftType = [IdentityStatusChange]

    public static func write(_ value: [IdentityStatusChange], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeIdentityStatusChange.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [IdentityStatusChange] {
        let len: Int32 = try readInt(&buf)
        var seq = [IdentityStatusChange]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeIdentityStatusChange.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeKnockRequest: FfiConverterRustBuffer {
    typealias SwiftType = [KnockRequest]

    public static func write(_ value: [KnockRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeKnockRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [KnockRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [KnockRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeKnockRequest.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLeaveSpaceRoom: FfiConverterRustBuffer {
    typealias SwiftType = [LeaveSpaceRoom]

    public static func write(_ value: [LeaveSpaceRoom], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLeaveSpaceRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LeaveSpaceRoom] {
        let len: Int32 = try readInt(&buf)
        var seq = [LeaveSpaceRoom]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLeaveSpaceRoom.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeLiveLocationShare: FfiConverterRustBuffer {
    typealias SwiftType = [LiveLocationShare]

    public static func write(_ value: [LiveLocationShare], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLiveLocationShare.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LiveLocationShare] {
        let len: Int32 = try readInt(&buf)
        var seq = [LiveLocationShare]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLiveLocationShare.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeNotificationItemsRequest: FfiConverterRustBuffer {
    typealias SwiftType = [NotificationItemsRequest]

    public static func write(_ value: [NotificationItemsRequest], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeNotificationItemsRequest.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [NotificationItemsRequest] {
        let len: Int32 = try readInt(&buf)
        var seq = [NotificationItemsRequest]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeNotificationItemsRequest.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePatternedPushRule: FfiConverterRustBuffer {
    typealias SwiftType = [PatternedPushRule]

    public static func write(_ value: [PatternedPushRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePatternedPushRule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PatternedPushRule] {
        let len: Int32 = try readInt(&buf)
        var seq = [PatternedPushRule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePatternedPushRule.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePollAnswer: FfiConverterRustBuffer {
    typealias SwiftType = [PollAnswer]

    public static func write(_ value: [PollAnswer], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePollAnswer.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PollAnswer] {
        let len: Int32 = try readInt(&buf)
        var seq = [PollAnswer]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePollAnswer.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeReaction: FfiConverterRustBuffer {
    typealias SwiftType = [Reaction]

    public static func write(_ value: [Reaction], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReaction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Reaction] {
        let len: Int32 = try readInt(&buf)
        var seq = [Reaction]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReaction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeReactionSenderData: FfiConverterRustBuffer {
    typealias SwiftType = [ReactionSenderData]

    public static func write(_ value: [ReactionSenderData], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeReactionSenderData.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [ReactionSenderData] {
        let len: Int32 = try readInt(&buf)
        var seq = [ReactionSenderData]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeReactionSenderData.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRecentEmoji: FfiConverterRustBuffer {
    typealias SwiftType = [RecentEmoji]

    public static func write(_ value: [RecentEmoji], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRecentEmoji.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RecentEmoji] {
        let len: Int32 = try readInt(&buf)
        var seq = [RecentEmoji]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRecentEmoji.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoomDescription: FfiConverterRustBuffer {
    typealias SwiftType = [RoomDescription]

    public static func write(_ value: [RoomDescription], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomDescription.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomDescription] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomDescription]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomDescription.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoomHero: FfiConverterRustBuffer {
    typealias SwiftType = [RoomHero]

    public static func write(_ value: [RoomHero], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomHero.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomHero] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomHero]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomHero.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoomMember: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMember]

    public static func write(_ value: [RoomMember], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMember.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMember] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMember]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMember.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSimplePushRule: FfiConverterRustBuffer {
    typealias SwiftType = [SimplePushRule]

    public static func write(_ value: [SimplePushRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSimplePushRule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SimplePushRule] {
        let len: Int32 = try readInt(&buf)
        var seq = [SimplePushRule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSimplePushRule.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSpaceRoom: FfiConverterRustBuffer {
    typealias SwiftType = [SpaceRoom]

    public static func write(_ value: [SpaceRoom], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSpaceRoom.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SpaceRoom] {
        let len: Int32 = try readInt(&buf)
        var seq = [SpaceRoom]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSpaceRoom.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUserPowerLevelUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [UserPowerLevelUpdate]

    public static func write(_ value: [UserPowerLevelUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserPowerLevelUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserPowerLevelUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserPowerLevelUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserPowerLevelUpdate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeUserProfile: FfiConverterRustBuffer {
    typealias SwiftType = [UserProfile]

    public static func write(_ value: [UserProfile], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUserProfile.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [UserProfile] {
        let len: Int32 = try readInt(&buf)
        var seq = [UserProfile]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUserProfile.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAction: FfiConverterRustBuffer {
    typealias SwiftType = [Action]

    public static func write(_ value: [Action], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAction.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Action] {
        let len: Int32 = try readInt(&buf)
        var seq = [Action]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAction.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeAllowRule: FfiConverterRustBuffer {
    typealias SwiftType = [AllowRule]

    public static func write(_ value: [AllowRule], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAllowRule.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AllowRule] {
        let len: Int32 = try readInt(&buf)
        var seq = [AllowRule]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAllowRule.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeDraftAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [DraftAttachment]

    public static func write(_ value: [DraftAttachment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeDraftAttachment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [DraftAttachment] {
        let len: Int32 = try readInt(&buf)
        var seq = [DraftAttachment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeDraftAttachment.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeFilterTimelineEventType: FfiConverterRustBuffer {
    typealias SwiftType = [FilterTimelineEventType]

    public static func write(_ value: [FilterTimelineEventType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFilterTimelineEventType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FilterTimelineEventType] {
        let len: Int32 = try readInt(&buf)
        var seq = [FilterTimelineEventType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFilterTimelineEventType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGalleryItemInfo: FfiConverterRustBuffer {
    typealias SwiftType = [GalleryItemInfo]

    public static func write(_ value: [GalleryItemInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGalleryItemInfo.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GalleryItemInfo] {
        let len: Int32 = try readInt(&buf)
        var seq = [GalleryItemInfo]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGalleryItemInfo.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeGalleryItemType: FfiConverterRustBuffer {
    typealias SwiftType = [GalleryItemType]

    public static func write(_ value: [GalleryItemType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeGalleryItemType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [GalleryItemType] {
        let len: Int32 = try readInt(&buf)
        var seq = [GalleryItemType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeGalleryItemType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeMembership: FfiConverterRustBuffer {
    typealias SwiftType = [Membership]

    public static func write(_ value: [Membership], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeMembership.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Membership] {
        let len: Int32 = try readInt(&buf)
        var seq = [Membership]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeMembership.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeOidcPrompt: FfiConverterRustBuffer {
    typealias SwiftType = [OidcPrompt]

    public static func write(_ value: [OidcPrompt], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeOidcPrompt.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [OidcPrompt] {
        let len: Int32 = try readInt(&buf)
        var seq = [OidcPrompt]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeOidcPrompt.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypePushCondition: FfiConverterRustBuffer {
    typealias SwiftType = [PushCondition]

    public static func write(_ value: [PushCondition], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePushCondition.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PushCondition] {
        let len: Int32 = try readInt(&buf)
        var seq = [PushCondition]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePushCondition.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoomDirectorySearchEntryUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [RoomDirectorySearchEntryUpdate]

    public static func write(_ value: [RoomDirectorySearchEntryUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomDirectorySearchEntryUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomDirectorySearchEntryUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomDirectorySearchEntryUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomDirectorySearchEntryUpdate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoomListEntriesDynamicFilterKind: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntriesDynamicFilterKind]

    public static func write(_ value: [RoomListEntriesDynamicFilterKind], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntriesDynamicFilterKind.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntriesDynamicFilterKind] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntriesDynamicFilterKind]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntriesDynamicFilterKind.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoomListEntriesUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [RoomListEntriesUpdate]

    public static func write(_ value: [RoomListEntriesUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomListEntriesUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomListEntriesUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomListEntriesUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomListEntriesUpdate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeRoomMessageEventMessageType: FfiConverterRustBuffer {
    typealias SwiftType = [RoomMessageEventMessageType]

    public static func write(_ value: [RoomMessageEventMessageType], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeRoomMessageEventMessageType.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [RoomMessageEventMessageType] {
        let len: Int32 = try readInt(&buf)
        var seq = [RoomMessageEventMessageType]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeRoomMessageEventMessageType.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSlidingSyncVersion: FfiConverterRustBuffer {
    typealias SwiftType = [SlidingSyncVersion]

    public static func write(_ value: [SlidingSyncVersion], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSlidingSyncVersion.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SlidingSyncVersion] {
        let len: Int32 = try readInt(&buf)
        var seq = [SlidingSyncVersion]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSlidingSyncVersion.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeSpaceListUpdate: FfiConverterRustBuffer {
    typealias SwiftType = [SpaceListUpdate]

    public static func write(_ value: [SpaceListUpdate], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeSpaceListUpdate.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [SpaceListUpdate] {
        let len: Int32 = try readInt(&buf)
        var seq = [SpaceListUpdate]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeSpaceListUpdate.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTimelineDiff: FfiConverterRustBuffer {
    typealias SwiftType = [TimelineDiff]

    public static func write(_ value: [TimelineDiff], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTimelineDiff.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineDiff] {
        let len: Int32 = try readInt(&buf)
        var seq = [TimelineDiff]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTimelineDiff.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeTraceLogPacks: FfiConverterRustBuffer {
    typealias SwiftType = [TraceLogPacks]

    public static func write(_ value: [TraceLogPacks], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeTraceLogPacks.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TraceLogPacks] {
        let len: Int32 = try readInt(&buf)
        var seq = [TraceLogPacks]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeTraceLogPacks.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterSequenceTypeWidgetEventFilter: FfiConverterRustBuffer {
    typealias SwiftType = [WidgetEventFilter]

    public static func write(_ value: [WidgetEventFilter], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeWidgetEventFilter.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [WidgetEventFilter] {
        let len: Int32 = try readInt(&buf)
        var seq = [WidgetEventFilter]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeWidgetEventFilter.read(from: &buf))
        }
        return seq
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringInt32: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int32], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt32.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int32] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int32]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt32.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringInt64: FfiConverterRustBuffer {
    public static func write(_ value: [String: Int64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Int64] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Int64]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringString: FfiConverterRustBuffer {
    public static func write(_ value: [String: String], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: String] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: String]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeIgnoredUser: FfiConverterRustBuffer {
    public static func write(_ value: [String: IgnoredUser], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeIgnoredUser.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: IgnoredUser] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: IgnoredUser]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeIgnoredUser.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeReceipt: FfiConverterRustBuffer {
    public static func write(_ value: [String: Receipt], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeReceipt.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: Receipt] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: Receipt]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeReceipt.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringTypeBatchNotificationResult: FfiConverterRustBuffer {
    public static func write(_ value: [String: BatchNotificationResult], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterTypeBatchNotificationResult.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: BatchNotificationResult] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: BatchNotificationResult]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterTypeBatchNotificationResult.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryStringSequenceString: FfiConverterRustBuffer {
    public static func write(_ value: [String: [String]], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterString.write(key, into: &buf)
            FfiConverterSequenceString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [String: [String]] {
        let len: Int32 = try readInt(&buf)
        var dict = [String: [String]]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterString.read(from: &buf)
            let value = try FfiConverterSequenceString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeTagNameTypeTagInfo: FfiConverterRustBuffer {
    public static func write(_ value: [TagName: TagInfo], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeTagName.write(key, into: &buf)
            FfiConverterTypeTagInfo.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TagName: TagInfo] {
        let len: Int32 = try readInt(&buf)
        var dict = [TagName: TagInfo]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeTagName.read(from: &buf)
            let value = try FfiConverterTypeTagInfo.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
fileprivate struct FfiConverterDictionaryTypeTimelineEventTypeInt64: FfiConverterRustBuffer {
    public static func write(_ value: [TimelineEventType: Int64], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeTimelineEventType.write(key, into: &buf)
            FfiConverterInt64.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [TimelineEventType: Int64] {
        let len: Int32 = try readInt(&buf)
        var dict = [TimelineEventType: Int64]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeTimelineEventType.read(from: &buf)
            let value = try FfiConverterInt64.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}


/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Timestamp = UInt64

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public struct FfiConverterTypeTimestamp: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Timestamp {
        return try FfiConverterUInt64.read(from: &buf)
    }

    public static func write(_ value: Timestamp, into buf: inout [UInt8]) {
        return FfiConverterUInt64.write(value, into: &buf)
    }

    public static func lift(_ value: UInt64) throws -> Timestamp {
        return try FfiConverterUInt64.lift(value)
    }

    public static func lower(_ value: Timestamp) -> UInt64 {
        return FfiConverterUInt64.lower(value)
    }
}


#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lift(_ value: UInt64) throws -> Timestamp {
    return try FfiConverterTypeTimestamp.lift(value)
}

#if swift(>=5.8)
@_documentation(visibility: private)
#endif
public func FfiConverterTypeTimestamp_lower(_ value: Timestamp) -> UInt64 {
    return FfiConverterTypeTimestamp.lower(value)
}

private let UNIFFI_RUST_FUTURE_POLL_READY: Int8 = 0
private let UNIFFI_RUST_FUTURE_POLL_WAKE: Int8 = 1

fileprivate let uniffiContinuationHandleMap = UniffiHandleMap<UnsafeContinuation<Int8, Never>>()

fileprivate func uniffiRustCallAsync<F, T>(
    rustFutureFunc: () -> UInt64,
    pollFunc: (UInt64, @escaping UniffiRustFutureContinuationCallback, UInt64) -> (),
    completeFunc: (UInt64, UnsafeMutablePointer<RustCallStatus>) -> F,
    freeFunc: (UInt64) -> (),
    liftFunc: (F) throws -> T,
    errorHandler: ((RustBuffer) throws -> Swift.Error)?
) async throws -> T {
    // Make sure to call the ensure init function since future creation doesn't have a
    // RustCallStatus param, so doesn't use makeRustCall()
    uniffiEnsureMatrixSdkFfiInitialized()
    let rustFuture = rustFutureFunc()
    defer {
        freeFunc(rustFuture)
    }
    var pollResult: Int8;
    repeat {
        pollResult = await withUnsafeContinuation {
            pollFunc(
                rustFuture,
                { handle, pollResult in
                    uniffiFutureContinuationCallback(handle: handle, pollResult: pollResult)
                },
                uniffiContinuationHandleMap.insert(obj: $0)
            )
        }
    } while pollResult != UNIFFI_RUST_FUTURE_POLL_READY

    return try liftFunc(makeRustCall(
        { completeFunc(rustFuture, $0) },
        errorHandler: errorHandler
    ))
}

// Callback handlers for an async calls.  These are invoked by Rust when the future is ready.  They
// lift the return value or error and resume the suspended function.
fileprivate func uniffiFutureContinuationCallback(handle: UInt64, pollResult: Int8) {
    if let continuation = try? uniffiContinuationHandleMap.remove(handle: handle) {
        continuation.resume(returning: pollResult)
    } else {
        print("uniffiFutureContinuationCallback invalid handle")
    }
}
public func sdkGitSha() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_sdk_git_sha($0
    )
})
}
public func genTransactionId() -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_gen_transaction_id($0
    )
})
}
/**
 * Set the global enablement level for the Sentry layer (after the logs have
 * been set up).
 */
public func enableSentryLogging(enabled: Bool)  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_enable_sentry_logging(
        FfiConverterBool.lower(enabled),$0
    )
}
}
/**
 * Sets up logs and the tokio runtime for the current application.
 *
 * If `use_lightweight_tokio_runtime` is set to true, this will set up a
 * lightweight tokio runtime, for processes that have memory limitations (like
 * the NSE process on iOS). Otherwise, this can remain false, in which case a
 * multithreaded tokio runtime will be set up.
 */
public func initPlatform(config: TracingConfiguration, useLightweightTokioRuntime: Bool)throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_init_platform(
        FfiConverterTypeTracingConfiguration_lower(config),
        FfiConverterBool.lower(useLightweightTokioRuntime),$0
    )
}
}
/**
 * Updates the tracing subscriber with a new file writer based on the provided
 * configuration.
 *
 * This method will throw if `init_platform` hasn't been called, or if it was
 * called with `write_to_files` set to `None`.
 */
public func reloadTracingFileWriter(configuration: TracingFileConfiguration)throws   {try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_reload_tracing_file_writer(
        FfiConverterTypeTracingFileConfiguration_lower(configuration),$0
    )
}
}
/**
 * Generates a `matrix.to` permalink to the given room alias.
 */
public func matrixToRoomAliasPermalink(roomAlias: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_matrix_to_room_alias_permalink(
        FfiConverterString.lower(roomAlias),$0
    )
})
}
/**
 * Verifies the passed `String` matches the expected room alias format:
 *
 * This means it's lowercase, with no whitespace chars, has a single leading
 * `#` char and a single `:` separator between the local and domain parts, and
 * the local part only contains characters that can't be percent encoded.
 */
public func isRoomAliasFormatValid(alias: String) -> Bool  {
    return try!  FfiConverterBool.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_is_room_alias_format_valid(
        FfiConverterString.lower(alias),$0
    )
})
}
/**
 * Transforms a Room's display name into a valid room alias name.
 */
public func roomAliasNameFromRoomDisplayName(roomName: String) -> String  {
    return try!  FfiConverterString.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_room_alias_name_from_room_display_name(
        FfiConverterString.lower(roomName),$0
    )
})
}
/**
 * Generates a `matrix.to` permalink to the given userID.
 */
public func matrixToUserPermalink(userId: String)throws  -> String  {
    return try  FfiConverterString.lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_matrix_to_user_permalink(
        FfiConverterString.lower(userId),$0
    )
})
}
/**
 * Get the suggested power level for the given role.
 *
 * Returns an error if the value of the power level is unsupported.
 */
public func suggestedPowerLevelForRole(role: RoomMemberRole)throws  -> PowerLevel  {
    return try  FfiConverterTypePowerLevel_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_suggested_power_level_for_role(
        FfiConverterTypeRoomMemberRole_lower(role),$0
    )
})
}
/**
 * Get the suggested role for the given power level.
 *
 * Returns an error if the value of the power level is out of range for numbers
 * accepted in canonical JSON.
 */
public func suggestedRoleForPowerLevel(powerLevel: PowerLevel)throws  -> RoomMemberRole  {
    return try  FfiConverterTypeRoomMemberRole_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_suggested_role_for_power_level(
        FfiConverterTypePowerLevel_lower(powerLevel),$0
    )
})
}
/**
 * Creates a [`RoomMessageEventContentWithoutRelation`] given a
 * [`MessageContent`] value.
 */
public func contentWithoutRelationFromMessage(message: MessageContent)throws  -> RoomMessageEventContentWithoutRelation  {
    return try  FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_content_without_relation_from_message(
        FfiConverterTypeMessageContent_lower(message),$0
    )
})
}
public func messageEventContentFromHtml(body: String, htmlBody: String) -> RoomMessageEventContentWithoutRelation  {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html(
        FfiConverterString.lower(body),
        FfiConverterString.lower(htmlBody),$0
    )
})
}
public func messageEventContentFromHtmlAsEmote(body: String, htmlBody: String) -> RoomMessageEventContentWithoutRelation  {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_html_as_emote(
        FfiConverterString.lower(body),
        FfiConverterString.lower(htmlBody),$0
    )
})
}
public func messageEventContentFromMarkdown(md: String) -> RoomMessageEventContentWithoutRelation  {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown(
        FfiConverterString.lower(md),$0
    )
})
}
public func messageEventContentFromMarkdownAsEmote(md: String) -> RoomMessageEventContentWithoutRelation  {
    return try!  FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_from_markdown_as_emote(
        FfiConverterString.lower(md),$0
    )
})
}
public func messageEventContentNew(msgtype: MessageType)throws  -> RoomMessageEventContentWithoutRelation  {
    return try  FfiConverterTypeRoomMessageEventContentWithoutRelation_lift(try rustCallWithError(FfiConverterTypeClientError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_message_event_content_new(
        FfiConverterTypeMessageType_lower(msgtype),$0
    )
})
}
/**
 * Parse a matrix entity from a given URI, be it either
 * a `matrix.to` link or a `matrix:` URI
 */
public func parseMatrixEntityFrom(uri: String) -> MatrixEntity?  {
    return try!  FfiConverterOptionTypeMatrixEntity.lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_parse_matrix_entity_from(
        FfiConverterString.lower(uri),$0
    )
})
}
/**
 * Create a caption edit.
 *
 * If no `formatted_caption` is provided, then it's assumed the `caption`
 * represents valid Markdown that can be used as the formatted caption.
 */
public func createCaptionEdit(caption: String?, formattedCaption: FormattedBody?, mentions: Mentions?) -> EditedContent  {
    return try!  FfiConverterTypeEditedContent_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_create_caption_edit(
        FfiConverterOptionString.lower(caption),
        FfiConverterOptionTypeFormattedBody.lower(formattedCaption),
        FfiConverterOptionTypeMentions.lower(mentions),$0
    )
})
}
/**
 * Log an event.
 *
 * The target should be something like a module path, and can be referenced in
 * the filter string given to `init_platform`. `level` and `target` for a
 * callsite are fixed at the first `log_event` call for that callsite and can
 * not be changed afterwards, i.e. the level and target passed for second and
 * following `log_event`s with the same callsite will be ignored.
 *
 * This function leaks a little bit of memory for each unique (file + line +
 * level + target) it is called with. Please make sure that the number of
 * different combinations of those parameters this can be called with is
 * constant in the final executable.
 */
public func logEvent(file: String, line: UInt32?, level: LogLevel, target: String, message: String)  {try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_log_event(
        FfiConverterString.lower(file),
        FfiConverterOptionUInt32.lower(line),
        FfiConverterTypeLogLevel_lower(level),
        FfiConverterString.lower(target),
        FfiConverterString.lower(message),$0
    )
}
}
/**
 * Create the actual url that can be used to setup the WebView or IFrame
 * that contains the widget.
 *
 * # Arguments
 * * `widget_settings` - The widget settings to generate the url for.
 * * `room` - A Matrix room which is used to query the logged in username
 * * `props` - Properties from the client that can be used by a widget to adapt
 * to the client. e.g. language, font-scale...
 */
public func generateWebviewUrl(widgetSettings: WidgetSettings, room: Room, props: ClientProperties)async throws  -> String  {
    return
        try  await uniffiRustCallAsync(
            rustFutureFunc: {
                uniffi_matrix_sdk_ffi_fn_func_generate_webview_url(FfiConverterTypeWidgetSettings_lower(widgetSettings),FfiConverterTypeRoom_lower(room),FfiConverterTypeClientProperties_lower(props)
                )
            },
            pollFunc: ffi_matrix_sdk_ffi_rust_future_poll_rust_buffer,
            completeFunc: ffi_matrix_sdk_ffi_rust_future_complete_rust_buffer,
            freeFunc: ffi_matrix_sdk_ffi_rust_future_free_rust_buffer,
            liftFunc: FfiConverterString.lift,
            errorHandler: FfiConverterTypeParseError_lift
        )
}
/**
 * The Capabilities required to run a element call widget.
 *
 * This is intended to be used in combination with: `acquire_capabilities` of
 * the `CapabilitiesProvider`.
 *
 * `acquire_capabilities` can simply return the `WidgetCapabilities` from this
 * function. Even if there are non intersecting permissions to what the widget
 * requested.
 *
 * Editing and extending the capabilities from this function is also possible,
 * but should only be done as temporal workarounds until this function is
 * adjusted
 */
public func getElementCallRequiredPermissions(ownUserId: String, ownDeviceId: String) -> WidgetCapabilities  {
    return try!  FfiConverterTypeWidgetCapabilities_lift(try! rustCall() {
    uniffi_matrix_sdk_ffi_fn_func_get_element_call_required_permissions(
        FfiConverterString.lower(ownUserId),
        FfiConverterString.lower(ownDeviceId),$0
    )
})
}
public func makeWidgetDriver(settings: WidgetSettings)throws  -> WidgetDriverAndHandle  {
    return try  FfiConverterTypeWidgetDriverAndHandle_lift(try rustCallWithError(FfiConverterTypeParseError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_make_widget_driver(
        FfiConverterTypeWidgetSettings_lower(settings),$0
    )
})
}
/**
 * `WidgetSettings` are usually created from a state event.
 * (currently unimplemented)
 *
 * In some cases the client wants to create custom `WidgetSettings`
 * for specific rooms based on other conditions.
 * This function returns a `WidgetSettings` object which can be used
 * to setup a widget using `run_client_widget_api`
 * and to generate the correct url for the widget.
 *
 * # Arguments
 *
 * * `props` - A struct containing the configuration parameters for a element
 * call widget.
 */
public func newVirtualElementCallWidget(props: VirtualElementCallWidgetProperties, config: VirtualElementCallWidgetConfig)throws  -> WidgetSettings  {
    return try  FfiConverterTypeWidgetSettings_lift(try rustCallWithError(FfiConverterTypeParseError_lift) {
    uniffi_matrix_sdk_ffi_fn_func_new_virtual_element_call_widget(
        FfiConverterTypeVirtualElementCallWidgetProperties_lower(props),
        FfiConverterTypeVirtualElementCallWidgetConfig_lower(config),$0
    )
})
}

private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private let initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 30
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_matrix_sdk_ffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_sdk_git_sha() != 4038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_gen_transaction_id() != 50486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_enable_sentry_logging() != 7613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_init_platform() != 14462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_reload_tracing_file_writer() != 7613) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_matrix_to_room_alias_permalink() != 4370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_is_room_alias_format_valid() != 32456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_room_alias_name_from_room_display_name() != 64531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_matrix_to_user_permalink() != 8284) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_suggested_power_level_for_role() != 52982) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_suggested_role_for_power_level() != 1141) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_content_without_relation_from_message() != 11794) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html() != 47401) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_html_as_emote() != 56994) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown() != 53788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_from_markdown_as_emote() != 33485) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_message_event_content_new() != 33472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_parse_matrix_entity_from() != 43356) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_create_caption_edit() != 57776) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_log_event() != 28696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_generate_webview_url() != 42271) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_get_element_call_required_permissions() != 40493) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_make_widget_driver() != 16495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_func_new_virtual_element_call_widget() != 6216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommessageeventcontentwithoutrelation_with_mentions() != 23475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_sliding_sync_version() != 8075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supported_oidc_prompts() != 39919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_oidc_login() != 22858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_password_login() != 1406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_supports_sso_login() != 19696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_homeserverlogindetails_url() != 19766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_ssohandler_finish() != 56350) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_ssohandler_url() != 633) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_abort_oidc_auth() != 17052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_account_data() != 23790) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_account_url() != 53991) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_available_sliding_sync_versions() != 46726) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_avatar_url() != 26042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_await_room_remote_echo() != 5412) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_cached_avatar_url() != 30527) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_can_deactivate_account() != 27747) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_clear_caches() != 61351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_create_room() != 12931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_custom_login_with_jwt() != 16219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_deactivate_account() != 7894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_delete_pusher() != 20472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_device_id() != 63337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_display_name() != 20054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_enable_all_send_queues() != 53800) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_enable_send_queue_upload_progress() != 30956) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_encryption() != 13362) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_fetch_media_preview_config() != 53942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_dm_room() != 3705) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_invite_avatars_display_policy() != 16387) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_max_media_upload_size() != 54634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_content() != 30321) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_file() != 41198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_preview_display_policy() != 62158) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_media_thumbnail() != 23704) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_notification_settings() != 625) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_profile() != 3999) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_recently_visited_rooms() != 43351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_room() != 63699) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_alias() != 48007) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_room_preview_from_room_id() != 58119) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_session_verification_controller() != 64657) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_store_sizes() != 47046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_url() != 46254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_homeserver() != 26707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_homeserver_login_details() != 63281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_ignore_user() != 30519) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_ignored_users() != 57288) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_is_livekit_rtc_supported() != 48327) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_is_login_with_qr_code_supported() != 14689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_is_report_room_api_supported() != 48577) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_is_room_alias_available() != 53090) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id() != 28397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_join_room_by_id_or_alias() != 16138) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_knock() != 40592) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login() != 48373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login_with_email() != 22630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_login_with_oidc_callback() != 63441) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_logout() != 54411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_new_grant_login_with_qr_code_handler() != 59558) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_new_login_with_qr_code_handler() != 37543) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_notification_client() != 17687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_observe_account_data_event() != 40713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_observe_room_account_data_event() != 46899) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_optimize_stores() != 53467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_register_notification_handler() != 46860) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_remove_avatar() != 12536) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_reset_supported_versions() != 12909) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_reset_well_known() != 52054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_resolve_room_alias() != 16053) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_restore_session() != 56243) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_restore_session_with() != 21462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_room_alias_exists() != 5713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_room_directory_search() != 4257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_rooms() != 57092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_search_users() != 23484) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_server() != 11140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_server_vendor_info() != 25767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_session() != 47980) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_account_data() != 56242) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_delegate() != 377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_display_name() != 47937) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_invite_avatars_display_policy() != 57486) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_media_preview_display_policy() != 27881) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_media_retention_policy() != 45052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_pusher() != 51438) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_set_utd_delegate() != 38853) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_sliding_sync_version() != 55440) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_space_service() != 19054) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_start_sso_login() != 11891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_ignored_users() != 10184) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_media_preview_config() != 11612) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_room_info() != 3308) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_status() != 39397) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_subscribe_to_send_queue_updates() != 53470) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_sync_service() != 47464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_track_recently_visited_room() != 40498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_unignore_user() != 2582) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_upload_avatar() != 14839) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_upload_media() != 19621) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_url_for_oidc() != 50450) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_user_id() != 11375) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_user_id_server_name() != 52727) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_add_recent_emoji() != 15952) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_client_get_recent_emojis() != 49975) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_path() != 42046) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediafilehandle_persist() != 34214) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_add_root_certificates() != 60910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_backups() != 19978) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_auto_enable_cross_signing() != 41588) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_backup_download_strategy() != 5278) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_build() != 21717) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_cross_process_store_locks_holder_name() != 56336) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_decryption_settings() != 36533) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_automatic_token_refresh() != 60164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_built_in_root_certificates() != 34380) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_disable_ssl_verification() != 17095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_oidc_refresh_lock() != 54805) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_enable_share_history_on_invite() != 47743) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_homeserver_url() != 27846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_in_memory_store() != 7770) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_proxy() != 56894) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_request_config() != 41133) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_room_key_recipient_strategy() != 7083) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name() != 27235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_server_name_or_homeserver_url() != 11561) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_session_paths() != 52143) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_set_session_delegate() != 35713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sliding_sync_version_builder() != 39928) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_sqlite_store() != 54280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_system_is_memory_constrained() != 64472) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_threads_enabled() != 10698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_user_agent() != 31638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientbuilder_username() != 9349) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_exists_on_server() != 16984) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state() != 60707) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_backup_state_listener() != 14813) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_curve25519_key() != 25462) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_disable_recovery() != 43697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_ed25519_key() != 30741) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_backups() != 61920) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_enable_recovery() != 2033) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_has_devices_to_verify_against() != 50754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_is_last_device() != 54322) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recover() != 14635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recover_and_reset() != 48062) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state() != 28660) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_recovery_state_listener() != 17926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_identity() != 47257) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_reset_recovery_key() != 15954) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_user_identity() != 39850) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state() != 29580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_verification_state_listener() != 30914) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_backup_upload_steady_state() != 28614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_encryption_wait_for_e2ee_initialization_tasks() != 23168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_auth_type() != 21421) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_cancel() != 14034) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identityresethandle_reset() != 29457) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_has_verification_violation() != 36877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_is_verified() != 27675) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_master_key() != 44140) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_pin() != 64915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_was_previously_verified() != 10595) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_useridentity_withdraw_verification() != 8452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_content() != 50738) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_event_id() != 64715) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_sender_id() != 16913) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_thread_root_event_id() != 3965) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineevent_timestamp() != 31754) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notification() != 47425) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_notifications() != 55817) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationclient_get_room() != 22250) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_homeserver_push_encrypted_event_to_device() != 46370) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_can_push_encrypted_event_to_device() != 24557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_contains_keywords_rules() != 31603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_default_room_notification_mode() != 44201) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_raw_push_rules() != 22761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_room_notification_settings() != 44589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_rooms_with_user_defined_rules() != 23908) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_get_user_defined_room_notification_mode() != 13690) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_call_enabled() != 42573) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_invite_for_me_enabled() != 24945) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_room_mention_enabled() != 4073) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_is_user_mention_enabled() != 17837) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_restore_default_room_notification_mode() != 12358) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_call_enabled() != 17088) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_custom_push_rule() != 49373) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_default_room_notification_mode() != 29804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_delegate() != 39042) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_invite_for_me_enabled() != 34082) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_mention_enabled() != 63495) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_room_notification_mode() != 21942) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_set_user_mention_enabled() != 22017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettings_unmute_room() != 54475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_checkcodesender_send() != 2180) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_grantloginwithqrcodehandler_generate() != 59049) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_grantloginwithqrcodehandler_scan() != 35786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_generate() != 27889) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_loginwithqrcodehandler_scan() != 55947) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_server_name() != 52906) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_qrcodedata_to_bytes() != 22532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_accept() != 60529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline() != 20051) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_decline_and_ban() != 23767) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestactions_mark_as_seen() != 20986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_active_members_count() != 10052) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_active_room_call_participants() != 61411) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_alternative_aliases() != 30946) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_apply_power_level_changes() != 56335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_avatar_url() != 4697) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ban_user() != 54282) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_canonical_alias() != 5795) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_clear_composer_draft() != 12270) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_clear_event_cache_storage() != 14531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_decline_call() != 12323) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_discard_room_key() != 57692) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_display_name() != 45762) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_edit() != 6689) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_enable_encryption() != 16452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_enable_send_queue() != 32996) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_encryption_state() != 35766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_fetch_thread_subscription() != 37784) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_forget() != 10622) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_get_power_levels() != 33125) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_get_room_visibility() != 49289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_has_active_room_call() != 1287) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_heroes() != 38402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_id() != 34667) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ignore_device_trust_and_resend() != 24786) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_ignore_user() != 45929) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invite_user_by_id() != 27806) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_invited_members_count() != 44865) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_inviter() != 7247) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_direct() != 61932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_encrypted() != 37204) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_public() != 31529) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_send_queue_enabled() != 5651) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_is_space() != 19377) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_join() != 65464) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_joined_members_count() != 55525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_kick_user() != 64949) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_latest_encryption_state() != 9465) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_latest_event() != 37006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_leave() != 3346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_load_composer_draft() != 61910) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_load_or_fetch_event() != 47103) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_fully_read_unchecked() != 1608) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_mark_as_read() != 38075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_event_permalink() != 30684) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_matrix_to_permalink() != 10281) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member() != 58977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_avatar_url() != 44092) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_display_name() != 26431) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_member_with_sender_info() != 36075) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_members() != 13926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_members_no_sync() != 8950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_membership() != 65038) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_own_user_id() != 32346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_predecessor_room() != 21931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_preview_room() != 20509) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_publish_room_alias_in_room_directory() != 2302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_raw_name() != 65346) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_redact() != 56590) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_remove_avatar() != 3551) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_remove_room_alias_from_room_directory() != 26389) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_report_content() != 27264) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_report_room() != 372) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_reset_power_levels() != 32610) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_room_events_debug_string() != 35772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_room_info() != 62185) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_save_composer_draft() != 42915) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_live_location() != 36351) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_send_raw() != 63831) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_is_favourite() != 1289) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_is_low_priority() != 44950) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_name() != 33828) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_thread_subscription() != 55986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_topic() != 40525) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_set_unread_flag() != 38235) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_start_live_location_share() != 43479) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_stop_live_location_share() != 19603) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_call_decline_events() != 21456) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_identity_status_changes() != 49969) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_knock_requests() != 43535) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_live_location_shares() != 48977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_room_info_updates() != 32254) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_send_queue_updates() != 36773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_subscribe_to_typing_notifications() != 12198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_successor_room() != 17951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_suggested_role_for_user() != 58040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_timeline() != 51168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_timeline_with_configuration() != 46904) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_topic() != 33844) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_typing_notice() != 26086) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_unban_user() != 25834) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_update_canonical_alias() != 35023) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_update_history_visibility() != 29249) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_update_join_rules() != 62193) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_update_power_levels_for_users() != 46007) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_update_room_visibility() != 46267) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_upload_avatar() != 43932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_room_withdraw_verification_and_resend() != 13926) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_len() != 59145) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roommembersiterator_next_chunk() != 47532) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_ban() != 52576) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_invite() != 55467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_kick() != 8759) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_pin_unpin() != 64005) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_other() != 10630) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_redact_own() != 10164) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_message() != 27531) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_send_state() != 17089) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_own_user_trigger_room_notification() != 59279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_ban() != 12687) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_invite() != 26290) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_kick() != 3923) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_pin_unpin() != 20659) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_other() != 54198) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_redact_own() != 59218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_message() != 45517) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_send_state() != 40995) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_can_user_trigger_room_notification() != 35381) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_events() != 10932) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_user_power_levels() != 48829) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompowerlevels_values() != 62886) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_is_at_last_page() != 31168) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_loaded_pages() != 59827) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_next_page() != 14719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_results() != 21645) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearch_search() != 38611) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters() != 19021) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_entries_with_dynamic_adapters_with() != 25653) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_loading_state() != 2181) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlist_room() != 50761) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_add_one_page() != 47488) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_reset_to_one_page() != 4391) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistdynamicentriescontroller_set_filter() != 8696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_controller() != 21030) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieswithdynamicadaptersresult_entries_stream() != 22467) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_all_rooms() != 4638) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_room() != 40756) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_state() != 41751) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_subscribe_to_rooms() != 1302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservice_sync_indicator() != 48386) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_has_notifications() != 57541) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_highlight_count() != 60202) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unreadnotificationscount_notification_count() != 27272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_forget() != 42918) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_info() != 16635) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_inviter() != 54424) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_leave() != 52262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roompreview_own_membership_details() != 16335) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_to_json() != 19277) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediasource_url() != 53516) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_accept_verification_request() != 56039) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_acknowledge_verification_request() != 22948) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_approve_verification() != 26553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_cancel_verification() != 32557) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_decline_verification() != 9058) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_device_verification() != 20402) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_request_user_verification() != 11869) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_set_delegate() != 65112) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontroller_start_sas_verification() != 56151) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_description() != 45746) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationemoji_symbol() != 54870) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_leave() != 64951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_leavespacehandle_rooms() != 40216) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_paginate() != 14784) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_pagination_state() != 6614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_rooms() != 65022) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_space() != 63772) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_pagination_state_updates() != 15348) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_room_update() != 52629) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlist_subscribe_to_space_updates() != 31589) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_add_child_to_space() != 64688) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_editable_spaces() != 9178) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_get_space_room() != 38097) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_joined_parents_of_child() != 40037) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_leave_space() != 57139) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_remove_child_from_space() != 22535) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_space_room_list() != 14788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_subscribe_to_top_level_joined_spaces() != 59416) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservice_top_level_joined_spaces() != 19973) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sqlitestorebuilder_cache_size() != 61803) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sqlitestorebuilder_journal_size_limit() != 23095) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sqlitestorebuilder_passphrase() != 45337) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sqlitestorebuilder_pool_max_size() != 41218) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sqlitestorebuilder_system_is_memory_constrained() != 19368) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_expire_sessions() != 5808) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_room_list_service() != 39986) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_start() != 42766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_state() != 56378) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservice_stop() != 40415) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_finish() != 29725) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_cross_process_lock() != 17911) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_offline_mode() != 48885) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicebuilder_with_share_pos() != 21315) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_cancel() != 12353) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_taskhandle_is_finished() != 17040) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_contains_only_emojis() != 57596) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_debug_info() != 797) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_send_handle() != 279) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_lazytimelineitemprovider_get_shields() != 46064) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_cancel() != 5666) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendattachmentjoinhandle_join() != 22211) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendhandle_abort() != 2406) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendhandle_try_resend() != 50142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_add_listener() != 38550) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_create_message_content() != 54719) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_create_poll() != 33924) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_edit() != 46968) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_end_poll() != 2766) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_details_for_event() != 22240) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_fetch_members() != 22294) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_get_event_timeline_item_by_event_id() != 40008) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_latest_event_id() != 31074) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_load_reply_details() != 11426) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_mark_as_read() != 58804) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_backwards() != 53026) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_paginate_forwards() != 35094) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_pin_event() != 40498) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_redact_event() != 42154) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_retry_decryption() != 39219) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send() != 24846) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_audio() != 52753) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_file() != 19448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_image() != 31845) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_location() != 21302) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_poll_response() != 41951) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_read_receipt() != 6077) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_reply() != 25065) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_video() != 21275) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_voice_message() != 33769) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_subscribe_to_back_pagination_status() != 27990) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_toggle_reaction() != 42673) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_unpin_event() != 18514) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timeline_send_gallery() != 64895) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_event() != 46788) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_as_virtual() != 58215) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_fmt_debug() != 59080) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelineitem_unique_id() != 32877) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_cancel() != 23182) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendgalleryjoinhandle_join() != 30455) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_threadsummary_latest_event() != 49553) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_threadsummary_num_replies() != 47977) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event() != 52000) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_inreplytodetails_event_id() != 55998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_enter() != 15935) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_exit() != 2919) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_span_is_none() != 59307) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetdriver_run() != 61502) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_recv() != 10867) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetdriverhandle_send() != 27865) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_clientbuilder_new() != 40475) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_qrcodedata_from_bytes() != 55735) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_json() != 60091) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_mediasource_from_url() != 37564) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_sqlitestorebuilder_new() != 604) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_exclude() != 17142) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_timelineeventtypefilter_include() != 18137) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_current() != 2135) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_new() != 47713) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_constructor_span_new_bridge_span() != 51316) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_accountdatalistener_on_change() != 13017) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientdelegate_did_receive_auth_error() != 38563) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_retrieve_session_from_keychain() != 43233) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_clientsessiondelegate_save_session_in_keychain() != 4452) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_ignoreduserslistener_call() != 6068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_mediapreviewconfiglistener_on_change() != 45931) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_progresswatcher_transmission_progress() != 41998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomaccountdatalistener_on_change() != 54581) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomerrorlistener_on_error() != 601) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendqueueroomupdatelistener_on_update() != 56104) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncnotificationlistener_on_notification() != 39259) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_backupstatelistener_on_update() != 43998) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_backupsteadystatelistener_on_update() != 56068) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_enablerecoveryprogresslistener_on_update() != 27773) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_recoverystatelistener_on_update() != 34195) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_verificationstatelistener_on_update() != 33992) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_notificationsettingsdelegate_settings_did_change() != 52554) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_generatedqrloginprogresslistener_on_update() != 30858) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_grantgeneratedqrloginprogresslistener_on_update() != 23453) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_grantqrloginprogresslistener_on_update() != 63807) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_qrloginprogresslistener_on_update() != 62487) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_calldeclinelistener_call() != 6360) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_identitystatuschangelistener_call() != 13891) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_knockrequestslistener_call() != 17262) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_livelocationsharelistener_call() != 15280) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roominfolistener_call() != 61614) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sendqueuelistener_on_update() != 62056) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_typingnotificationslistener_call() != 36696) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomdirectorysearchentrieslistener_on_update() != 6069) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistentrieslistener_on_update() != 12283) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistloadingstatelistener_on_update() != 34444) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservicestatelistener_on_update() != 60435) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_roomlistservicesyncindicatorlistener_on_update() != 47433) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_request() != 58189) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_accept_verification_request() != 43661) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_start_sas_verification() != 8006) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_receive_verification_data() != 8698) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_fail() != 45076) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_cancel() != 36580) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_sessionverificationcontrollerdelegate_did_finish() != 53036) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistentrieslistener_on_update() != 20303) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistpaginationstatelistener_on_update() != 4634) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceroomlistspacelistener_on_update() != 21212) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_spaceservicejoinedspaceslistener_on_update() != 21383) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_syncservicestateobserver_on_update() != 7272) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_paginationstatuslistener_on_update() != 53207) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_timelinelistener_on_update() != 35518) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_unabletodecryptdelegate_on_utd() != 3448) {
        return InitializationResult.apiChecksumMismatch
    }
    if (uniffi_matrix_sdk_ffi_checksum_method_widgetcapabilitiesprovider_acquire_capabilities() != 3738) {
        return InitializationResult.apiChecksumMismatch
    }

    uniffiCallbackInitAccountDataListener()
    uniffiCallbackInitBackupStateListener()
    uniffiCallbackInitBackupSteadyStateListener()
    uniffiCallbackInitCallDeclineListener()
    uniffiCallbackInitClientDelegate()
    uniffiCallbackInitClientSessionDelegate()
    uniffiCallbackInitEnableRecoveryProgressListener()
    uniffiCallbackInitGeneratedQrLoginProgressListener()
    uniffiCallbackInitGrantGeneratedQrLoginProgressListener()
    uniffiCallbackInitGrantQrLoginProgressListener()
    uniffiCallbackInitIdentityStatusChangeListener()
    uniffiCallbackInitIgnoredUsersListener()
    uniffiCallbackInitKnockRequestsListener()
    uniffiCallbackInitLiveLocationShareListener()
    uniffiCallbackInitMediaPreviewConfigListener()
    uniffiCallbackInitNotificationSettingsDelegate()
    uniffiCallbackInitPaginationStatusListener()
    uniffiCallbackInitProgressWatcher()
    uniffiCallbackInitQrLoginProgressListener()
    uniffiCallbackInitRecoveryStateListener()
    uniffiCallbackInitRoomAccountDataListener()
    uniffiCallbackInitRoomDirectorySearchEntriesListener()
    uniffiCallbackInitRoomInfoListener()
    uniffiCallbackInitRoomListEntriesListener()
    uniffiCallbackInitRoomListLoadingStateListener()
    uniffiCallbackInitRoomListServiceStateListener()
    uniffiCallbackInitRoomListServiceSyncIndicatorListener()
    uniffiCallbackInitSendQueueListener()
    uniffiCallbackInitSendQueueRoomErrorListener()
    uniffiCallbackInitSendQueueRoomUpdateListener()
    uniffiCallbackInitSessionVerificationControllerDelegate()
    uniffiCallbackInitSpaceRoomListEntriesListener()
    uniffiCallbackInitSpaceRoomListPaginationStateListener()
    uniffiCallbackInitSpaceRoomListSpaceListener()
    uniffiCallbackInitSpaceServiceJoinedSpacesListener()
    uniffiCallbackInitSyncNotificationListener()
    uniffiCallbackInitSyncServiceStateObserver()
    uniffiCallbackInitTimelineListener()
    uniffiCallbackInitTypingNotificationsListener()
    uniffiCallbackInitUnableToDecryptDelegate()
    uniffiCallbackInitVerificationStateListener()
    uniffiCallbackInitWidgetCapabilitiesProvider()
    uniffiEnsureMatrixSdkBaseInitialized()
    uniffiEnsureMatrixSdkCommonInitialized()
    uniffiEnsureMatrixSdkCryptoInitialized()
    uniffiEnsureMatrixSdkInitialized()
    uniffiEnsureMatrixSdkUiInitialized()
    return InitializationResult.ok
}()

// Make the ensure init function public so that other modules which have external type references to
// our types can call it.
public func uniffiEnsureMatrixSdkFfiInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all